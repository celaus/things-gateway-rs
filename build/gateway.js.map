{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src sync","webpack:///./src/addon-manager.js","webpack:///./src/app-instance.js","webpack:///./src/app.js","webpack:///./src/command-utils.js","webpack:///./src/constants.js","webpack:///./src/controllers/actions_controller.js","webpack:///./src/controllers/adapters_controller.js","webpack:///./src/controllers/addons_controller.js","webpack:///./src/controllers/commands_controller.js","webpack:///./src/controllers/debug_controller.js","webpack:///./src/controllers/events_controller.js","webpack:///./src/controllers/log_out_controller.js","webpack:///./src/controllers/login_controller.js","webpack:///./src/controllers/logs_controller.js","webpack:///./src/controllers/new_things_controller.js","webpack:///./src/controllers/oauth_controller.ts","webpack:///./src/controllers/oauthclients_controller.ts","webpack:///./src/controllers/ping_controller.js","webpack:///./src/controllers/push_controller.js","webpack:///./src/controllers/root_controller.js","webpack:///./src/controllers/settings_controller.js","webpack:///./src/controllers/things_controller.js","webpack:///./src/controllers/updates_controller.js","webpack:///./src/controllers/uploads_controller.js","webpack:///./src/controllers/users_controller.js","webpack:///./src/db.js","webpack:///./src/deferred.js","webpack:///./src/ec-crypto.ts","webpack:///./src/jwt-middleware.js","webpack:///./src/log-timestamps.js","webpack:///./src/mdns-server.js","webpack:///./src/models/action.js","webpack:///./src/models/actions.js","webpack:///./src/models/event.js","webpack:///./src/models/events.js","webpack:///./src/models/intentparser.js","webpack:///./src/models/jsonwebtoken.js","webpack:///./src/models/oauthclients.ts","webpack:///./src/models/settings.js","webpack:///./src/models/thing.js","webpack:///./src/models/things.js","webpack:///./src/models/user.js","webpack:///./src/models/users.js","webpack:///./src/oauth-types.ts","webpack:///./src/passwords.js","webpack:///./src/platform.js","webpack:///./src/plugin/adapter-proxy.js","webpack:///./src/plugin/addon-manager-proxy.js","webpack:///./src/plugin/device-proxy.js","webpack:///./src/plugin/ipc.js","webpack:///./src/plugin/plugin-client.js","webpack:///./src/plugin/plugin-server.js","webpack:///./src/plugin/plugin.js","webpack:///./src/plugin/property-proxy.js","webpack:///./src/push-service.js","webpack:///./src/router.js","webpack:///./src/rules-engine/APIError.js","webpack:///./src/rules-engine/Database.js","webpack:///./src/rules-engine/Engine.js","webpack:///./src/rules-engine/Events.js","webpack:///./src/rules-engine/Property.js","webpack:///./src/rules-engine/Rule.js","webpack:///./src/rules-engine/ThingConnection.js","webpack:///./src/rules-engine/effects/ActionEffect.js","webpack:///./src/rules-engine/effects/Effect.js","webpack:///./src/rules-engine/effects/MultiEffect.js","webpack:///./src/rules-engine/effects/NotificationEffect.js","webpack:///./src/rules-engine/effects/PropertyEffect.js","webpack:///./src/rules-engine/effects/PulseEffect.js","webpack:///./src/rules-engine/effects/SetEffect.js","webpack:///./src/rules-engine/effects/index.js","webpack:///./src/rules-engine/index.js","webpack:///./src/rules-engine/triggers/BooleanTrigger.js","webpack:///./src/rules-engine/triggers/EqualityTrigger.js","webpack:///./src/rules-engine/triggers/EventTrigger.js","webpack:///./src/rules-engine/triggers/LevelTrigger.js","webpack:///./src/rules-engine/triggers/MultiTrigger.js","webpack:///./src/rules-engine/triggers/PropertyTrigger.js","webpack:///./src/rules-engine/triggers/TimeTrigger.js","webpack:///./src/rules-engine/triggers/Trigger.js","webpack:///./src/rules-engine/triggers/index.js","webpack:///./src/ssltunnel.js","webpack:///./src/user-profile.js","webpack:///./src/utils.js","webpack:///./src/wifi-setup/app.js","webpack:///./src/wifi-setup/index.js","webpack:///./src/wifi-setup/platform.js","webpack:///./src/wifi-setup/platforms/default.js","webpack:///./src/wifi-setup/run.js","webpack:///./src/wifi-setup/wait.js","webpack:///./src/wifi-setup/wifi.js","webpack:///external \"ajv\"","webpack:///external \"archiver\"","webpack:///external \"asn1.js\"","webpack:///external \"assert\"","webpack:///external \"bcryptjs\"","webpack:///external \"body-parser\"","webpack:///external \"callsites\"","webpack:///external \"child_process\"","webpack:///external \"compression\"","webpack:///external \"config\"","webpack:///external \"crypto\"","webpack:///external \"dnssd\"","webpack:///external \"event-to-promise\"","webpack:///external \"events\"","webpack:///external \"express\"","webpack:///external \"express-fileupload\"","webpack:///external \"express-handlebars\"","webpack:///external \"express-promise-router\"","webpack:///external \"express-ws\"","webpack:///external \"fs\"","webpack:///external \"gateway-addon\"","webpack:///external \"greenlock\"","webpack:///external \"handlebars\"","webpack:///external \"http\"","webpack:///external \"https\"","webpack:///external \"ip-regex\"","webpack:///external \"jsonwebtoken\"","webpack:///external \"le-challenge-dns\"","webpack:///external \"le-store-certbot\"","webpack:///external \"mkdirp\"","webpack:///external \"nanomsg\"","webpack:///external \"ncp\"","webpack:///external \"net\"","webpack:///external \"nocache\"","webpack:///external \"node-fetch\"","webpack:///external \"node-getopt\"","webpack:///external \"os\"","webpack:///external \"path\"","webpack:///external \"process\"","webpack:///external \"promisepipe\"","webpack:///external \"readline\"","webpack:///external \"rimraf\"","webpack:///external \"semver\"","webpack:///external \"sqlite3\"","webpack:///external \"string-format\"","webpack:///external \"tar\"","webpack:///external \"tmp\"","webpack:///external \"url\"","webpack:///external \"util\"","webpack:///external \"uuid\"","webpack:///external \"web-push\"","webpack:///external \"winston\"","webpack:///external \"winston-daily-rotate-file\"","webpack:///external \"ws\""],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,gD;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,kBAAkB,mBAAO,CAAC,uCAAa;AACvC,iBAAiB,mBAAO,CAAC,qCAAY;AACrC,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,iBAAiB,mBAAO,CAAC,qCAAY;AACrC,iBAAiB,mBAAO,CAAC,mDAAmB;AAC5C,oBAAoB,mBAAO,CAAC,6CAAgB;AAC5C,cAAc,mBAAO,CAAC,+BAAS;AAC/B,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,YAAY,mBAAO,CAAC,gBAAK;AACzB,WAAW,mBAAO,CAAC,cAAI;AACvB,oBAAoB,mBAAO,CAAC,gCAAa;AACzC,cAAc,mBAAO,CAAC,8BAAY;AAClC,OAAO,gBAAgB,GAAG,mBAAO,CAAC,gBAAK;;AAEvC,YAAY,mBAAO,CAAC,uCAAiB;;AAErC;;AAEA;AACA;AACA,MAAM,IAA8C;AACpD;AACA,WAAW,OAAuB;AAClC;AACA,SAAS,2CAAO;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,QAAQ;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,QAAQ;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,QAAQ;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,QAAQ;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,QAAQ;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO,EAAE,IAAI;AAC3C,+BAA+B,WAAW,iBAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO,EAAE,IAAI;AACjE,4BAA4B,aAAa;AACzC;AACA;AACA;AACA,WAAW;AACX,uDAAuD,aAAa;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,uCAAuC,OAAO,EAAE,IAAI;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wCAAwC,YAAY,IAAI,EAAE;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,yCAAyC,YAAY,IAAI,EAAE;AAC3D;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,cAAc;AAC3D,oDAAoD,YAAY;AAChE;AACA;AACA;;AAEA;AACA;AACA,wDAAwD,cAAc;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,cAAc;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,cAAc,iBAAiB,MAAM;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,cAAc,IAAI,SAAS;AACvE;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,mDAAmD,cAAc,IAAI,EAAE;AACvE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,YAAY,IAAI,IAAI;AAC3D;;AAEA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D,mBAAmB,cAAc,wBAAwB;AACzD,gCAAgC;AAChC;AACA;AACA;;AAEA;AACA,0BAA0B,cAAc;AACxC;AACA,wCAAwC;AACxC;AACA;AACA;AACA,4EAA4E;AAC5E;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,cAAc;AACxD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,eAAe;AAC5D;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,sDAAsD,cAAc,IAAI,EAAE;AAC1E;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAO,CAAC,6DAAwB;AACnD,mBAAmB,mBAAO,CAAC,6DAAwB;;AAEnD,gDAAgD,eAAe;;AAE/D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,UAAU,IAAI,IAAI;AACpE,SAAS;AACT;AACA,KAAK;;AAEL,QAAQ,IAA+B;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,uCAAuC,YAAY,EAAE,SAAS;AAC9D,4CAA4C,KAAK;;AAEjD,mCAAmC,IAAI,MAAM,SAAS;;AAEtD;AACA;AACA;AACA,8CAA8C,WAAW;AACzD;;AAEA;AACA;AACA,KAAK;AACL,wBAAwB,YAAY;AACpC;AACA,0DAA0D,SAAS,IAAI,EAAE;AACzE;AACA,OAAO;AACP,gDAAgD,KAAK,IAAI,EAAE;AAC3D;AACA;AACA;;AAEA;AACA,wBAAwB,YAAY;AACpC;AACA,0DAA0D,SAAS,IAAI,EAAE;AACzE;AACA,OAAO;AACP,wDAAwD,KAAK;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,sBAAsB,YAAY;AAClC;AACA,wDAAwD,SAAS,IAAI,EAAE;AACvE;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,YAAY;AAC9D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,wDAAwD,UAAU,IAAI,EAAE;AACxE;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA,4CAA4C,YAAY,IAAI,EAAE;AAC9D;AACA,SAAS;AACT;AACA;;AAEA,oCAAoC,YAAY,QAAQ,UAAU;;AAElE;AACA;AACA,mBAAmB,4CAA4C;AAC/D,KAAK;AACL;AACA;;AAEA,gDAAgD,YAAY,IAAI,EAAE;AAClE;AACA;AACA;;AAEA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,wDAAwD,YAAY,IAAI,EAAE;AAC1E;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,wCAAwC,YAAY,aAAa,EAAE;AACnE;AACA;;AAEA;;AAEA;AACA,gBAAgB,qBAAa;AAC7B;AACA,eAAe,qBAAa;AAC5B;AACA,KAAK;;AAEL;AACA;AACA,yBAAyB,YAAY;AACrC;AACA,0CAA0C,YAAY,IAAI,EAAE;AAC5D;AACA,OAAO;AACP;;AAEA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,IAAI,GAAG,kBAAkB;AAC/D;AACA;AACA,+CAA+C,QAAQ;AACvD,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,wDAAwD,YAAY,IAAI,EAAE;AAC1E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,8CAA8C,UAAU,IAAI,EAAE;AAC9D;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;;AC9qCA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,wBAAS;;AAEjC;;AAEA;AACA;AACA;;AAEA;AACA,cAAc,YAAY,GAAG,eAAe;AAC5C;;AAEA;AACA;AACA,0BAA0B,aAAa;AACvC,0BAA0B,eAAe;AACzC,0BAA0B,eAAe;AACzC,2BAA2B,oBAAoB;AAC/C;AACA;;AAEA;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,mBAAO,CAAC,6CAAgB;AAC5C;AACA;;AAEA;AACA,cAAc,mBAAO,CAAC,oBAAO;AAC7B,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,cAAI;AACvB,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,kBAAkB,mBAAO,CAAC,8BAAY;AACtC,mBAAmB,mBAAO,CAAC,8CAAoB;AAC/C,mBAAmB,mBAAO,CAAC,gCAAa;AACxC,eAAe,mBAAO,CAAC,gCAAa;AACpC,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,aAAa,mBAAO,CAAC,kBAAM;AAC3B,0BAA0B,mBAAO,CAAC,8CAAoB;AACtD,gBAAgB,mBAAO,CAAC,0BAAU;;AAElC;AACA,qBAAqB,mBAAO,CAAC,+CAAiB;AAC9C,WAAW,mBAAO,CAAC,yBAAM;AACzB,mBAAmB,mBAAO,CAAC,2CAAe;AAC1C,eAAe,mBAAO,CAAC,iCAAU;AACjC,sBAAsB,mBAAO,CAAC,uCAAa;AAC3C,kBAAkB,mBAAO,CAAC,uCAAa;AACvC,OAAO,mBAAmB,GAAG,mBAAO,CAAC,+CAAc;;AAEnD;AACA,mBAAO,CAAC,iDAAkB;;AAE1B;AACA;AACA,mBAAO,CAAC,6CAAgB;;AAExB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC;AACA;AACA,sBAAsB,mBAAO,CAAC,4DAAyB;AACvD;AACA;AACA;AACA;AACA,yBAAyB,SAAS,eAAe,sBAAsB;AACvE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,2BAA2B,aAAa;;AAExC;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,yBAAyB;AACpC,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA,sBAAsB,KAAK;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,kEAAkE,IAAI;AACtE;AACA,CAAC;;AAED,kBAAkB;AAClB;AACA;AACA;AACA;;;;;;;;;;;;AC3XA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe,UAAU;AACzB,iBAAiB,EAAE;AACnB;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjUA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,eAAe,mBAAO,CAAC,gDAAkB;AACzC,gBAAgB,mBAAO,CAAC,kDAAmB;AAC3C,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,eAAe,mBAAO,CAAC,gDAAkB;;AAEzC,yCAAyC,kBAAkB;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,sCAAsC;AACrE,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,sCAAsC;AACrE,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uCAAuC;AACtE,GAAG;AACH,6BAA6B,SAAS;AACtC;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;;;;;;;;;;;;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,qBAAqB,mBAAO,CAAC,gDAAkB;;AAE/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,0CAA0C,UAAU;AACpD;AACA,CAAC;;AAED;;;;;;;;;;;;ACzCA,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,iBAAiB,mBAAO,CAAC,oDAAoB;;AAE7C;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,UAAU;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,+DAA+D,UAAU;AACzE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,uDAAuD,UAAU;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,+BAA+B,iBAAiB;AAChD,GAAG;AACH,6CAA6C,UAAU;AACvD;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,UAAU;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,+DAA+D,UAAU;AACzE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,uDAAuD,UAAU;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,OAAO;AACtC,GAAG;AACH,mDAAmD,UAAU;AAC7D;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,KAAK;AAC/B;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,8CAA8C,KAAK,IAAI,EAAE;AACzD;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,iDAAiD,UAAU,IAAI,EAAE;AACjE;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mCAAmC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,qBAAqB,mBAAO,CAAC,4DAAwB;AACrD,eAAe,mBAAO,CAAC,gDAAkB;;AAEzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;;;;;;;;;;;;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,qBAAqB,mBAAO,CAAC,gDAAkB;;AAE/C;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,yCAAyC,SAAS;AAClD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,6BAA6B,SAAS;AACtC;AACA,2CAA2C,SAAS,EAAE,MAAM;AAC5D,KAAK;AACL,GAAG;AACH,yCAAyC,SAAS;AAClD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,yCAAyC,SAAS;AAClD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,+BAA+B,SAAS;AACxC;AACA,6CAA6C,SAAS,IAAI,MAAM;AAChE,OAAO;AACP,KAAK;AACL,2CAA2C;AAC3C,OAAO,cAAc;AACrB,OAAO;AACP;AACA,GAAG;AACH,yCAAyC,SAAS;AAClD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,wCAAwC,QAAQ;AAChD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,0CAA0C,QAAQ,GAAG,MAAM;AAC3D,KAAK;AACL,GAAG;AACH,wCAAwC,QAAQ;AAChD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,8BAA8B,QAAQ;AACtC;AACA,4CAA4C,QAAQ,GAAG,MAAM;AAC7D,OAAO;AACP,KAAK;AACL,0CAA0C;AAC1C,OAAO,cAAc;AACrB,OAAO;AACP;AACA,GAAG;AACH,wCAAwC,QAAQ;AAChD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD,GAAG;AACH;AACA,2CAA2C,QAAQ,WAAW,IAAI;AAClE,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;ACtSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,eAAe,mBAAO,CAAC,gDAAkB;;AAEzC,yCAAyC,kBAAkB;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sDAAwB;;AAE/C,qBAAqB,mBAAO,CAAC,4DAAwB;;AAErD;;AAEA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;;AAE3B,eAAe,mBAAO,CAAC,sDAAwB;AAC/C,cAAc,mBAAO,CAAC,8CAAiB;AACvC,qBAAqB,mBAAO,CAAC,4DAAwB;AACrD,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,kBAAkB,mBAAO,CAAC,wCAAc;;AAExC;;AAEA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD,CAAC;;AAED;AACA;AACA;AACA;AACA,SAAS,KAAK;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH,CAAC;;AAED;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,iBAAiB,mBAAO,CAAC,0BAAU;AACnC,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,sBAAsB,mBAAO,CAAC,kDAAmB;AACjD,oBAAoB,mBAAO,CAAC,8CAAiB;AAC7C,cAAc,mBAAO,CAAC,gCAAU;AAChC,kBAAkB,mBAAO,CAAC,cAAI;;AAE9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,gCAAgC,yBAAyB,OAAO,IAAI,IAAI;AACxE;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2BAA2B;AACzD;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,cAAc,mBAAO,CAAC,8BAAY;AAClC,kBAAkB,mBAAO,CAAC,cAAI;AAC9B,eAAe,mBAAO,CAAC,gDAAkB;;AAEzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,sEAAsE,MAAM;AAC5E;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,sEAAsE,MAAM;AAC5E,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,UAAU,4BAA4B;;AAExE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;ACjFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmC;AACT;AAE1B,MAAM,YAAY,GAAG,mBAAO,CAAC,4DAAwB,CAAC,CAAC;AAI/B;AAE0B;AACC;AACT;AAE1C,MAAM,IAAI,GAAG,0DAAwB,EAAE,CAAC;AAExC,MAAM,eAAe,GAAG,8CAAc,EAAE,CAAC;AA4EzC,kBAAkB,QAA0B,EAAE,OAAY,EAAE,MAA4B;IACtF,IAAI,GAAG,GAAG,IAAI,uCAAG,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC;IACtC,KAAK,IAAI,GAAG,IAAI,MAAM,EAAE;QACtB,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;YAC/B,SAAS;SACV;QACD,IAAI,OAAO,MAAM,CAAC,GAAG,CAAC,KAAK,WAAW,EAAE;YACtC,GAAG,CAAC,YAAY,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;SACnD;KACF;IACD,IAAI,GAAG,CAAC,QAAQ,KAAK,mBAAmB,EAAE;QACxC,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,+BAA+B,EAAE,EAAE,CAAC,CAAC,CAAC;QAC/E,OAAO;KACR;IACD,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC;AACpC,CAAC;AAED,sBAAsB,OAAqB,EAAE,QAA0B;IAErE,IAAI,MAAM,GAAG,4DAAY,CAAC,GAAG,CAAC,OAAO,CAAC,SAAS,EAAE,OAAO,CAAC,YAAY,CAAC,CAAC;IACvE,IAAI,CAAC,MAAM,EAAE;QACX,IAAI,GAAG,GAAsC;YAC3C,KAAK,EAAE,qBAAqB;YAC5B,iBAAiB,EAAE,mBAAmB;YACtC,KAAK,EAAE,OAAO,CAAC,KAAK;SACrB,CAAC;QAEF,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC/B,OAAO,IAAI,CAAC;KACb;IAED,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE;QACzB,OAAO,CAAC,YAAY,GAAG,MAAM,CAAC,YAAY,CAAC;KAC5C;IAED,IAAI,OAAO,CAAC,YAAa,CAAC,QAAQ,EAAE,KAAK,MAAM,CAAC,YAAY,CAAC,QAAQ,EAAE,EAAE;QACvE,IAAI,GAAG,GAAkC;YACvC,KAAK,EAAE,iBAAiB;YACxB,iBAAiB,EAAE,yBAAyB;YAC5C,KAAK,EAAE,OAAO,CAAC,KAAK;SACrB,CAAC;QAEF,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC/B,OAAO,IAAI,CAAC;KACb;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,mCAAmC,MAAsB,EACvD,OAAwB,EAAE,QAA0B;IACpD,IAAI,aAAa,GAAG,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC;IAClD,IAAI,OAAO,aAAa,KAAK,QAAQ,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;QAC5E,IAAI,GAAG,GAAsC;YAC3C,KAAK,EAAE,qBAAqB;YAC5B,iBAAiB,EAAE,2CAA2C;SAC/D,CAAC;QAEF,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC/B,OAAO,KAAK,CAAC;KACd;IAED,IAAI,WAAW,GAAG,aAAa,CAAC,SAAS,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;IAC3D,IAAI,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC,QAAQ,EAAE,CAAC;IAE7D,IAAI,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAChC,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;QACtB,IAAI,GAAG,GAAsC;YAC3C,KAAK,EAAE,qBAAqB;YAC5B,iBAAiB,EAAE,2CAA2C;SAC/D,CAAC;QAEF,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC/B,OAAO,KAAK,CAAC;KACd;IAED,IAAI,QAAQ,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;IAClE,IAAI,YAAY,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;IAEtE,IAAI,MAAM,CAAC,EAAE,KAAK,QAAQ,IAAI,MAAM,CAAC,MAAM,KAAK,YAAY,EAAE;QAC5D,IAAI,GAAG,GAAsC;YAC3C,KAAK,EAAE,qBAAqB;YAC5B,iBAAiB,EAAE,+BAA+B;SACnD,CAAC;QAEF,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC/B,OAAO,KAAK,CAAC;KACd;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED,oCAAoC,WAAiC,EACjC,QAA0B;IAE5D,IAAI,MAAM,GAAG,YAAY,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;IACjD,IAAI,CAAC,MAAM,EAAE;QACX,OAAO;KACR;IAED,IAAI,WAAW,CAAC,aAAa,KAAK,MAAM,EAAE;QACxC,IAAI,GAAG,GAA+B;YACpC,KAAK,EAAE,2BAA2B;YAClC,KAAK,EAAE,WAAW,CAAC,KAAK;SACzB,CAAC;QACF,QAAQ,CACN,QAAQ,EACR,MAAM,CAAC,YAAY,EACnB,GAAG,CACJ,CAAC;QACF,OAAO;KACR;IAED,IAAI,CAAC,qEAAgB,CAAC,MAAM,CAAC,KAAK,EAAE,WAAW,CAAC,KAAK,CAAC,EAAE;QACtD,IAAI,GAAG,GAA+B;YACpC,KAAK,EAAE,eAAe;YACtB,iBAAiB,EAAE,6CAA6C;YAChE,KAAK,EAAE,WAAW,CAAC,KAAK;SACzB,CAAC;QACF,QAAQ,CACN,QAAQ,EACR,MAAM,CAAC,YAAY,EACnB,GAAG,CACJ,CAAC;QACF,OAAO;KACR;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,eAAe,CAAC,GAAG,CAAC,YAAY,EAAE,KAAK,EAAE,OAAwB,EAAE,QAA0B,EAAE,EAAE;IAE/F,IAAI,WAAW,GAAyB;QACtC,aAAa,EAAE,OAAO,CAAC,KAAK,CAAC,aAAa;QAC1C,SAAS,EAAE,OAAO,CAAC,KAAK,CAAC,SAAS;QAClC,YAAY,EAAE,OAAO,CAAC,KAAK,CAAC,YAAY,IAAI,IAAI,uCAAG,CAAC,OAAO,CAAC,KAAK,CAAC,YAAY,CAAC;QAC/E,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC,KAAK;QAC1B,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC,KAAK;KAC3B,CAAC;IAEF,IAAI,MAAM,GAAG,0BAA0B,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;IAC/D,IAAI,CAAC,MAAM,EAAE;QACX,OAAO;KACR;IAED,QAAQ,CAAC,MAAM,CAAC,WAAW,EAAE;QAC3B,IAAI,EAAE,MAAM,CAAC,IAAI;QACjB,MAAM,EAAE,MAAM,CAAC,YAAY,CAAC,IAAI;QAChC,OAAO,EAAE,WAAW;KACrB,CAAC,CAAC;AACL,CAAC,CAAC,CAAC;AAEH,eAAe,CAAC,GAAG,CAAC,sBAAsB,EAAE,KAAK,EAAE,OAAwB,EAAE,QAA0B,EAAE,EAAE;IACzG,IAAI,WAAW,GAAmB,4DAAY,CAAC,GAAG,CAAC,aAAa,EAAE,SAAS,CAAE,CAAC;IAC9E,IAAI,YAAY,GAAuB;QACrC,UAAU,EAAE,oBAAoB;QAChC,IAAI,EAAE,OAAO,CAAC,KAAK,CAAC,IAAI;QACxB,YAAY,EAAE,WAAW,CAAC,YAAY;QACtC,SAAS,EAAE,WAAW,CAAC,EAAE;KAC1B,CAAC;IACF,OAAO,CAAC,IAAI,GAAG,YAAY,CAAC;IAC5B,OAAO,CAAC,OAAO,CAAC,aAAa,GAAG,QAAQ;QACtC,IAAI,MAAM,CAAC,WAAW,CAAC,EAAE,GAAG,GAAG,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAC3E,IAAI,KAAK,GAAG,MAAM,wBAAwB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;IAC9D,IAAI,KAAK,EAAE;QACT,QAAQ,CAAC,MAAM,CAAC,qBAAqB,EAAE;YACrC,KAAK,EAAE,KAAK,CAAC,YAAY;SAC1B,CAAC,CAAC;KACJ;AACH,CAAC,CAAC,CAAC;AAEH,eAAe,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,OAAwB,EAAE,QAA0B,EAAE,EAAE;IACjG,IAAI,WAAW,GAAyB;QACtC,aAAa,EAAE,OAAO,CAAC,KAAK,CAAC,aAAa;QAC1C,SAAS,EAAE,OAAO,CAAC,KAAK,CAAC,SAAS;QAClC,YAAY,EAAE,OAAO,CAAC,KAAK,CAAC,YAAY,IAAI,IAAI,uCAAG,CAAC,OAAO,CAAC,KAAK,CAAC,YAAY,CAAC;QAC/E,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC,KAAK;QAC1B,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC,KAAK;KAC3B,CAAC;IAEF,IAAI,MAAM,GAAG,0BAA0B,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;IAC/D,IAAI,CAAC,MAAM,EAAE;QACX,OAAO;KACR;IAED,IAAI,GAAG,GAAI,OAAe,CAAC,GAAG,CAAC;IAC/B,IAAI,CAAC,GAAG,EAAE;QACR,OAAO;KACR;IAED,IAAI,CAAC,GAAG,CAAC,OAAO,IAAI,GAAG,CAAC,OAAO,CAAC,IAAI,KAAK,YAAY,EAAE;QACrD,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,mCAAmC,CAAC,CAAC;QAC/D,OAAO;KACR;IAGD,IAAI,IAAI,GAAG,MAAM,YAAY,CAAC,eAAe,CAAC,MAAM,EAAE,GAAG,CAAC,IAAI,EAAE;QAC9D,IAAI,EAAE,oBAAoB;QAC1B,KAAK,EAAE,WAAW,CAAC,KAAK;KACzB,CAAC,CAAC;IAEH,IAAI,OAAO,GAAiC;QAC1C,IAAI,EAAE,IAAI;QACV,KAAK,EAAE,WAAW,CAAC,KAAK;KACzB,CAAC;IAEF,QAAQ,CACN,QAAQ,EACR,MAAM,CAAC,YAAY,EACnB,OAAO,CACR,CAAC;AACJ,CAAC,CAAC,CAAC;AAEH,eAAe,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,EAAE,OAAwB,EAAE,QAA0B,EAAE,EAAE;IAC5F,MAAM,WAAW,GAAG,OAAO,CAAC,IAAI,CAAC;IACjC,IAAI,WAAW,CAAC,UAAU,KAAK,oBAAoB,EAAE;QACnD,IAAI,KAAK,GAAG,MAAM,wBAAwB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;QAC9D,IAAI,KAAK,EAAE;YACT,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACtB;QACD,OAAO;KACR;IAID,IAAI,GAAG,GAA6B;QAClC,KAAK,EAAE,wBAAwB;QAC/B,KAAK,EAAE,WAAW,CAAC,KAAK;KACzB,CAAC;IACF,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC;AAMH,KAAK,mCAAmC,OAAwB,EAAE,QAA0B;IAE1F,MAAM,WAAW,GAAG,OAAO,CAAC,IAAI,CAAC;IACjC,IAAI,YAAY,GAAuB;QACrC,UAAU,EAAE,WAAW,CAAC,UAAU;QAClC,IAAI,EAAE,WAAW,CAAC,IAAI;QACtB,YAAY,EAAE,WAAW,CAAC,YAAY,IAAI,IAAI,uCAAG,CAAC,WAAW,CAAC,YAAY,CAAC;QAC3E,SAAS,EAAE,WAAW,CAAC,SAAS;KACjC,CAAC;IAEF,IAAI,MAAM,GAAG,YAAY,CAAC,YAAY,EAAE,QAAQ,CAAC,CAAC;IAClD,IAAI,CAAC,MAAM,EAAE;QACX,OAAO;KACR;IAED,IAAI,CAAC,yBAAyB,CAAC,MAAM,EAAE,OAAO,EAAE,QAAQ,CAAC,EAAE;QACzD,OAAO;KACR;IACD,IAAI,SAAS,GAAG,MAAM,YAAY,CAAC,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;IAChE,IAAI,CAAC,SAAS,EAAE;QACd,IAAI,GAAG,GAA6B;YAClC,KAAK,EAAE,eAAe;YACtB,iBAAiB,EAAE,yBAAyB;YAC5C,KAAK,EAAE,OAAO,CAAC,IAAI,CAAC,KAAK;SAC1B,CAAC;QAEF,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC/B,OAAO;KACR;IAED,IAAI,OAAO,GAAG,SAAS,CAAC,OAAO,CAAC;IAChC,IAAI,CAAC,OAAO,IAAI,OAAO,CAAC,IAAI,KAAK,oBAAoB,IAAI,OAAO,CAAC,SAAS,KAAK,MAAM,CAAC,EAAE,EAAE;QACxF,IAAI,GAAG,GAA6B;YAClC,KAAK,EAAE,eAAe;YACtB,KAAK,EAAE,OAAO,CAAC,IAAI,CAAC,KAAK;SAC1B,CAAC;QAEF,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC/B,OAAO;KACR;IAED,IAAI,WAAW,GAAG,MAAM,YAAY,CAAC,eAAe,CAAC,MAAM,EAAE,SAAS,CAAC,IAAI,EAAE;QAC3E,IAAI,EAAE,uDAAsB;QAC5B,KAAK,EAAE,SAAS,CAAC,OAAO,CAAC,KAAK;KAC/B,CAAC,CAAC;IAIH,IAAI,GAAG,GAA+B;QACpC,YAAY,EAAE,WAAW;QACzB,UAAU,EAAE,QAAQ;QAEpB,KAAK,EAAE,MAAM,CAAC,KAAK;KACpB,CAAC;IAEF,OAAO,GAAG,CAAC;AACb,CAAC;AAEc,8EAAe,EAAC;;;;;;;;;;;;;ACjY/B;AAAA;AAAa;AAIb,MAAM,aAAa,GAAG,mBAAO,CAAC,sDAAwB,CAAC,CAAC;AACN;AAGlD,MAAM,sBAAsB,GAAG,aAAa,EAAE,CAAC;AAK/C,sBAAsB,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,EAAE,OAAwB,EAAE,QAA0B,EAAE,EAAE;IAC7F,IAAI,IAAI,GAAI,OAAe,CAAC,GAAG,CAAC,IAAI,CAAC;IACrC,IAAI,OAAO,GAAG,MAAM,4DAAY,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IAErD,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAsB,EAAE,EAAE;QACnD,OAAO,MAAM,CAAC,cAAc,EAAE,CAAC;IACjC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC,CAAC;AAEH,sBAAsB,CAAC,MAAM,CAAC,YAAY,EAAE,KAAK,EAAE,OAAwB,EAAE,QAA0B,EAAE,EAAE;IACzG,IAAI,QAAQ,GAAG,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC;IACvC,IAAI,CAAC,4DAAY,CAAC,GAAG,CAAC,QAAQ,EAAE,SAAS,CAAC,EAAE;QAC1C,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;QAC9C,OAAO;KACR;IACD,IAAI,IAAI,GAAI,OAAe,CAAC,GAAG,CAAC,IAAI,CAAC;IAErC,MAAM,4DAAY,CAAC,yBAAyB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAC7D,QAAQ,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AAC3B,CAAC,CAAC,CAAC;AAEY,qFAAsB,EAAC;;;;;;;;;;;;;AC5CtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,wBAAS;;AAEjC;;AAEA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,oBAAoB,mBAAO,CAAC,8CAAiB;;AAE7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA,6BAA6B,2BAA2B;AACxD,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH,wDAAwD,aAAa;AACrE,+BAA+B,yBAAyB;AACxD;AACA;AACA,8BAA8B;AAC9B,CAAC;;AAED;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,sBAAsB,mBAAO,CAAC,wCAAc;;AAE5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,kBAAkB,mBAAO,CAAC,4BAAW;AACrC,uBAAuB,mBAAO,CAAC,0CAAkB,UAAU,aAAa;AACxE,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,cAAc,mBAAO,CAAC,8BAAY;AAClC,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,iBAAiB,mBAAO,CAAC,sCAAa;AACtC,iBAAiB,mBAAO,CAAC,oDAAoB;AAC7C,sBAAsB,mBAAO,CAAC,wCAAc;AAC5C,oBAAoB,mBAAO,CAAC,8CAAiB;AAC7C,mBAAmB,mBAAO,CAAC,4CAAgB;AAC3C,YAAY,mBAAO,CAAC,0CAAoB;;AAExC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,0CAA0C,eAAe;AACzD;AACA,iCAAiC,gBAAgB;AACjD,KAAK;AACL,yDAAyD,eAAe;AACxE;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,eAAe;AACzD;AACA;AACA,OAAO;AACP,mCAAmC,gBAAgB;AACnD;AACA,KAAK;AACL,yDAAyD,eAAe;AACxE;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB;AACnB,KAAK,gBAAgB,UAAU;AAC/B;AACA,GAAG;AACH;AACA,0DAA0D,EAAE;AAC5D;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,UAAU,GAAG,+BAA+B;;AAEpE;AACA;AACA,4DAA4D,QAAQ;AACpE;AACA;;AAEA,kBAAkB,mBAAO,CAAC,0CAAkB;AAC5C;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS,mBAAmB,MAAM,aAAa,cAAc;AAC7D;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX,OAAO;AACP;;AAEA;AACA;AACA,0BAA0B;AAC1B,KAAK,kBAAkB,UAAU,SAAS,MAAM;AAChD;AACA,2CAA2C,wBAAwB;AACnE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,SAAS,kBAAkB,MAAM,SAAS,MAAM;AAChD;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,UAAU;AAC9C,qCAAqC;AACrC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,mBAAmB,SAAS,KAAK,8BAA8B,SAAS,KAAK;AAC7E,iCAAiC;AACjC;AACA;AACA;AACA,GAAG;AACH,iDAAiD,IAAI;AACrD,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,QAAQ;AACvC,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;AChYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,gDAAkB;AACzC,gBAAgB,mBAAO,CAAC,kDAAmB;AAC3C,0BAA0B,mBAAO,CAAC,qEAAsB;AACxD,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,YAAY,mBAAO,CAAC,gBAAK;AACzB,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,yBAAyB,mBAAO,CAAC,mEAAqB;AACtD,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,iBAAiB,mBAAO,CAAC,oDAAoB;AAC7C,eAAe,mBAAO,CAAC,gDAAkB;AACzC,kBAAkB,mBAAO,CAAC,cAAI;;AAE9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,OAAO;AACP;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,2CAA2C,QAAQ,IAAI,EAAE;AACzD;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yEAAyE,GAAG;AAC5E,8BAA8B,MAAM;AACpC;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8CAA8C,KAAK;AACnD;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX,OAAO;AACP;AACA,OAAO;AACP,GAAG;;AAEH;AACA;AACA;AACA,iCAAiC,uBAAuB;;AAExD;AACA;AACA;AACA,iCAAiC,sBAAsB;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH,wDAAwD,QAAQ,IAAI,EAAE;AACtE,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,0DAA0D,QAAQ,IAAI,EAAE;AACxE;;AAEA;AACA;AACA;AACA,KAAK;AACL,0DAA0D,QAAQ,IAAI,EAAE;AACxE;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,0DAA0D,QAAQ,IAAI,EAAE;AACxE;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,wDAAwD,QAAQ,IAAI,EAAE;AACtE;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA,OAAO;AACP,4DAA4D,QAAQ,IAAI,EAAE;AAC1E,OAAO;AACP,KAAK;AACL,0DAA0D,QAAQ,IAAI,EAAE;AACxE,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC,OAAO;AACP,KAAK;AACL;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oBAAoB;AACjE;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;;;;;;;;;;;;ACrjBA,qBAAqB,mBAAO,CAAC,oCAAe;AAC5C,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,WAAW,mBAAO,CAAC,cAAI;AACvB,cAAc,mBAAO,CAAC,8BAAY;AAClC,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,sBAAsB,mBAAO,CAAC,sDAAwB;;AAEtD,YAAY,mBAAO,CAAC,0CAAoB;;AAExC;;AAEA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sDAAsD,gBAAgB;AACtE;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA,UAAU,cAAc;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK,UAAU,qCAAqC,YAAY,GAAG;;AAEnE;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;;;;;;;;;;;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,oBAAoB,mBAAO,CAAC,8CAAiB;;AAE7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,+CAA+C,IAAI;AACnD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,wEAAwE,IAAI;AAC5E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,mDAAmD,IAAI;AACvD;;AAEA;AACA,yCAAyC,MAAM;AAC/C;;AAEA;AACA,GAAG;AACH,CAAC;;AAED;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,cAAc,mBAAO,CAAC,8CAAiB;AACvC,qBAAqB,mBAAO,CAAC,4DAAwB;AACrD,sBAAsB,mBAAO,CAAC,kDAAmB;AACjD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,MAAM;AAC1C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,kBAAkB,mBAAO,CAAC,uCAAa;AACvC,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B;AACA,mBAAmB,mBAAO,CAAC,mDAAuB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,MAAK,KAAK,aAAoB;;AAE5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ,KAA+B,EAAE,EAEpC;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,MAAM;AACN,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,8CAA8C,kBAAkB;AAChE;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,QAAQ,GAAG,IAAI;AACrC,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,WAAW;AACX,yCAAyC,WAAW;AACpD,yBAAyB;AACzB;AACA,SAAS;AACT;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA,WAAW,MAAM;AACjB;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW,MAAM;AACjB;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,mBAAmB;AACnB,KAAK;AACL,GAAG;;AAEH;AACA;AACA,aAAa,KAAK;AAClB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,aAAa;AAC1B,cAAc,gBAAgB;AAC9B;AACA;AACA,WAAW,0CAA0C;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,KAAK;AACL,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,cAAc,gBAAgB;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,qCAAqC,EAAE;AACvC,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,aAAa,WAAW;AACxB,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;;;;;;;;;;;;;AC1oBA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AChCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgC;AACC;AASjC,MAAM,KAAK,GAAG,YAAY,CAAC;AAG3B,MAAM,eAAe,GAAG,8CAAW,CAAC,cAAc,EAAE;IAClD,IAAI,CAAC,GAAG,EAAE,CAAC,GAAG,CACZ,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,GAAG,EAAE,EACzB,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,MAAM,EAAE,EAC/B,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,QAAQ,EAAE,EACrD,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,CACtD,CAAC;AACJ,CAAC,CAAC,CAAC;AAGH,MAAM,uBAAuB,GAAG,8CAAW,CAAC,sBAAsB,EAAE;IAClE,IAAI,CAAC,GAAG,EAAE,CAAC,GAAG,CACZ,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAC7B,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EACtB,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,KAAK,EAAE,CAC/B,EACD,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,MAAM,EAAE,CACzB;AACH,CAAC,CAAC,CAAC;AAIH,MAAM,yBAAyB,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AAE3D,MAAM,eAAe,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AAS7C;IACL,MAAM,GAAG,GAAG,iDAAiB,CAAC,KAAK,CAAC,CAAC;IACrC,GAAG,CAAC,YAAY,EAAE,CAAC;IAEnB,MAAM,IAAI,GAAG,eAAe,CAAC,MAAM,CAAC;QAClC,OAAO,EAAE,CAAC;QACV,UAAU,EAAE,GAAG,CAAC,aAAa,EAAE;QAC/B,UAAU,EAAE,eAAe;KAC5B,EAAE,KAAK,EAAE;QAER,KAAK,EAAE,gBAAgB;KACxB,CAAC,CAAC;IAEH,MAAM,GAAG,GAAG,uBAAuB,CAAC,MAAM,CAAC;QACzC,GAAG,EAAE;YACH,MAAM,EAAE,CAAC;YACT,IAAI,EAAE,GAAG,CAAC,YAAY,EAAE;SACzB;QACD,SAAS,EAAE;YACT,EAAE,EAAE,yBAAyB;YAC7B,UAAU,EAAE,eAAe;SAC5B;KACF,EAAE,KAAK,EAAE;QACR,KAAK,EAAE,YAAY;KACpB,CAAC,CAAC;IAEH,OAAO,EAAE,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;AACxC,CAAC;AAEM,MAAM,aAAa,GAAG,OAAO,CAAC;;;;;;;;;;;;ACrFrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,uCAAa;AACvC,qBAAqB,mBAAO,CAAC,2DAAuB;;AAEpD;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,aAAa;AACzB;AACA;AACA,SAAS,cAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB,GAAG,oBAAoB;AACjE;AACA;AACA;AACA,6BAA6B,iBAAiB,sBAAsB,MAAM;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,wBAAwB,mBAAO,CAAC,4DAA2B;AAC3D,oBAAoB,mBAAO,CAAC,6CAAgB;AAC5C,eAAe,mBAAO,CAAC,kBAAM;;AAE7B;AACA;AACA;AACA,sBAAsB,eAAe,GAAG,MAAM,IAAI,aAAa;AAC/D;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;;AAED;AACA;AACA,YAAY,uBAAuB;AACnC,SAAS,wBAAwB,aAAa;AAC9C,SAAS,mBAAmB,aAAa;AACzC,SAAS,oBAAoB,aAAa;AAC1C,SAAS,sBAAsB,aAAa;AAC5C,SAAS,sBAAsB,aAAa;AAC5C,UAAU,2BAA2B,aAAa;AAClD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAO,CAAC,4BAAW;;AAEzC;AACA;AACA,wBAAwB,mBAAmB,GAAG,qBAAqB;AACnE,mBAAmB,6CAA6C;AAChE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AClJA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,cAAc,mBAAO,CAAC,oBAAO;;AAE7B;AACA,iBAAiB,mBAAO,CAAC,qCAAY;AACrC,iBAAiB,mBAAO,CAAC,mDAAmB;AAC5C,sBAAsB,mBAAO,CAAC,uCAAa;;AAE3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,KAA+B,EAAE,EAEpC;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,mBAAmB;;AAEnB;AACA,iCAAiC,EAAE;AACnC;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,sDAAsD,kBAAkB;AACxE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8DAA8D,YAAY;AAC1E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,iEAAiE,YAAY;AAC7E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB,qBAAqB;;AAErB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,kDAAmB;AAC3C,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,OAAO,MAAM,GAAG,mBAAO,CAAC,oCAAe;;AAEvC;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,WAAW,EAAE,uBAAuB,GAAG,KAAK,GAAG,QAAQ;AAC5E;AACA,KAAK;AACL,qBAAqB,uBAAuB,GAAG,KAAK,GAAG,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,gDAAkB;AACzC,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,qBAAqB,mBAAO,CAAC,sBAAQ;;AAErC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL,cAAc;AACd,KAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL,cAAc;AACd,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,yDAAyD,YAAY;AACrE;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,GAAG;AACrC;;AAEA;AACA;AACA;AACA;AACA,iDAAiD,YAAY;AAC7D;AACA,SAAS;AACT;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACpOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,OAAO,MAAM,GAAG,mBAAO,CAAC,oCAAe;;AAEvC;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,gDAAkB;;AAEzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL,cAAc;AACd,KAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL,cAAc;AACd,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;;AAEb,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,YAAY,mBAAO,CAAC,gBAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA,uCAAuC,KAAK;AAC5C;AACA,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,KAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,oCAAoC,KAAK;AACzC;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;;;;;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,kBAAM;AAC3B,YAAY,mBAAO,CAAC,kCAAc;AAClC,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B,WAAW,mBAAO,CAAC,wCAAc;AACjC,iBAAiB,mBAAO,CAAC,0BAAO;AAChC,iBAAiB,mBAAO,CAAC,4CAAY;;AAErC;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,WAAW,IAAI;;AAEf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,cAAc,OAAO;AACrB;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,cAAc,6BAA6B;AAC3C,cAAc,OAAO;AACrB;AACA;AACA,WAAW,WAAW;AACtB;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA,uCAAuC,sBAAsB;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA,WAAW,iCAAiC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;ACjKA;AAAA;AAAA;AAAA;AAA0B;AACqC;AAC/D,MAAM,QAAQ,GAAG,mBAAO,CAAC,0BAAO,CAAC,CAAC;AAGlC;IAEE;QADQ,YAAO,GAAuC,IAAI,GAAG,EAAE,CAAC;IAEhE,CAAC;IAED,QAAQ,CAAC,MAAsB;QAC7B,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE;YAC/B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;SAC3C;aAAM;YACL,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;SACvC;IACH,CAAC;IAED,GAAG,CAAC,EAAU,EAAE,WAA0B;QACxC,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACrC,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO;SACR;QACD,IAAI,CAAC,WAAW,EAAE;YAChB,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC;SACnB;QACD,KAAK,IAAI,MAAM,IAAI,OAAO,EAAE;YAC1B,IAAI,MAAM,CAAC,YAAY,CAAC,IAAI,KAAK,WAAW,CAAC,IAAI,EAAE;gBACjD,OAAO,MAAM,CAAC;aACf;SACF;QACD,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC;IACpB,CAAC;IAED,KAAK,CAAC,aAAa,CAAC,MAAc;QAChC,IAAI,IAAI,GAAG,MAAM,QAAQ,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;QACzD,IAAI,UAAU,GAAG,IAAI,GAAG,EAAE,CAAC;QAE3B,KAAK,IAAI,GAAG,IAAI,IAAI,EAAE;YACpB,IAAI,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YACtC,IAAI,OAAO,CAAC,IAAI,KAAK,cAAc,EAAE;gBACnC,SAAS;aACV;YACD,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;gBACxC,OAAO,CAAC,IAAI,CAAC,uBAAuB,EAAE,GAAG,CAAC,CAAC;gBAC3C,MAAM,QAAQ,CAAC,yBAAyB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBACpD,SAAS;aACV;YACD,MAAM,aAAa,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,SAAS,CAAE,CAAC,CAAC,CAAC,CAAC;YAC9D,IAAI,CAAC,aAAa,EAAE;gBAClB,SAAS;aACV;YACD,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;SAClD;QAED,OAAO,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,CAAC;IACzC,CAAC;IAED,KAAK,CAAC,yBAAyB,CAAC,MAAc,EAAE,QAAgB;QAC9D,IAAI,IAAI,GAAG,MAAM,QAAQ,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;QAEzD,KAAK,IAAI,GAAG,IAAI,IAAI,EAAE;YACpB,IAAI,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YACtC,IAAI,OAAO,CAAC,SAAS,KAAK,QAAQ,EAAE;gBAClC,MAAM,QAAQ,CAAC,yBAAyB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;aACrD;SACF;IACH,CAAC;CACF;AAED,IAAI,YAAY,GAAG,IAAI,YAAY,EAAE,CAAC;AAEtC,YAAY,CAAC,QAAQ,CACnB,IAAI,2DAAc,CAAC,IAAI,uCAAG,CAAC,iCAAiC,CAAC,EAAE,MAAM,EAClD,mBAAmB,EAAE,cAAc,EAAE,mBAAmB,CAAC,CAC7E,CAAC;AAEF,YAAY,CAAC,QAAQ,CACnB,IAAI,2DAAc,CAAC,IAAI,uCAAG,CAAC,oCAAoC,CAAC,EAAE,MAAM,EACrD,mBAAmB,EAAE,cAAc,EAAE,mBAAmB,CAAC,CAC7E,CAAC;AAEF,YAAY,CAAC,QAAQ,CACnB,IAAI,2DAAc,CAAC,IAAI,uCAAG,CAAC,qDAAqD,CAAC,EAAE,aAAa,EAC7E,qBAAqB,EAAE,cAAc,EACrC,mBAAmB,CAAC,CACxC,CAAC;AACa,2EAAY,EAAC;;;;;;;;;;;;;ACvF5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,iBAAiB,mBAAO,CAAC,0BAAO;AAChC,aAAa,mBAAO,CAAC,kBAAM;;AAE3B,cAAc,MAAK,KAAK,aAAoB;;AAE5C;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,sBAAsB;AAC/D;AACA;AACA,KAAK;AACL;AACA,yCAAyC,sBAAsB;AAC/D;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D,YAAY;AACtE,uCAAuC,+BAA+B;AACtE;AACA,mBAAmB,YAAY,GAAG,+BAA+B;AACjE,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,yEAAyE,IAAI;AAC7E;AACA;AACA;;AAEA,0CAA0C,eAAe;AACzD,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,iBAAiB,mBAAO,CAAC,6BAAU;AACnC,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,oBAAoB,mBAAO,CAAC,8CAAiB;AAC7C,kBAAkB,mBAAO,CAAC,cAAI;AAC9B,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,YAAY,mBAAO,CAAC,gBAAK;;AAEzB;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB,GAAG,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB,GAAG;AAClD,OAAO,EAAE,0BAA0B,GAAG,aAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,KAAK;AACL;AACA;AACA,eAAe,UAAU;AACzB,KAAK;AACL;AACA;AACA,eAAe,UAAU;AACzB,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS,UAAU,WAAW,WAAW;AACzC;;AAEA;AACA,qCAAqC,UAAU,UAAU,UAAU;AACnE;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2DAA2D,UAAU;AACrE;AACA;AACA,KAAK;;AAEL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,yBAAyB,KAAK,QAAQ,EAAE,UAAU;AACjE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB,GAAG;AAClD,OAAO,EAAE,0BAA0B,GAAG,aAAa;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,UAAU,WAAW,WAAW;AACzC;;AAEA;AACA;AACA;AACA,qCAAqC,UAAU,UAAU,UAAU;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACtbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,cAAc,mBAAO,CAAC,yCAAY;AAClC,iBAAiB,mBAAO,CAAC,6BAAU;AACnC,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,kBAAkB,mBAAO,CAAC,wCAAc;;AAExC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,MAAM,MAAM;AACZ,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB,GAAG,kBAAkB;AACzD;AACA;AACA;AACA,iCAAiC;AACjC,eAAe,GAAG;AAClB,eAAe,EAAE,0BAA0B,GAAG,aAAa;AAC3D;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,KAAK,gBAAgB;AACrB,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,KAAK,gBAAgB;AACrB,GAAG;;AAEH;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,yDAAyD,GAAG;AAC5D;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,eAAe;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAyD,KAAK;AAC9D,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED,uCAAuC,kBAAkB;AACzD;AACA,CAAC;;AAED;;;;;;;;;;;;;AC1TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,kBAAkB,mBAAO,CAAC,wCAAc;;AAExC;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,aAAa,mBAAO,CAAC,uCAAW;AAChC,iBAAiB,mBAAO,CAAC,6BAAU;;AAEnC;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,KAAK;AAClB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;AC3GA;AAAA;AAAA;AAAA;AAAA;AAAyC;AAUlC;IACL,YAAmB,YAAiB,EAAS,EAAY,EAAS,IAAY,EAC3D,MAAc,EAAS,KAAe;QADtC,iBAAY,GAAZ,YAAY,CAAK;QAAS,OAAE,GAAF,EAAE,CAAU;QAAS,SAAI,GAAJ,IAAI,CAAQ;QAC3D,WAAM,GAAN,MAAM,CAAQ;QAAS,UAAK,GAAL,KAAK,CAAU;IACzD,CAAC;IAED,cAAc;QACZ,OAAO;YACL,EAAE,EAAE,IAAI,CAAC,EAAE;YACX,IAAI,EAAE,IAAI,CAAC,IAAI;YACf,YAAY,EAAE,IAAI,CAAC,YAAY;YAC/B,KAAK,EAAE,IAAI,CAAC,KAAK;SAClB,CAAC;IACJ,CAAC;CACF;AAED,uBAAuB,QAAkB;IACvC,IAAI,KAAK,GAAU,EAAE,CAAC;IACtB,IAAI,UAAU,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACrC,KAAK,IAAI,SAAS,IAAI,UAAU,EAAE;QAChC,IAAI,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACjC,IAAI,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACpB,IAAI,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACzB,IAAI,SAAS,KAAK,MAAM,IAAI,SAAS,KAAK,WAAW,EAAE;YACrD,SAAS,GAAG,MAAM,CAAC;SACpB;QACD,KAAK,CAAC,IAAI,CAAC,GAAG,SAA+B,CAAC;KAC/C;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AAEM,0BAA0B,cAAwB,EAAE,eAAyB;IAClF,IAAI,cAAc,KAAK,eAAe,EAAE;QACtC,OAAO,IAAI,CAAC;KACb;IACD,IAAI,WAAW,GAAG,aAAa,CAAC,cAAc,CAAC,CAAC;IAChD,IAAI,YAAY,GAAG,aAAa,CAAC,eAAe,CAAC,CAAC;IAElD,IAAI,CAAC,WAAW,IAAI,CAAC,YAAY,EAAE;QACjC,OAAO,KAAK,CAAC;KACd;IAED,KAAK,IAAI,WAAW,IAAI,YAAY,EAAE;QACpC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,sDAAqB,CAAC,EAAE;YAClD,OAAO,CAAC,IAAI,CAAC,yCAAyC,EAAE,eAAe,CAAC,CAAC;YACzE,OAAO,KAAK,CAAC;SACd;QACD,IAAI,aAAa,GAAG,YAAY,CAAC,WAAW,CAAC,CAAC;QAC9C,IAAI,MAA6B,CAAC;QAClC,IAAI,WAAW,CAAC,WAAW,CAAC,EAAE;YAC5B,MAAM,GAAG,WAAW,CAAC,WAAW,CAAC,CAAC;SACnC;aAAM;YACL,MAAM,GAAG,WAAW,CAAC,sDAAqB,CAAC,CAAC;SAC7C;QAED,IAAI,CAAC,MAAM,EAAE;YACX,OAAO,KAAK,CAAC;SACd;QAED,IAAI,aAAa,KAAK,WAAW,EAAE;YACjC,IAAI,MAAM,KAAK,WAAW,EAAE;gBAC1B,OAAO,KAAK,CAAC;aACd;SACF;KACF;IACD,OAAO,IAAI,CAAC;AACd,CAAC;;;;;;;;;;;;AC7ED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,0BAAU;AACjC,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAO,CAAC,oCAAe;AAC7C,WAAW,mBAAO,CAAC,cAAI;AACvB,gBAAgB,mBAAO,CAAC,wBAAS;;AAEjC;AACA;AACA;AACA;AACA,YAAY,iBAAiB,GAAG,aAAa;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;;AAEvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,OAAO,QAAQ,GAAG,mBAAO,CAAC,oCAAe;AACzC,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,iBAAiB,mBAAO,CAAC,sCAAa;AACtC,oBAAoB,mBAAO,CAAC,oDAAgB;;AAE5C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;;AAEA;AACA;AACA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA,0CAA0C,oBAAoB;AAC9D;;AAEA;AACA;AACA;AACA,iDAAiD,oBAAoB;AACrE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;;AAEP,uCAAuC,cAAc;AACrD,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,qBAAqB,mBAAO,CAAC,sBAAQ;;AAErC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA,iEAAiE,SAAS;AAC1E;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,mBAAO,CAAC,gDAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oEAAoE;AACpE;;AAEA;AACA,gEAAgE,QAAQ;AACxE;AACA;;AAEA;;;;;;;;;;;;;ACzaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,kDAAmB;AAC3C,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,cAAc,mBAAO,CAAC,8CAAiB;AACvC,eAAe,mBAAO,CAAC,gDAAkB;AACzC,sBAAsB,mBAAO,CAAC,wDAAkB;AAChD,OAAO,iBAAiB,GAAG,mBAAO,CAAC,oCAAe;;AAElD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC9Ja;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,WAAW,mBAAO,CAAC,cAAI;AACvB,gBAAgB,mBAAO,CAAC,wBAAS;;AAEjC,oBAAoB,mBAAO,CAAC,8CAAiB;;AAE7C;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;;AAEA;AACA,0BAA0B,kBAAkB;AAC5C,sBAAsB;AACtB;;AAEA;AACA,iDAAiD,cAAc;AAC/D;AACA;AACA;AACA;AACA,sBAAsB,cAAc,KAAK,aAAa;;AAEtD,iCAAiC,IAAI,cAAc,eAAe;AAClE,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,0BAA0B,mBAAO,CAAC,kEAAuB;AACzD,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,iBAAiB,mBAAO,CAAC,sCAAa;AACtC,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,kBAAkB,mBAAO,CAAC,kCAAO;;AAEjC;;AAEA,yBAAyB,QAAQ,KAAK;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;;AAEA;;;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,kBAAkB,mBAAO,CAAC,kCAAO;AACjC,eAAe,mBAAO,CAAC,wCAAU;;AAEjC;AACA,6BAA6B,QAAQ,KAAK;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,qBAAqB,mBAAO,CAAC,sDAAiB;AAC9C,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,iBAAiB,mBAAO,CAAC,sCAAa;AACtC,oBAAoB,mBAAO,CAAC,oDAAgB;AAC5C,eAAe,mBAAO,CAAC,oCAAe;AACtC,kBAAkB,mBAAO,CAAC,kCAAO;AACjC,iBAAiB,mBAAO,CAAC,0BAAU;AACnC,cAAc,mBAAO,CAAC,oCAAe;AACrC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,oBAAoB,mBAAO,CAAC,8CAAiB;;AAE7C;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,cAAc;;AAEvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA,uDAAuD;AACvD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA,qBAAqB,eAAe,IAAI,KAAK;AAC7C,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA,uBAAuB,eAAe,IAAI,KAAK;AAC/C,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;;AAEA;;;;;;;;;;;;;ACreA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,iBAAiB,mBAAO,CAAC,sCAAa;AACtC,OAAO,SAAS,GAAG,mBAAO,CAAC,oCAAe;;AAE1C;AACA;AACA;;AAEA;;AAEA;AACA,wCAAwC;AACxC;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,0BAAU;AAClC,iBAAiB,mBAAO,CAAC,mDAAmB;AAC5C,iBAAiB,mBAAO,CAAC,yBAAM;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;;AAEjC;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,oBAAoB,mBAAO,CAAC,gCAAa;AACzC,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,kBAAkB,mBAAO,CAAC,uCAAa;AACvC,sBAAsB,mBAAO,CAAC,iDAAkB;AAChD;AACA,oBAAoB,mBAAO,CAAC,6CAAgB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;;AAE9B;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,YAAY,mBAAO,CAAC,6EAAgC;;AAEpD;AACA,eAAe,WAAW,KAAK,mBAAO,CAAC,2EAA+B;;AAEtE;AACA;AACA,YAAY,mBAAO,CAAC,6EAAgC;AACpD;AACA,YAAY,mBAAO,CAAC,mFAAmC;AACvD;AACA,YAAY,mBAAO,CAAC,6EAAgC;AACpD;AACA,YAAY,mBAAO,CAAC,2EAA+B;AACnD;AACA;AACA,cAAc,mBAAO,CAAC,6EAAgC;AACtD;;AAEA;AACA;AACA,YAAY,mBAAO,CAAC,+EAAiC;AACrD;AACA,YAAY,mBAAO,CAAC,uFAAqC;AACzD;AACA,YAAY,mBAAO,CAAC,mFAAmC;AACvD;AACA,YAAY,mBAAO,CAAC,iFAAkC;AACtD;AACA,YAAY,mBAAO,CAAC,+EAAiC;AACrD;AACA,YAAY,mBAAO,CAAC,iFAAkC;AACtD;AACA,YAAY,mBAAO,CAAC,iFAAkC;AACtD;AACA,YAAY,mBAAO,CAAC,mFAAmC;AACvD;AACA,YAAY,mBAAO,CAAC,iFAAkC;AACtD;AACA,YAAY,mBAAO,CAAC,+EAAiC;AACrD;AACA,YAAY,mBAAO,CAAC,4DAAyB;AAC7C;AACA,YAAY,mBAAO,CAAC,2EAA+B;AACnD;AACA,YAAY,mBAAO,CAAC,2EAA+B;;AAEnD;AACA,YAAY,mBAAO,CAAC,6EAAgC;AACpD;AACA,YAAY,mBAAO,CAAC,2FAAuC;AAC3D,GAAG;AACH;;AAEA;;;;;;;;;;;;AC7IA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA,oCAAoC,aAAa;AACjD;;AAEA;AACA,2BAA2B,mCAAmC;AAC9D;AACA;;AAEA;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,WAAW,mBAAO,CAAC,6BAAU;;AAE7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,YAAY,sCAAsC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,kDAAY;AACrC,aAAa,mBAAO,CAAC,0CAAQ;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA,8CAA8C,GAAG;AACjD;AACA;AACA;;AAEA;AACA;AACA,aAAa,KAAK;AAClB,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,KAAK;AAClB,cAAc;AACd;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,cAAc,mBAAO,CAAC,8BAAY;AAClC,cAAc,mBAAO,CAAC,oBAAO;AAC7B,iBAAiB,mBAAO,CAAC,oDAAoB;AAC7C,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,eAAe,mBAAO,CAAC,8CAAU;AACjC,wBAAwB,mBAAO,CAAC,gEAAmB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA,iCAAiC,IAAI;AACrC;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA,aAAa,IAAI;AACjB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAO,CAAC,sDAAW;AACnC,iBAAiB,mBAAO,CAAC,wDAAY;AACrC,eAAe,mBAAO,CAAC,8CAAU;;AAEjC;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,0CAAkB;AACtC,iBAAiB,mBAAO,CAAC,oDAAoB;AAC7C,kBAAkB,mBAAO,CAAC,cAAI;;AAE9B;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,sBAAsB,2CAA2C,OAAO,IAAI;;AAE5E,qCAAqC,0BAA0B;AAC/D;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,sBAAsB,sBAAsB;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,cAAc,mBAAO,CAAC,8BAAY;AAClC,cAAc,mBAAO,CAAC,oBAAO;AAC7B,eAAe,mBAAO,CAAC,sDAAU;AACjC,iBAAiB,mBAAO,CAAC,uDAAuB;;AAEhD;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,oBAAoB;AACpB,KAAK;AACL;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,IAAI;AACrC;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,sDAAU;;AAEjC;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA,4BAA4B,mBAAO,CAAC,oDAAS;;AAE7C;AACA;AACA,KAAK;AACL;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,eAAe,mBAAO,CAAC,sDAAU;AACjC,oBAAoB,mBAAO,CAAC,iDAAoB;;AAEhD;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,mDAAa;AACtC,eAAe,mBAAO,CAAC,sDAAU;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,uBAAuB,mBAAO,CAAC,sEAAkB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,uBAAuB,mBAAO,CAAC,sEAAkB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,mBAAO,CAAC,sDAAU;AAC5B,gBAAgB,mBAAO,CAAC,kEAAgB;AACxC,eAAe,mBAAO,CAAC,gEAAe;AACtC,sBAAsB,mBAAO,CAAC,8EAAsB;AACpD,aAAa,mBAAO,CAAC,4DAAa;AAClC,eAAe,mBAAO,CAAC,gEAAe;AACtC;;AAEA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,YAAY;AACZ;AACA;AACA;AACA;AACA,0DAA0D,UAAU;AACpE;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,iBAAiB,mBAAO,CAAC,oDAAoB;;AAE7C,iBAAiB,mBAAO,CAAC,kDAAY;AACrC,iBAAiB,mBAAO,CAAC,kDAAY;AACrC,eAAe,mBAAO,CAAC,8CAAU;AACjC,qBAAqB,mBAAO,CAAC,4DAAwB;AACrD,aAAa,mBAAO,CAAC,0CAAQ;;AAE7B;AACA;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,iBAAiB;AAC5B,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,YAAY,WAAW;AACvB,CAAC;;AAED;AACA;AACA;AACA,eAAe;AACf,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,eAAe;AACf,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjGA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,eAAe,mBAAO,CAAC,+CAAW;AAClC,wBAAwB,mBAAO,CAAC,yEAAmB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA,uCAAuC,2BAA2B;AAClE,KAAK;AACL,uCAAuC,4BAA4B;AACnE;AACA;AACA;;AAEA;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,+CAAW;AAClC,wBAAwB,mBAAO,CAAC,yEAAmB;;AAEnD;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;;AAEA,qCAAqC,yBAAyB;AAC9D;AACA;;AAEA;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAO,CAAC,8CAAoB;AAC9C,eAAe,mBAAO,CAAC,+CAAW;AAClC,wBAAwB,mBAAO,CAAC,iEAAoB;AACpD,gBAAgB,mBAAO,CAAC,yDAAW;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qCAAqC,4BAA4B;AACjE;AACA;AACA;AACA;AACA,uCAAuC,6BAA6B;AACpE;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,eAAe,mBAAO,CAAC,+CAAW;AAClC,wBAAwB,mBAAO,CAAC,yEAAmB;;AAEnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,yBAAyB;AAC9D;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,eAAe,mBAAO,CAAC,+CAAW;AAClC,gBAAgB,mBAAO,CAAC,yDAAW;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAO,CAAC,qDAAS;;AAE7C;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;;AAEA;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,+CAAW;AAClC,gBAAgB,mBAAO,CAAC,yDAAW;AACnC,iBAAiB,mBAAO,CAAC,mDAAa;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,+CAAW;AAClC,gBAAgB,mBAAO,CAAC,yDAAW;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,4BAA4B;AACjE;AACA;;AAEA;AACA,qCAAqC,6BAA6B;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,sBAAQ;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAO,CAAC,uEAAkB;AAC5C,mBAAmB,mBAAO,CAAC,yEAAmB;AAC9C,gBAAgB,mBAAO,CAAC,mEAAgB;AACxC,gBAAgB,mBAAO,CAAC,mEAAgB;AACxC,gBAAgB,mBAAO,CAAC,mEAAgB;AACxC,mBAAmB,mBAAO,CAAC,yEAAmB;AAC9C,eAAe,mBAAO,CAAC,iEAAe;AACtC,WAAW,mBAAO,CAAC,yDAAW;AAC9B;;AAEA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,YAAY;AACZ;AACA;AACA;AACA;AACA,2DAA2D,UAAU;AACrE;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,cAAI;AACvB,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,8BAAY;AAClC,kBAAkB,mBAAO,CAAC,oCAAe;AACzC,iBAAiB,mBAAO,CAAC,mDAAmB;AAC5C,oBAAoB,mBAAO,CAAC,6CAAgB;AAC5C,oBAAoB,mBAAO,CAAC,6CAAgB;;AAE5C,cAAc,MAAK,KAAK,aAAoB;;AAE5C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,uCAAuC;AAC9D;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC,yCAAyC;AACzC;AACA;AACA,gDAAgD,SAAS;AACzD,qDAAqD;AACrD,6CAA6C;AAC7C,wBAAwB;AACxB,mDAAmD;AACnD,gDAAgD;AAChD,uBAAuB,YAAY;;AAEnC;AACA;AACA;AACA;AACA,8CAA8C,KAAK;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,4CAA4C,KAAK;AACjD,SAAS;AACT;AACA,6DAA6D,KAAK;AAClE,SAAS;;AAET;AACA;AACA;;AAEA;AACA,oCAAoC,SAAS;AAC7C,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,aAAa;AACb,KAAK,cAAc,uBAAuB;AAC1C;AACA;AACA,OAAO;AACP,GAAG;AACH;;AAEA;;;;;;;;;;;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,cAAI;AACvB,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,YAAY,mBAAO,CAAC,gBAAK;AACzB,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,WAAW,mBAAO,CAAC,yBAAM;AACzB,iBAAiB,mBAAO,CAAC,mDAAmB;AAC5C,cAAc,mBAAO,CAAC,6CAAgB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,KAA+B,EAAE,EAEpC;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,sBAAsB,IAAI;AAClE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,IAA+B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;AC3OA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,WAAW,mBAAO,CAAC,cAAI;;AAEvB;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;;AAEA;AACA,2BAA2B;AAC3B,0BAA0B;AAC1B,0BAA0B;AAC1B,4BAA4B;AAC5B,4BAA4B;AAC5B,GAAG;AACH;;;;;;;;;;;;AC7DA,gEAAe,mBAAO,CAAC,sBAAQ;AAC/B,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,mBAAmB,mBAAO,CAAC,8BAAY;AACvC,mBAAmB,mBAAO,CAAC,gCAAa;AACxC,WAAW,mBAAO,CAAC,cAAI;AACvB,iBAAiB,mBAAO,CAAC,mDAAe;AACxC,aAAa,mBAAO,CAAC,2CAAW;AAChC,aAAa,mBAAO,CAAC,2CAAW;AAChC,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,gBAAgB;;AAE/C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD,KAAK;AACL,uCAAuC,eAAe;AACtD;AACA,GAAG;AACH;AACA,qCAAqC,eAAe;AACpD,GAAG;AACH;AACA,qCAAqC,eAAe;AACpD,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,KAAK;AACL;AACA,uCAAuC;AACvC;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,qCAAqC,eAAe;AACpD,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,aAAa;AACnD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,cAAc;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;;;;;;;;;;;;;AC/LA,sBAAsB,mBAAO,CAAC,wCAAQ;AACtC,8BAA8B,mBAAO,CAAC,sCAAO;;;;;;;;;;;;ACD7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,mBAAO,CAAC,oCAAe,iCAAiC,iBAAiB;;AAE7E;;AAEA,iBAAiB,mBAAO,CAAC,qEAAwB;;AAEjD;;;;;;;;;;;;ACfA,8DAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wDAAwD,eAAe,EAAE,EAAE;;AAE3E;AACA;AACA;AACA,mDAAmD,UAAU,EAAE,EAAE;;AAEjE;AACA;AACA,gBAAgB,kCAAkC;;AAElD;AACA;AACA;AACA;AACA,gEAAgE,UAAU,EAAE,SAAS;;AAErF;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8BAA8B;;AAE3D;AACA;AACA;AACA,iCAAiC,6BAA6B;;AAE9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjEA,sBAAsB,mBAAO,CAAC,oCAAe;;AAE7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,4BAA4B,QAAQ,qBAAqB,OAAO;AAChE,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;AACH;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;ACJA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,WAAW,mBAAO,CAAC,cAAI;AACvB,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,YAAY,mBAAO,CAAC,yCAAU;AAC9B,iBAAiB,mBAAO,CAAC,mDAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,qBAAqB;;AAElC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,qBAAqB;;AAElC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,gEAAgE;;AAE7E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,mCAAmC;AACnC;AACA,OAAO;;AAEP;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;;;;;;;;;;AC5VA,gC;;;;;;;;;;;ACAA,qC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,qC;;;;;;;;;;;ACAA,wC;;;;;;;;;;;ACAA,sC;;;;;;;;;;;ACAA,0C;;;;;;;;;;;ACAA,wC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,kC;;;;;;;;;;;ACAA,6C;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,+C;;;;;;;;;;;ACAA,+C;;;;;;;;;;;ACAA,mD;;;;;;;;;;;ACAA,uC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,0C;;;;;;;;;;;ACAA,sC;;;;;;;;;;;ACAA,uC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,kC;;;;;;;;;;;ACAA,qC;;;;;;;;;;;ACAA,yC;;;;;;;;;;;ACAA,6C;;;;;;;;;;;ACAA,6C;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,uC;;;;;;;;;;;ACAA,wC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,wC;;;;;;;;;;;ACAA,qC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,0C;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,qC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,sD;;;;;;;;;;;ACAA,+B","file":"gateway.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/app.js\");\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"./src sync recursive\";","/**\n * Manages all of the add-ons used in the system.\n *\n * @module AddonManager\n */\n/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\n'use strict';\n\nconst config = require('config');\nconst Constants = require('./constants');\nconst Deferred = require('./deferred');\nconst EventEmitter = require('events').EventEmitter;\nconst Platform = require('./platform');\nconst Settings = require('./models/settings');\nconst UserProfile = require('./user-profile');\nconst Utils = require('./utils');\nconst fs = require('fs');\nconst path = require('path');\nconst rimraf = require('rimraf');\nconst semver = require('semver');\nconst tar = require('tar');\nconst os = require('os');\nconst promisePipe = require('promisepipe');\nconst fetch = require('node-fetch');\nconst {URLSearchParams} = require('url');\n\nconst pkg = require('../package.json');\n\nlet PluginClient, PluginServer;\n\n// Use webpack provided require for dynamic includes from the bundle  .\nconst dynamicRequire = (() => {\n  if (typeof __non_webpack_require__ !== 'undefined') {\n    // eslint-disable-next-line no-undef\n    return __non_webpack_require__;\n  }\n  return require;\n})();\n\n/**\n * @class AddonManager\n * @classdesc The AddonManager will load any add-ons from the 'addons'\n * directory. See loadAddons() for details.\n */\nclass AddonManager extends EventEmitter {\n\n  constructor() {\n    super();\n    this.adapters = new Map();\n    this.devices = {};\n    this.deferredAdd = null;\n    this.deferredRemove = null;\n    this.addonsLoaded = false;\n    this.installedAddons = new Set();\n    this.deferredWaitForAdapter = new Map();\n    this.pluginServer = null;\n  }\n\n  /**\n   * Adds an adapter to the collection of adapters managed by AddonManager.\n   * This function is typically called when loading add-ons.\n   */\n  addAdapter(adapter) {\n    if (!adapter.name) {\n      adapter.name = adapter.constructor.name;\n    }\n    this.adapters.set(adapter.id, adapter);\n\n    /**\n     * Adapter added event.\n     *\n     * This is event is emitted whenever a new adapter is loaded.\n     *\n     * @event adapterAdded\n     * @type  {Adapter}\n     */\n    this.emit(Constants.ADAPTER_ADDED, adapter);\n\n    const deferredWait = this.deferredWaitForAdapter.get(adapter.id);\n    if (deferredWait) {\n      this.deferredWaitForAdapter.delete(adapter.id);\n      deferredWait.resolve(adapter);\n    }\n  }\n\n  /**\n   * @method addNewThing\n   * Initiates pairing on all of the adapters that support it.\n   * The user then presses the \"button\" on the device to be added.\n   * @returns A promise that resolves to the newly added device.\n   */\n  addNewThing(pairingTimeout) {\n    const deferredAdd = new Deferred();\n\n    if (this.deferredAdd) {\n      deferredAdd.reject('Add already in progress');\n    } else if (this.deferredRemove) {\n      deferredAdd.reject('Remove already in progress');\n    } else {\n      this.deferredAdd = deferredAdd;\n      this.adapters.forEach((adapter) => {\n        console.log('About to call startPairing on', adapter.name);\n        adapter.startPairing(pairingTimeout);\n      });\n      this.pairingTimeout = setTimeout(() => {\n        console.log('Pairing timeout');\n        this.emit(Constants.PAIRING_TIMEOUT);\n        this.cancelAddNewThing();\n      }, pairingTimeout * 1000);\n    }\n\n    return deferredAdd.promise;\n  }\n\n  /**\n   * @method cancelAddNewThing\n   *\n   * Cancels a previous addNewThing request.\n   */\n  cancelAddNewThing() {\n    const deferredAdd = this.deferredAdd;\n\n    if (this.pairingTimeout) {\n      clearTimeout(this.pairingTimeout);\n      this.pairingTimeout = null;\n    }\n\n    if (deferredAdd) {\n      this.adapters.forEach((adapter) => {\n        adapter.cancelPairing();\n      });\n      this.deferredAdd = null;\n      deferredAdd.reject('addNewThing cancelled');\n    }\n  }\n\n  /**\n   * @method cancelRemoveThing\n   *\n   * Cancels a previous removeThing request.\n   */\n  cancelRemoveThing(thingId) {\n    const deferredRemove = this.deferredRemove;\n    if (deferredRemove) {\n      const device = this.getDevice(thingId);\n      if (device) {\n        const adapter = device.adapter;\n        if (adapter) {\n          adapter.cancelRemoveThing(device);\n        }\n      }\n      this.deferredRemove = null;\n      deferredRemove.reject('removeThing cancelled');\n    }\n  }\n\n  /**\n   * @method getAdapter\n   * @returns Returns the adapter with the indicated id.\n   */\n  getAdapter(adapterId) {\n    return this.adapters.get(adapterId);\n  }\n\n  /**\n   * @method getAdaptersByPackageName\n   * @returns Returns a list of loaded adapters with the given package name.\n   */\n  getAdaptersByPackageName(packageName) {\n    return Array.from(this.adapters.values()).filter(\n      (a) => a.getPackageName() === packageName);\n  }\n\n  /**\n   * @method getAdapters\n   * @returns Returns a Map of the loaded adapters. The dictionary\n   *          key corresponds to the adapter id.\n   */\n  getAdapters() {\n    return this.adapters;\n  }\n\n  /**\n   * @method getDevice\n   * @returns Returns the device with the indicated id.\n   */\n  getDevice(id) {\n    return this.devices[id];\n  }\n\n  /**\n   * @method getDevices\n   * @returns Returns an dictionary of all of the known devices.\n   *          The dictionary key corresponds to the device id.\n   */\n  getDevices() {\n    return this.devices;\n  }\n\n  /**\n   * @method getPlugin\n   *\n   * Returns a previously registered plugin.\n   */\n  getPlugin(pluginId) {\n    if (this.pluginServer) {\n      return this.pluginServer.getPlugin(pluginId);\n    }\n  }\n\n  /**\n   * @method getThings\n   * @returns Returns a dictionary of all of the known things.\n   *          The dictionary key corresponds to the device id.\n   */\n  getThings() {\n    const things = [];\n    for (const thingId in this.devices) {\n      things.push(this.getThing(thingId));\n    }\n    return things;\n  }\n\n  /**\n   * @method getThing\n   * @returns Returns the thing with the indicated id.\n   */\n  getThing(thingId) {\n    const device = this.getDevice(thingId);\n    if (device) {\n      return device.asThing();\n    }\n  }\n\n  /**\n   * @method getPropertyDescriptions\n   * @returns Retrieves all of the properties associated with the thing\n   *          identified by `thingId`.\n   */\n  getPropertyDescriptions(thingId) {\n    const device = this.getDevice(thingId);\n    if (device) {\n      return device.getPropertyDescriptions();\n    }\n  }\n\n  /**\n   * @method getPropertyDescription\n   * @returns Retrieves the property named `propertyName` from the thing\n   *          identified by `thingId`.\n   */\n  getPropertyDescription(thingId, propertyName) {\n    const device = this.getDevice(thingId);\n    if (device) {\n      return device.getPropertyDescription(propertyName);\n    }\n  }\n\n  /**\n   * @method getProperty\n   * @returns a promise which resolves to the retrieved value of `propertyName`\n   *          from the thing identified by `thingId`.\n   */\n  getProperty(thingId, propertyName) {\n    const device = this.getDevice(thingId);\n    if (device) {\n      return device.getProperty(propertyName);\n    }\n\n    return Promise.reject(`getProperty: device: ${thingId} not found.`);\n  }\n\n  /**\n   * @method setProperty\n   * @returns a promise which resolves to the updated value of `propertyName`\n   *          for the thing identified by `thingId`.\n   */\n  setProperty(thingId, propertyName, value) {\n    const device = this.getDevice(thingId);\n    if (device) {\n      return device.setProperty(propertyName, value);\n    }\n\n    return Promise.reject(`setProperty: device: ${thingId} not found.`);\n  }\n\n  /**\n   * @method setPin\n   * @returns a promise which resolves when the PIN has been set.\n   */\n  setPin(thingId, pin) {\n    const device = this.getDevice(thingId);\n    if (device) {\n      return device.adapter.setPin(thingId, pin);\n    }\n\n    return Promise.reject(`setPin: device ${thingId} not found.`);\n  }\n\n  /**\n   * @method requestAction\n   * @returns a promise which resolves when the action has been requested.\n   */\n  requestAction(thingId, actionId, actionName, input) {\n    const device = this.getDevice(thingId);\n    if (device) {\n      return device.requestAction(actionId, actionName, input);\n    }\n\n    return Promise.reject(`requestAction: device: ${thingId} not found.`);\n  }\n\n  /**\n   * @method removeAction\n   * @returns a promise which resolves when the action has been removed.\n   */\n  removeAction(thingId, actionId, actionName) {\n    const device = this.getDevice(thingId);\n    if (device) {\n      return device.removeAction(actionId, actionName);\n    }\n\n    return Promise.reject(`removeAction: device: ${thingId} not found.`);\n  }\n\n  /**\n   * @method handleDeviceAdded\n   *\n   * Called when the indicated device has been added to an adapter.\n   */\n  handleDeviceAdded(device) {\n    this.devices[device.id] = device;\n    const thing = device.asThing();\n\n    /**\n     * Thing added event.\n     *\n     * This event is emitted whenever a new thing is added.\n     *\n     * @event thingAdded\n     * @type  {Thing}\n     */\n    this.emit(Constants.THING_ADDED, thing);\n\n    // If this device was added in response to addNewThing, then\n    // We need to cancel pairing mode on all of the \"other\" adapters.\n\n    const deferredAdd = this.deferredAdd;\n    if (deferredAdd) {\n      this.deferredAdd = null;\n      this.adapters.forEach((adapter) => {\n        if (adapter !== device.adapter) {\n          adapter.cancelPairing();\n        }\n      });\n      if (this.pairingTimeout) {\n        clearTimeout(this.pairingTimeout);\n        this.pairingTimeout = null;\n      }\n      deferredAdd.resolve(thing);\n    }\n  }\n\n  /**\n   * @method handleDeviceRemoved\n   * Called when the indicated device has been removed an adapter.\n   */\n  handleDeviceRemoved(device) {\n    delete this.devices[device.id];\n    const thing = device.asThing();\n\n    /**\n     * Thing removed event.\n     *\n     * This event is emitted whenever a new thing is removed.\n     *\n     * @event thingRemoved\n     * @type  {Thing}\n     */\n    this.emit(Constants.THING_REMOVED, thing);\n\n    const deferredRemove = this.deferredRemove;\n    if (deferredRemove && deferredRemove.adapter == device.adapter) {\n      this.deferredRemove = null;\n      deferredRemove.resolve(device.id);\n    }\n  }\n\n  /**\n   * @method validateManifestObject\n   *\n   * Verifies one level of an object, and recurses as required.\n   */\n  validateManifestObject(prefix, object, template) {\n    for (const key in template) {\n      if (key in object) {\n        const objectVal = object[key];\n        const templateVal = template[key];\n        if (typeof objectVal !== typeof templateVal) {\n          return `Expecting ${prefix}${key} to have type: ${\n            typeof templateVal}, found: ${typeof objectVal}`;\n        }\n        if (typeof objectVal === 'object') {\n          if (Array.isArray(objectVal)) {\n            if (templateVal.length > 0) {\n              const expectedType = typeof templateVal[0];\n              for (const val of objectVal) {\n                if (typeof val !== expectedType) {\n                  return `Expecting all values in ${prefix}${key} to be of ` +\n                    `type ${expectedType}`;\n                }\n              }\n            }\n          } else {\n            const err = this.validateManifestObject(`${prefix + key}.`,\n                                                    objectVal, templateVal);\n            if (err) {\n              return err;\n            }\n          }\n        }\n      } else {\n        return `Manifest is missing: ${prefix}${key}`;\n      }\n    }\n  }\n\n  /**\n   * @method validateManifest\n   *\n   * Verifies that the manifest looks valid. We only need to validate\n   * fields that we actually use.\n   */\n  validateManifest(manifest) {\n    const manifestTemplate = {\n      name: '',\n      version: '',\n      files: [''],\n      moziot: {\n        api: {\n          min: 0,\n          max: 0,\n        },\n      },\n    };\n    if (config.get('ipc.protocol') !== 'inproc') {\n      // If we're not using in-process plugins, then\n      // we also need the exec keyword to exist.\n      manifestTemplate.moziot.exec = '';\n    }\n    return this.validateManifestObject('', manifest, manifestTemplate);\n  }\n\n  /**\n   * @method loadAddon\n   *\n   * Loads add-on with the given package name.\n   *\n   * @param {String} packageName The package name of the add-on to load.\n   * @returns A promise which is resolved when the add-on is loaded.\n   */\n  async loadAddon(packageName) {\n    const addonPath = path.join(UserProfile.addonsDir, packageName);\n\n    // Skip if there's no package.json file.\n    const packageJson = path.join(addonPath, 'package.json');\n    if (!fs.lstatSync(packageJson).isFile()) {\n      const err = `package.json not found: ${packageJson}`;\n      console.error(err);\n      return Promise.reject(err);\n    }\n\n    // Read the package.json file.\n    let data;\n    try {\n      data = fs.readFileSync(packageJson);\n    } catch (e) {\n      const err =\n        `Failed to read package.json: ${packageJson}\\n${e}`;\n      console.error(err);\n      return Promise.reject(err);\n    }\n\n    let manifest;\n    try {\n      manifest = JSON.parse(data);\n    } catch (e) {\n      const err =\n        `Failed to parse package.json: ${packageJson}\\n${e}`;\n      console.error(err);\n      return Promise.reject(err);\n    }\n\n    // Verify that the name in the package matches the packageName\n    if (manifest.name != packageName) {\n      const err = `Name from package.json \"${manifest.name}\" doesn't ` +\n                  `match the name from list.json \"${packageName}\"`;\n      console.error(err);\n      return Promise.reject(err);\n    }\n\n    // Verify the files list in the package.\n    if (!manifest.hasOwnProperty('files') || manifest.files.length === 0) {\n      const err = `files property missing for package ${manifest.name}`;\n      console.error(err);\n      return Promise.reject(err);\n    }\n\n    if (fs.existsSync(path.join(addonPath, '.git'))) {\n      // This looks like a git repository, so we'll skip checking the\n      // SHA256SUMS file.\n      const sha256SumsIndex = manifest.files.indexOf('SHA256SUMS');\n      if (sha256SumsIndex >= 0) {\n        manifest.files.splice(sha256SumsIndex, 1);\n        console.log(`Not checking SHA256SUMS file for ${manifest.name} ` +\n        'since a .git directory was detected');\n      }\n    }\n\n    for (let fname of manifest.files) {\n      fname = path.join(addonPath, fname);\n      if (!fs.existsSync(fname)) {\n        const err = `Package ${manifest.name} missing file: ${fname}`;\n        console.error(err);\n        return Promise.reject(err);\n      }\n    }\n\n    // If a SHA256SUMS file is present, verify it. This file is of the format:\n    // <checksum> <filename>\n    //\n    // To generate a file of this type, you can use:\n    //   `rm -f SHA256SUMS && sha256sum file1 file2 ... > SHA256SUMS`\n    // To verify, use:\n    //   `sha256sum --check SHA256SUMS`\n    if (manifest.files.includes('SHA256SUMS')) {\n      const sumsFile = path.join(addonPath, 'SHA256SUMS');\n      try {\n        const data = fs.readFileSync(sumsFile, 'utf8');\n        const lines = data.trim().split(/\\r?\\n/);\n        for (const line of lines) {\n          const checksum = line.slice(0, 64);\n          const filename = line.slice(64).trimLeft();\n\n          if (Utils.hashFile(path.join(addonPath, filename)) !== checksum) {\n            const err =\n              `Checksum failed in package ${manifest.name}: ${filename}`;\n            console.error(err);\n            return Promise.reject(err);\n          }\n        }\n      } catch (e) {\n        const err =\n          `Failed to read SHA256SUMS for package ${manifest.name}: ${e}`;\n        console.error(err);\n        return Promise.reject(err);\n      }\n    }\n\n    // Verify that important fields exist in the manifest\n    const err = this.validateManifest(manifest);\n    if (err) {\n      return Promise.reject(\n        `Error found in manifest for ${packageName}\\n${err}`);\n    }\n\n    // Verify API version.\n    const apiVersion = config.get('addonManager.api');\n    if (manifest.moziot.api.min > apiVersion ||\n        manifest.moziot.api.max < apiVersion) {\n      const err = `API mismatch for package: ${manifest.name}\\nCurrent: ${\n        apiVersion} Supported: ${manifest.moziot.api.min}-${\n        manifest.moziot.api.max}`;\n      console.error(err);\n      return Promise.reject(err);\n    }\n\n    // Get any saved settings for this add-on.\n    const key = `addons.${manifest.name}`;\n    const savedSettings = await Settings.get(key);\n    const newSettings = Object.assign({}, manifest);\n    if (savedSettings) {\n      // Overwrite config and enablement values.\n      newSettings.moziot.enabled = savedSettings.moziot.enabled;\n      newSettings.moziot.config = Object.assign(manifest.moziot.config || {},\n                                                savedSettings.moziot.config);\n    } else {\n      if (!manifest.moziot.hasOwnProperty('enabled')) {\n        newSettings.moziot.enabled = false;\n      }\n\n      if (!newSettings.moziot.hasOwnProperty('config')) {\n        newSettings.moziot.config = {};\n      }\n    }\n\n    // Update the settings database.\n    await Settings.set(key, newSettings);\n    this.installedAddons.add(packageName);\n\n    // If this add-on is not explicitly enabled, move on.\n    if (!newSettings.moziot.enabled) {\n      const err = `Package not enabled: ${manifest.name}`;\n      console.log(err);\n      return Promise.reject(err);\n    }\n\n    const errorCallback = function(packageName, errorStr) {\n      console.error('Failed to load', packageName, '-', errorStr);\n    };\n\n    // Load the add-on\n    console.log('Loading add-on:', manifest.name);\n    if (config.get('ipc.protocol') === 'inproc') {\n      // This is a special case where we load the adapter directly\n      // into the gateway, but we use IPC comms to talk to the\n      // add-on (i.e. for testing)\n      const pluginClient = new PluginClient(manifest.name,\n                                            {verbose: false});\n      try {\n        const addonManagerProxy = await pluginClient.register();\n        console.log('Loading add-on', manifest.name, 'as plugin');\n        const addonLoader = dynamicRequire(addonPath);\n        addonLoader(addonManagerProxy, newSettings, errorCallback);\n      } catch (e) {\n        const err =\n          `Failed to register package with gateway: ${manifest.name}\\n${e}`;\n        console.error(err);\n        return Promise.reject(err);\n      }\n    } else {\n      // This is the normal plugin adapter case, tell the PluginServer\n      // to load the plugin.\n      this.pluginServer.loadPlugin(addonPath, newSettings);\n    }\n  }\n\n  /**\n   * @method loadAddons\n   * Loads all of the configured add-ons from the addons directory.\n   */\n  loadAddons() {\n    if (this.addonsLoaded) {\n      // This is kind of a hack, but it allows the gateway to restart properly\n      // when switching between http and https modes.\n      return;\n    }\n    this.addonsLoaded = true;\n\n    // Load the Plugin Server\n    PluginClient = require('./plugin/plugin-client');\n    PluginServer = require('./plugin/plugin-server');\n\n    this.pluginServer = new PluginServer(this, {verbose: false});\n\n    // Load the add-ons\n\n    const addonManager = this;\n    const addonPath = UserProfile.addonsDir;\n\n    // Search add-ons directory\n    fs.readdir(addonPath, async function(err, files) {\n      if (err) {\n        // This should probably never happen.\n        console.error('Failed to search add-ons directory');\n        console.error(err);\n        return;\n      }\n\n      for (const addonName of files) {\n        // Skip if not a directory. Use stat rather than lstat such that we\n        // also load through symlinks.\n        if (!fs.statSync(path.join(addonPath, addonName)).isDirectory()) {\n          continue;\n        }\n\n        addonManager.loadAddon(addonName).catch((err) => {\n          console.error(`Failed to load add-on: ${addonName}\\n${err}`);\n        });\n      }\n    });\n\n    if (process.env.NODE_ENV !== 'test') {\n      // Check for add-ons in 10 seconds (allow add-ons to load first).\n      setTimeout(() => {\n        this.updateAddons();\n\n        // Check every day.\n        const delay = 24 * 60 * 60 * 1000;\n        setInterval(this.updateAddons, delay);\n      }, 10000);\n    }\n  }\n\n  /**\n   * @method removeThing\n   *\n   * Initiates removing a particular device.\n   * @returns A promise that resolves to the device which was actually removed.\n   * Note that it's possible that the device actually removed might\n   * not be the same as the one requested. This can occur with zwave for\n   * example if the user presses the button on a device which is different\n   * from the one that they requested removal of.\n   */\n  removeThing(thingId) {\n    const deferredRemove = new Deferred();\n\n    if (this.deferredAdd) {\n      deferredRemove.reject('Add already in progress');\n    } else if (this.deferredRemove) {\n      deferredRemove.reject('Remove already in progress');\n    } else {\n      const device = this.getDevice(thingId);\n      if (device) {\n        deferredRemove.adapter = device.adapter;\n        this.deferredRemove = deferredRemove;\n        device.adapter.removeThing(device);\n      } else {\n        deferredRemove.resolve(thingId);\n      }\n    }\n\n    return deferredRemove.promise;\n  }\n\n  /**\n   * @method unloadAddons\n   * Unloads all of the loaded add-ons.\n   *\n   * @returns a promise which is resolved when all of the add-ons\n   *          are unloaded.\n   */\n  unloadAddons() {\n    if (!this.addonsLoaded) {\n      // The add-ons are not currently loaded, no need to unload.\n      return Promise.resolve();\n    }\n\n    const unloadPromises = [];\n    // unload the adapters in the reverse of the order that they were loaded.\n    for (const adapterId of Array.from(this.adapters.keys()).reverse()) {\n      unloadPromises.push(this.unloadAdapter(adapterId));\n    }\n\n    this.addonsLoaded = false;\n    return Promise.all(unloadPromises).then(() => {\n      if (this.pluginServer) {\n        this.pluginServer.shutdown();\n      }\n    });\n  }\n\n  /**\n   * @method unloadAdapter\n   * Unload the given adapter.\n   *\n   * @param {String} id The ID of the adapter to unload.\n   * @returns A promise which is resolved when the adapter is unloaded.\n   */\n  unloadAdapter(id) {\n    if (!this.addonsLoaded) {\n      // The add-ons are not currently loaded, no need to unload.\n      return Promise.resolve();\n    }\n\n    const adapter = this.getAdapter(id);\n    if (typeof adapter === 'undefined') {\n      // This adapter wasn't loaded.\n      return Promise.resolve();\n    }\n\n    console.log('Unloading', adapter.name);\n    this.adapters.delete(adapter.id);\n    return adapter.unload();\n  }\n\n  /**\n   * @method unloadAddon\n   * Unload add-on with the given package name.\n   *\n   * @param {String} packageName The package name of the add-on to unload.\n   * @param {Boolean} wait Whether or not to wait for unloading to finish\n   * @returns A promise which is resolved when the add-on is unloaded.\n   */\n  unloadAddon(packageName, wait) {\n    if (!this.addonsLoaded) {\n      // The add-ons are not currently loaded, no need to unload.\n      return Promise.resolve();\n    }\n\n    const plugin = this.getPlugin(packageName);\n    let pluginProcess = {};\n    if (plugin) {\n      pluginProcess = plugin.process;\n    }\n\n    const adapters = this.getAdaptersByPackageName(packageName);\n    const adapterIds = adapters.map((a) => a.id);\n    const unloadPromises = [];\n    if (adapters.length > 0) {\n      for (const a of adapters) {\n        console.log('Unloading', a.name);\n        unloadPromises.push(a.unload());\n        this.adapters.delete(a.id);\n      }\n    } else if (plugin) {\n      // If there are no adapters, manually unload the plugin, otherwise it\n      // will just restart. Note that if the addon is disabled, then\n      // there might not be a plugin either.\n      plugin.unload();\n    }\n\n    // Give the process 3 seconds to exit before killing it.\n    const cleanup = () => {\n      setTimeout(() => {\n        if (pluginProcess.p) {\n          console.log(`Killing ${packageName} plugin.`);\n          pluginProcess.p.kill();\n        }\n\n        // Remove devices owned by this add-on.\n        for (const deviceId of Object.keys(this.devices)) {\n          if (adapterIds.includes(this.devices[deviceId].adapter.id)) {\n            this.handleDeviceRemoved(this.devices[deviceId]);\n          }\n        }\n      }, Constants.UNLOAD_PLUGIN_KILL_DELAY);\n    };\n\n    const all =\n      Promise.all(unloadPromises).then(() => cleanup(), () => cleanup());\n\n    if (wait) {\n      // If wait was set, wait 3 seconds + a little for the process to die.\n      // 3 seconds, because that's what is used in unloadAddon().\n      return all.then(() => {\n        return new Promise((resolve) => {\n          setTimeout(resolve, Constants.UNLOAD_PLUGIN_KILL_DELAY + 500);\n        });\n      });\n    }\n\n    return all;\n  }\n\n  /**\n   * @method isAddonInstalled\n   *\n   * @param {String} packageName The package name to check\n   * @returns Boolean indicating whether or not the package name is installed\n   *          on the system.\n   */\n  isAddonInstalled(packageName) {\n    return this.installedAddons.has(packageName);\n  }\n\n  /**\n   * Install an add-on.\n   *\n   * @param {String} name The package name\n   * @param {String} url The package URL\n   * @param {String} checksum SHA-256 checksum of the package\n   * @param {Boolean} enable Whether or not to enable the add-on after install\n   * @returns A Promise that resolves when the add-on is installed.\n   */\n  async installAddonFromUrl(name, url, checksum, enable) {\n    const tempPath = fs.mkdtempSync(`${os.tmpdir()}${path.sep}`);\n    const destPath = path.join(tempPath, `${name}.tar.gz`);\n\n    console.log(`Fetching add-on ${url} as ${destPath}`);\n\n    try {\n      const res = await fetch(url);\n      if (!res.ok) {\n        throw new Error(`HTTP error status: ${res.status}`);\n      }\n\n      const dest = fs.createWriteStream(destPath);\n      await promisePipe(res.body, dest);\n    } catch (e) {\n      rimraf(tempPath, {glob: false}, (e) => {\n        if (e) {\n          console.error(`Error removing temp directory: ${tempPath}\\n${e}`);\n        }\n      });\n      const err = `Failed to download add-on: ${name}\\n${e}`;\n      console.error(err);\n      return Promise.reject(err);\n    }\n\n    if (Utils.hashFile(destPath) !== checksum.toLowerCase()) {\n      rimraf(tempPath, {glob: false}, (e) => {\n        if (e) {\n          console.error(`Error removing temp directory: ${tempPath}\\n${e}`);\n        }\n      });\n      const err = `Checksum did not match for add-on: ${name}`;\n      console.error(err);\n      return Promise.reject(err);\n    }\n\n    let success = false, err;\n    try {\n      await this.installAddon(name, destPath, enable);\n      success = true;\n    } catch (e) {\n      err = e;\n    }\n\n    rimraf(tempPath, {glob: false}, (e) => {\n      if (e) {\n        console.error(`Error removing temp directory: ${tempPath}\\n${e}`);\n      }\n    });\n\n    if (!success) {\n      console.error(err);\n      return Promise.reject(err);\n    }\n  }\n\n  /**\n   * @method installAddon\n   *\n   * @param {String} packageName The package name to install\n   * @param {String} packagePath Path to the package tarball\n   * @param {Boolean} enable Whether or not to enable the add-on after install\n   * @returns A promise that resolves when the package is installed.\n   */\n  async installAddon(packageName, packagePath, enable) {\n    if (!this.addonsLoaded) {\n      const err =\n        'Cannot install add-on before other add-ons have been loaded.';\n      console.error(err);\n      return Promise.reject(err);\n    }\n\n    if (!fs.lstatSync(packagePath).isFile()) {\n      const err = `Cannot extract invalid path: ${packagePath}`;\n      console.error(err);\n      return Promise.reject(err);\n    }\n\n    const addonPath = path.join(UserProfile.addonsDir, packageName);\n\n    try {\n      // Create the add-on directory, if necessary\n      if (!fs.existsSync(addonPath)) {\n        fs.mkdirSync(addonPath);\n      }\n    } catch (e) {\n      const err = `Failed to create add-on directory: ${addonPath}\\n${e}`;\n      console.error(err);\n      return Promise.reject(err);\n    }\n\n    const cleanup = () => {\n      if (fs.lstatSync(addonPath).isDirectory()) {\n        rimraf(addonPath, {glob: false}, (e) => {\n          if (e) {\n            console.error(`Error removing ${packageName}: ${e}`);\n          }\n        });\n      }\n    };\n\n    console.log(`Expanding add-on ${packagePath} into ${addonPath}`);\n\n    try {\n      // Try to extract the tarball\n      await tar.x({file: packagePath, strip: 1, cwd: addonPath}, ['package']);\n    } catch (e) {\n      // Clean up if extraction failed\n      cleanup();\n\n      const err = `Failed to extract package: ${packagePath}\\n${e}`;\n      console.error(err);\n      return Promise.reject(err);\n    }\n\n    // Update the saved settings (if any) and enable the add-on\n    const key = `addons.${packageName}`;\n    let savedSettings = await Settings.get(key);\n    if (savedSettings) {\n      // Only enable if we're supposed to. Otherwise, keep whatever the current\n      // setting is.\n      if (enable) {\n        savedSettings.moziot.enabled = true;\n      }\n    } else {\n      // If this add-on is brand new, use the passed-in enable flag.\n      savedSettings = {\n        moziot: {\n          enabled: enable,\n        },\n      };\n    }\n    await Settings.set(key, savedSettings);\n\n    if (savedSettings.moziot.enabled) {\n      // Now, load the add-on\n      try {\n        await this.loadAddon(packageName);\n      } catch (e) {\n        // Clean up if loading failed\n        cleanup();\n        return Promise.reject(`Failed to load add-on: ${packageName}\\n${e}`);\n      }\n    }\n  }\n\n  /**\n   * @method uninstallAddon\n   *\n   * @param {String} packageName The package name to uninstall\n   * @param {Boolean} wait Whether or not to wait for unloading to finish\n   * @param {Boolean} disable Whether or not to disable the add-on\n   * @returns A promise that resolves when the package is uninstalled.\n   */\n  async uninstallAddon(packageName, wait, disable) {\n    try {\n      // Try to gracefully unload\n      await this.unloadAddon(packageName, wait);\n    } catch (e) {\n      console.error(`Failed to unload ${packageName} properly: ${e}`);\n      // keep going\n    }\n\n    const addonPath = path.join(UserProfile.addonsDir, packageName);\n\n    // Unload this module from the require cache\n    Object.keys(require.cache).map((x) => {\n      if (x.startsWith(addonPath)) {\n        delete require.cache[x];\n      }\n    });\n\n    // Remove the package from the file system\n    if (fs.lstatSync(addonPath).isDirectory()) {\n      rimraf(addonPath, {glob: false}, (e) => {\n        if (e) {\n          console.error(`Error removing ${packageName}: ${e}`);\n        }\n      });\n    }\n\n    // Update the saved settings and disable the add-on\n    if (disable) {\n      const key = `addons.${packageName}`;\n      const savedSettings = await Settings.get(key);\n      if (savedSettings) {\n        savedSettings.moziot.enabled = false;\n        await Settings.set(key, savedSettings);\n      }\n    }\n\n    // Remove from our list of installed add-ons\n    this.installedAddons.delete(packageName);\n  }\n\n  /**\n   * @method waitForAdapter\n   *\n   * Returns a promise which resolves to the adapter with the indicated id.\n   * This function is really only used to support testing and\n   * ensure that tests don't proceed until\n   */\n  waitForAdapter(adapterId) {\n    const adapter = this.getAdapter(adapterId);\n    if (adapter) {\n      // The adapter already exists, just create a Promise\n      // that resolves to that.\n      return Promise.resolve(adapter);\n    }\n\n    let deferredWait = this.deferredWaitForAdapter.get(adapterId);\n    if (!deferredWait) {\n      // No deferred wait currently setup. Set a new one up.\n      deferredWait = new Deferred();\n      this.deferredWaitForAdapter.set(adapterId, deferredWait);\n    }\n\n    return deferredWait.promise;\n  }\n\n  /**\n   * @method updateAddons\n   *\n   * Attempt to update all installed add-ons.\n   *\n   * @returns A promise which is resolved when updating is complete.\n   */\n  async updateAddons() {\n    const url = config.get('addonManager.listUrl');\n    const api = config.get('addonManager.api');\n    const architecture = Platform.getArchitecture();\n    const version = pkg.version;\n    const nodeVersion = Platform.getNodeVersion();\n    const pythonVersions = Platform.getPythonVersions();\n    const addonPath = UserProfile.addonsDir;\n    const available = {};\n\n    console.log('Checking for add-on updates...');\n\n    try {\n      const params = new URLSearchParams();\n      params.set('api', api);\n      params.set('arch', architecture);\n      params.set('version', version);\n      params.set('node', nodeVersion);\n\n      if (pythonVersions && pythonVersions.length > 0) {\n        params.set('python', pythonVersions.join(','));\n      }\n\n      const response = await fetch(`${url}?${params.toString()}`, {\n        headers: {\n          Accept: 'application/json',\n          'User-Agent': `mozilla-iot-gateway/${version}`,\n        },\n      });\n      const list = await response.json();\n\n      for (const addon of list) {\n        available[addon.name] = {\n          version: addon.version,\n          url: addon.url,\n          checksum: addon.checksum,\n        };\n      }\n    } catch (e) {\n      console.error('Failed to parse add-on list.');\n      return;\n    }\n\n    // Try to update what we can. Don't use the installedAddons set because it\n    // doesn't contain add-ons that failed to load properly.\n    fs.readdir(addonPath, async (err, files) => {\n      if (err) {\n        console.error('Failed to search add-on directory');\n        console.error(err);\n        return;\n      }\n\n      for (const addonName of files) {\n        // Skip if not a directory. Use stat rather than lstat such that we\n        // also load through symlinks.\n        if (!fs.statSync(path.join(addonPath, addonName)).isDirectory()) {\n          continue;\n        }\n\n        // Skip if .git directory is present.\n        if (fs.existsSync(path.join(addonPath, addonName, '.git'))) {\n          console.log(\n            `Not updating ${addonName} since a .git directory was detected`);\n          continue;\n        }\n\n        // Try to load package.json.\n        const packageJson = path.join(addonPath, addonName, 'package.json');\n        if (!fs.existsSync(packageJson)) {\n          continue;\n        }\n\n        let manifest;\n        try {\n          const data = fs.readFileSync(packageJson);\n          manifest = JSON.parse(data);\n        } catch (e) {\n          console.error(`Failed to read package.json: ${packageJson}\\n${e}`);\n          continue;\n        }\n\n        // Check if an update is available.\n        if (available.hasOwnProperty(addonName) &&\n            semver.lt(manifest.version, available[addonName].version)) {\n          try {\n            await this.uninstallAddon(addonName, true, false);\n            await this.installAddonFromUrl(addonName,\n                                           available[addonName].url,\n                                           available[addonName].checksum,\n                                           false);\n          } catch (e) {\n            console.error(`Failed to update ${addonName}: ${e}`);\n          }\n        }\n      }\n\n      console.log('Finished updating add-ons');\n    });\n  }\n}\n\nmodule.exports = new AddonManager();\n","/*\n * app-instance.js\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n// The way that the jest framework works, it has a pool of\n// processes which each run one or more tests. This means that\n// there can be multiple process running at the same time.\n//\n// Furthermore, if one of the processes ends, then it may\n// start a new test. This means that the same process may\n// run multiple tests, one after the other.\n//\n// During tests, some portions of the gateway may require\n// a unique identifier for each test that is run, and that is\n// the purpose of this module.\n\n'use strict';\n\nconst process = require('process');\n\nclass AppInstance {\n\n  constructor() {\n    this.mark();\n  }\n\n  get() {\n    return `${process.pid}-${this.timestamp}`;\n  }\n\n  mark() {\n    const t = new Date();\n    this.timestamp = (`0${t.getHours()}`).slice(-2) +\n                     (`0${t.getMinutes()}`).slice(-2) +\n                     (`0${t.getSeconds()}`).slice(-2) +\n                     (`00${t.getMilliseconds()}`).slice(-3);\n  }\n}\n\nmodule.exports = new AppInstance();\n","/*\n * Things Gateway App.\n *\n * Back end main script.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n// Set up the user profile.\nconst UserProfile = require('./user-profile');\nUserProfile.init();\nconst migration = UserProfile.migrate();\n\n// External Dependencies\nconst https = require('https');\nconst http = require('http');\nconst fs = require('fs');\nconst express = require('express');\nconst expressWs = require('express-ws');\nconst fileUpload = require('express-fileupload');\nconst bodyParser = require('body-parser');\nconst GetOpt = require('node-getopt');\nconst config = require('config');\nconst path = require('path');\nconst expressHandlebars = require('express-handlebars');\nconst ipRegex = require('ip-regex');\n\n// Internal Dependencies\nconst addonManager = require('./addon-manager');\nconst db = require('./db');\nconst mDNSserver = require('./mdns-server');\nconst Router = require('./router');\nconst TunnelService = require('./ssltunnel');\nconst Constants = require('./constants');\nconst {wifi, wifiSetupApp} = require('./wifi-setup');\n\n// Causes a timestamp to be prepended to console log lines.\nrequire('./log-timestamps');\n\n// The following causes an instance of AppInstance to be created.\n// This is then used in other places (like src/addons/plugin/ipc.js)\nrequire('./app-instance');\n\n// Open the database\ndb.open();\n\nconst httpServer = http.createServer();\nconst httpApp = createGatewayApp(httpServer);\n\nlet httpsServer = createHttpsServer();\nlet httpsApp = null;\n\n/**\n * Creates an HTTPS server object, if successful. If there are no public and\n * private keys stored for the tunnel service, null is returned.\n *\n * @param {}\n * @return {Object|null} https server object if successful, else NULL\n */\nfunction createHttpsServer() {\n  if (!TunnelService.hasCertificates()) {\n    return null;\n  }\n\n  // HTTPS server configuration\n  const options = {\n    key: fs.readFileSync(path.join(UserProfile.sslDir, 'privatekey.pem')),\n    cert: fs.readFileSync(path.join(UserProfile.sslDir, 'certificate.pem')),\n  };\n  if (fs.existsSync(path.join(UserProfile.sslDir, 'chain.pem'))) {\n    options.ca = fs.readFileSync(path.join(UserProfile.sslDir, 'chain.pem'));\n  }\n  return https.createServer(options);\n}\n\nfunction startHttpsGateway() {\n  let port = config.get('ports.https');\n  const cliOptions = getOptions();\n  if (typeof cliOptions.port === 'number') {\n    port = cliOptions.port;\n  }\n\n  if (!httpsServer) {\n    httpsServer = createHttpsServer();\n  }\n\n  httpsApp = createGatewayApp(httpsServer);\n  httpsServer.on('request', httpsApp);\n\n  // Start the HTTPS server\n  httpsServer.listen(port, function() {\n    migration.then(function() {\n      addonManager.loadAddons();\n    });\n    rulesEngineConfigure(httpsServer);\n    console.log('HTTPS server listening on port', httpsServer.address().port);\n  });\n\n  // Redirect HTTP to HTTPS\n  httpServer.on('request', createRedirectApp(httpsServer.address().port));\n  const httpPort = config.get('ports.http');\n  httpServer.listen(httpPort, function() {\n    console.log('Redirector listening on port', httpServer.address().port);\n  });\n}\n\nfunction startHttpGateway() {\n  httpServer.on('request', httpApp);\n\n  let port = config.get('ports.http');\n  const options = getOptions();\n  if (typeof options.port === 'number') {\n    port = options.port;\n  }\n\n  httpServer.listen(port, function() {\n    migration.then(function() {\n      addonManager.loadAddons();\n    });\n    rulesEngineConfigure(httpServer);\n    console.log('HTTP server listening on port', httpServer.address().port);\n  });\n}\n\nfunction stopHttpGateway() {\n  httpServer.removeListener('request', httpApp);\n}\n\nfunction startWiFiSetup() {\n  httpServer.on('request', wifiSetupApp.onRequest);\n\n  let port = config.get('ports.http');\n  const options = getOptions();\n  if (typeof options.port === 'number') {\n    port = options.port;\n  }\n\n  httpServer.listen(port);\n}\n\nfunction stopWiFiSetup() {\n  httpServer.removeListener('request', wifiSetupApp.onRequest);\n}\n\nfunction getOptions() {\n  if (!config.get('cli')) {\n    return {\n      debug: false,\n      port: null,\n    };\n  }\n\n  // Command line arguments\n  const getopt = new GetOpt([\n    ['d', 'debug', 'Enable debug features'],\n    ['p', 'port=PORT', 'Specify the server port to use'],\n    ['h', 'help', 'Display help' ],\n    ['v', 'verbose', 'Show verbose output'],\n    ['', 'check-wifi',\n     'Run a connection check on the WiFi (only supported on RasPi)'],\n  ]);\n\n  const opt = getopt.parseSystem();\n  const options = {\n    debug: !!opt.options.debug, // cast to bool\n    verbose: opt.options.verbose,\n  };\n\n  if (opt.options.verbose) {\n    console.log(opt);\n  }\n\n  if (opt.options.help) {\n    getopt.showHelp();\n    process.exit(1);\n  }\n\n  if (opt.options.port) {\n    options.port = parseInt(opt.options.port);\n  }\n\n  if (opt.options['check-wifi']) {\n    options['check-wifi'] = opt.options['check-wifi'];\n  }\n  return options;\n}\n\n/**\n * Because the rules engine talks to the server over the public HTTP/WS API,\n * the gateway needs to configure it with a JWT and a server address\n * @param {http.Server|https.Server} server\n */\nfunction rulesEngineConfigure(server) {\n  const rulesEngine = require('./rules-engine/index.js');\n  let protocol = 'https';\n  if (server instanceof http.Server) {\n    protocol = 'http';\n  }\n  const gatewayHref = `${protocol}://127.0.0.1:${server.address().port}`;\n  rulesEngine.configure(gatewayHref);\n}\n\nfunction createApp() {\n  const app = express();\n  app.engine('handlebars', expressHandlebars());\n  app.set('view engine', 'handlebars');\n  app.set('views', Constants.VIEWS_PATH);\n\n  // Use bodyParser to access the body of requests\n  app.use(bodyParser.urlencoded({\n    extended: false,\n  }));\n  app.use(bodyParser.json({limit: '1mb'}));\n\n  // Use fileUpload to handle multi-part uploads\n  app.use(fileUpload());\n\n  return app;\n}\n\n/**\n * @param {http.Server|https.Server} server\n * @return {express.Router}\n */\nfunction createGatewayApp(server) {\n  const app = createApp();\n  const opt = getOptions();\n\n  // Inject WebSocket support\n  expressWs(app, server);\n\n  // Configure router with configured app and command line options.\n  Router.configure(app, opt);\n  return app;\n}\n\nfunction createRedirectApp(port) {\n  const app = createApp();\n\n  // Allow LE challenges, used when renewing domain.\n  app.use(\n    /^\\/\\.well-known\\/acme-challenge\\/.*/,\n    function(request, response, next) {\n      if (request.method !== 'GET') {\n        response.sendStatus(403);\n        return;\n      }\n\n      const reqPath = path.join(Constants.BUILD_STATIC_PATH, request.path);\n      if (fs.existsSync(reqPath)) {\n        response.sendFile(reqPath);\n        return;\n      }\n\n      next();\n    });\n\n  // Redirect based on https://https.cio.gov/apis/\n  app.use(function(request, response) {\n    if (request.method !== 'GET') {\n      response.sendStatus(403);\n      return;\n    }\n    if (request.headers.authorization) {\n      response.sendStatus(403);\n      return;\n    }\n    let httpsUrl = `https://${request.hostname}`;\n    // If we're behind forwarding we can redirect to the port-free https url\n    if (port !== 443 && !config.get('behindForwarding')) {\n      httpsUrl += `:${port}`;\n    }\n    httpsUrl += request.url;\n\n    // If the request is for a bare hostname, a .local address, or an IP\n    // address, use a 307 redirect to prevent caching. For instance, if the\n    // browser caches a redirect for gateway.local to the HTTPS version, things\n    // will break after resetting/reflashing the gateway.\n    //\n    // Otherwise, use a 301 to help mitigate DNS hijacking.\n    if (request.hostname.indexOf('.') < 0 ||\n        request.hostname.endsWith('.local') ||\n        ipRegex({exact: true}).test(request.hostname)) {\n      response.redirect(307, httpsUrl);\n    } else {\n      response.redirect(301, httpsUrl);\n    }\n  });\n\n  return app;\n}\n\nlet serverStartup = Promise.resolve();\nlet wifiPromise = Promise.resolve(true);\nconst options = getOptions();\n\nif (options['check-wifi']) {\n  wifiPromise = wifi.checkConnection();\n}\n\nwifiPromise.then((connected) => {\n  if (!connected) {\n    wifiSetupApp.onConnection = function() {\n      stopWiFiSetup();\n      startGateway();\n    };\n    startWiFiSetup();\n  } else {\n    startGateway();\n  }\n});\n\nfunction startGateway() {\n  // if we have the certificates installed, we start https\n  if (TunnelService.hasCertificates()) {\n    serverStartup = TunnelService.userSkipped().then(function(res) {\n      if (res) {\n        startHttpGateway();\n      } else {\n        startHttpsGateway();\n        TunnelService.hasTunnelToken().then(function(result) {\n          if (result) {\n            TunnelService.start();\n          }\n        });\n      }\n    });\n  } else {\n    startHttpGateway();\n  }\n}\n\nif (config.get('cli')) {\n  // Get some decent error messages for unhandled rejections. This is\n  // often just errors in the code.\n  process.on('unhandledRejection', (reason) => {\n    console.log('Unhandled Rejection');\n    console.error(reason);\n  });\n\n  // Do graceful shutdown when Control-C is pressed.\n  process.on('SIGINT', function() {\n    console.log('Control-C: unloading add-ons...');\n    addonManager.unloadAddons();\n    mDNSserver.server.cleanup();\n    TunnelService.stop();\n    process.exit(0);\n  });\n}\n\n// function to stop running server and start https\nTunnelService.switchToHttps = function() {\n  stopHttpGateway();\n  startHttpsGateway();\n};\n\n// This part starts our Service Discovery process.\n// We check to see if mDNS should be setup in default mode, or has a previous\n// user setup a unique domain. Then we start it.\nmDNSserver.getmDNSstate().then((state) => {\n  try {\n    mDNSserver.getmDNSconfig().then((mDNSconfig) => {\n      console.log(`DNS config is: ${mDNSconfig.host}`);\n      mDNSserver.server.changeProfile(mDNSconfig);\n      mDNSserver.server.setState(state);\n    });\n  } catch (err) {\n    // if we failed to startup mDNS it's not the end of the world log it\n    // and carry on\n    console.error(`Service Discover failed to start with error: ${err}`);\n  }\n});\n\nmodule.exports = { // for testing\n  httpServer: httpServer,\n  server: httpsServer,\n  serverStartup: serverStartup,\n};\n","/**\n * Command utilities.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n/**\n * Mapping of CSS color names (in human-readable form) to hex colors.\n */\nconst colors = {\n  black: '#000000',\n  silver: '#c0c0c0',\n  gray: '#808080',\n  white: '#ffffff',\n  maroon: '#800000',\n  red: '#ff0000',\n  purple: '#800080',\n  fuchsia: '#ff00ff',\n  green: '#008000',\n  lime: '#00ff00',\n  olive: '#808000',\n  yellow: '#ffff00',\n  navy: '#000080',\n  blue: '#0000ff',\n  teal: '#008080',\n  aqua: '#00ffff',\n  orange: '#ffa500',\n  'alice blue': '#f0f8ff',\n  'antique white': '#faebd7',\n  aquamarine: '#7fffd4',\n  azure: '#f0ffff',\n  beige: '#f5f5dc',\n  bisque: '#ffe4c4',\n  'blanched almond': '#ffebcd',\n  'blue violet': '#8a2be2',\n  brown: '#a52a2a',\n  burlywood: '#deb887',\n  'cadet blue': '#5f9ea0',\n  chartreuse: '#7fff00',\n  chocolate: '#d2691e',\n  coral: '#ff7f50',\n  'cornflower blue': '#6495ed',\n  'corn silk': '#fff8dc',\n  crimson: '#dc143c',\n  cyan: '#00ffff',\n  'dark blue': '#00008b',\n  'dark cyan': '#008b8b',\n  'dark goldenrod': '#b8860b',\n  'dark gray': '#a9a9a9',\n  'dark green': '#006400',\n  'dark grey': '#a9a9a9',\n  'dark khaki': '#bdb76b',\n  'dark magenta': '#8b008b',\n  'dark olive green': '#556b2f',\n  'dark orange': '#ff8c00',\n  'dark orchid': '#9932cc',\n  'dark red': '#8b0000',\n  'dark salmon': '#e9967a',\n  'dark seagreen': '#8fbc8f',\n  'dark slate blue': '#483d8b',\n  'dark slate gray': '#2f4f4f',\n  'dark slate grey': '#2f4f4f',\n  'dark turquoise': '#00ced1',\n  'dark violet': '#9400d3',\n  'deep pink': '#ff1493',\n  'deep sky blue': '#00bfff',\n  'dim gray': '#696969',\n  'dim grey': '#696969',\n  'dodger blue': '#1e90ff',\n  firebrick: '#b22222',\n  'floral white': '#fffaf0',\n  'forest green': '#228b22',\n  gainsboro: '#dcdcdc',\n  'ghost white': '#f8f8ff',\n  gold: '#ffd700',\n  goldenrod: '#daa520',\n  'green yellow': '#adff2f',\n  grey: '#808080',\n  honeydew: '#f0fff0',\n  'hot pink': '#ff69b4',\n  'indian red': '#cd5c5c',\n  indigo: '#4b0082',\n  ivory: '#fffff0',\n  khaki: '#f0e68c',\n  lavender: '#e6e6fa',\n  'lavender blush': '#fff0f5',\n  'lawn green': '#7cfc00',\n  'lemon chiffon': '#fffacd',\n  'light blue': '#add8e6',\n  'light coral': '#f08080',\n  'light cyan': '#e0ffff',\n  'light goldenrod yellow': '#fafad2',\n  'light gray': '#d3d3d3',\n  'light green': '#90ee90',\n  'light grey': '#d3d3d3',\n  'light pink': '#ffb6c1',\n  'light salmon': '#ffa07a',\n  'light sea green': '#20b2aa',\n  'light sky blue': '#87cefa',\n  'light slate gray': '#778899',\n  'light slate grey': '#778899',\n  'light steel blue': '#b0c4de',\n  'light yellow': '#ffffe0',\n  'lime green': '#32cd32',\n  linen: '#faf0e6',\n  magenta: '#ff00ff',\n  'medium aquamarine': '#66cdaa',\n  'medium blue': '#0000cd',\n  'medium orchid': '#ba55d3',\n  'medium purple': '#9370db',\n  'medium sea green': '#3cb371',\n  'medium slate blue': '#7b68ee',\n  'medium spring green': '#00fa9a',\n  'medium turquoise': '#48d1cc',\n  'medium violet red': '#c71585',\n  'midnight blue': '#191970',\n  'mint cream': '#f5fffa',\n  'misty rose': '#ffe4e1',\n  moccasin: '#ffe4b5',\n  'navajo white': '#ffdead',\n  'old lace': '#fdf5e6',\n  'olive drab': '#6b8e23',\n  'orange red': '#ff4500',\n  orchid: '#da70d6',\n  'pale goldenrod': '#eee8aa',\n  'pale green': '#98fb98',\n  'pale turquoise': '#afeeee',\n  'pale violet red': '#db7093',\n  'papaya whip': '#ffefd5',\n  'peach puff': '#ffdab9',\n  peru: '#cd853f',\n  pink: '#ffc0cb',\n  plum: '#dda0dd',\n  'powder blue': '#b0e0e6',\n  'rosy brown': '#bc8f8f',\n  'royal blue': '#4169e1',\n  'saddle brown': '#8b4513',\n  salmon: '#fa8072',\n  'sandy brown': '#f4a460',\n  'sea green': '#2e8b57',\n  seashell: '#fff5ee',\n  sienna: '#a0522d',\n  'sky blue': '#87ceeb',\n  'slate blue': '#6a5acd',\n  'slate gray': '#708090',\n  'slate grey': '#708090',\n  snow: '#fffafa',\n  'spring green': '#00ff7f',\n  'steel blue': '#4682b4',\n  tan: '#d2b48c',\n  thistle: '#d8bfd8',\n  tomato: '#ff6347',\n  turquoise: '#40e0d0',\n  violet: '#ee82ee',\n  wheat: '#f5deb3',\n  'white smoke': '#f5f5f5',\n  'yellow green': '#9acd32',\n  'rebecca purple': '#663399',\n};\n\n/**\n * Mapping of percentages (in human-readable form) to numbers.\n */\nconst percentages = {\n  'zero percent': 0,\n  'one percent': 1,\n  'two percent': 2,\n  'three percent': 3,\n  'four percent': 4,\n  'five percent': 5,\n  'six percent': 6,\n  'seven percent': 7,\n  'eight percent': 8,\n  'nine percent': 9,\n\n  'ten percent': 10,\n  'eleven percent': 11,\n  'twelve percent': 12,\n  'thirteen percent': 13,\n  'fourteen percent': 14,\n  'fifteen percent': 15,\n  'sixteen percent': 16,\n  'seventeen percent': 17,\n  'eighteen percent': 18,\n  'nineteen percent': 19,\n\n  'twenty percent': 20,\n  'twenty one percent': 21,\n  'twenty two percent': 22,\n  'twenty three percent': 23,\n  'twenty four percent': 24,\n  'twenty five percent': 25,\n  'twenty six percent': 26,\n  'twenty seven percent': 27,\n  'twenty eight percent': 28,\n  'twenty nine percent': 29,\n\n  'thirty percent': 30,\n  'thirty one percent': 31,\n  'thirty two percent': 32,\n  'thirty three percent': 33,\n  'thirty four percent': 34,\n  'thirty five percent': 35,\n  'thirty six percent': 36,\n  'thirty seven percent': 37,\n  'thirty eight percent': 38,\n  'thirty nine percent': 39,\n\n  'forty percent': 40,\n  'forty one percent': 41,\n  'forty two percent': 42,\n  'forty three percent': 43,\n  'forty four percent': 44,\n  'forty five percent': 45,\n  'forty six percent': 46,\n  'forty seven percent': 47,\n  'forty eight percent': 48,\n  'forty nine percent': 49,\n\n  // Handle misspelling of forty\n  'fourty percent': 40,\n  'fourty one percent': 41,\n  'fourty two percent': 42,\n  'fourty three percent': 43,\n  'fourty four percent': 44,\n  'fourty five percent': 45,\n  'fourty six percent': 46,\n  'fourty seven percent': 47,\n  'fourty eight percent': 48,\n  'fourty nine percent': 49,\n\n  'fifty percent': 50,\n  'fifty one percent': 51,\n  'fifty two percent': 52,\n  'fifty three percent': 53,\n  'fifty four percent': 54,\n  'fifty five percent': 55,\n  'fifty six percent': 56,\n  'fifty seven percent': 57,\n  'fifty eight percent': 58,\n  'fifty nine percent': 59,\n\n  'sixty percent': 60,\n  'sixty one percent': 61,\n  'sixty two percent': 62,\n  'sixty three percent': 63,\n  'sixty four percent': 64,\n  'sixty five percent': 65,\n  'sixty six percent': 66,\n  'sixty seven percent': 67,\n  'sixty eight percent': 68,\n  'sixty nine percent': 69,\n\n  'seventy percent': 70,\n  'seventy one percent': 71,\n  'seventy two percent': 72,\n  'seventy three percent': 73,\n  'seventy four percent': 74,\n  'seventy five percent': 75,\n  'seventy six percent': 76,\n  'seventy seven percent': 77,\n  'seventy eight percent': 78,\n  'seventy nine percent': 79,\n\n  'eighty percent': 80,\n  'eighty one percent': 81,\n  'eighty two percent': 82,\n  'eighty three percent': 83,\n  'eighty four percent': 84,\n  'eighty five percent': 85,\n  'eighty six percent': 86,\n  'eighty seven percent': 87,\n  'eighty eight percent': 88,\n  'eighty nine percent': 89,\n\n  'ninety percent': 90,\n  'ninety one percent': 91,\n  'ninety two percent': 92,\n  'ninety three percent': 93,\n  'ninety four percent': 94,\n  'ninety five percent': 95,\n  'ninety six percent': 96,\n  'ninety seven percent': 97,\n  'ninety eight percent': 98,\n  'ninety nine percent': 99,\n\n  'one hundred percent': 100,\n};\n\nfor (let i = 0; i <= 100; i++) {\n  percentages[`${i}%`] = i;\n}\n\n/**\n * Find a property of a thing by its expected @type.\n *\n * @param {Object} thing Thing to search\n * @param {String} type Expected @type value\n * @param {String?} fallbackName Fallback name for legacy devices\n * @returns {String} property name\n */\nfunction findProperty(thing, propType, fallbackName) {\n  for (const prop in thing.properties) {\n    if (thing.properties[prop]['@type'] === propType) {\n      return prop;\n    }\n  }\n\n  if (thing.properties.hasOwnProperty(fallbackName)) {\n    return fallbackName;\n  }\n\n  return null;\n}\n\nmodule.exports = {\n  colors,\n  percentages,\n  findProperty,\n};\n","/*\n * Things Gateway Constants.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst path = require('path');\n\n// Web server routes\nexports.USERS_PATH = '/users';\nexports.THINGS_PATH = '/things';\nexports.PROPERTIES_PATH = '/properties';\nexports.NEW_THINGS_PATH = '/new_things';\nexports.ADAPTERS_PATH = '/adapters';\nexports.ADDONS_PATH = '/addons';\nexports.ACTIONS_PATH = '/actions';\nexports.EVENTS_PATH = '/events';\nexports.LOGIN_PATH = '/login';\nexports.LOG_OUT_PATH = '/log-out';\nexports.SETTINGS_PATH = '/settings';\nexports.COMMANDS_PATH = '/commands';\nexports.UPDATES_PATH = '/updates';\nexports.UPLOADS_PATH = '/uploads';\nexports.DEBUG_PATH = '/debug';\nexports.RULES_PATH = '/rules';\nexports.OAUTH_PATH = '/oauth';\nexports.OAUTHCLIENTS_PATH = '/authorizations';\nexports.LOGS_PATH = '/logs';\nexports.PUSH_PATH = '/push';\nexports.PING_PATH = '/ping';\n// Remember we end up in the build/* directory so these paths looks slightly\n// different than you might expect.\nexports.STATIC_PATH = path.join(__dirname, '../static');\nexports.BUILD_STATIC_PATH = path.join(__dirname, '../build/static');\nexports.VIEWS_PATH = path.join(__dirname, '../build/views');\n\n// Plugin and REST/websocket API things\nexports.DONT_RESTART_EXIT_CODE = 100;\nexports.UNLOAD_PLUGIN_KILL_DELAY = 3000;\nexports.ACTION_STATUS = 'actionStatus';\nexports.ADAPTER_ADDED = 'adapterAdded';\nexports.ADAPTER_UNLOADED = 'adapterUnloaded';\nexports.ADD_ADAPTER = 'addAdapter';\nexports.ADD_EVENT_SUBSCRIPTION = 'addEventSubscription';\nexports.ADD_MOCK_DEVICE = 'addMockDevice';\nexports.CANCEL_PAIRING = 'cancelPairing';\nexports.CANCEL_REMOVE_THING = 'cancelRemoveThing';\nexports.CLEAR_MOCK_ADAPTER_STATE = 'clearMockAdapterState';\nexports.CONNECTED = 'connected';\nexports.DEBUG_CMD = 'debugCmd';\nexports.EVENT = 'event';\nexports.ERROR = 'error';\nexports.HANDLE_DEVICE_ADDED = 'handleDeviceAdded';\nexports.HANDLE_DEVICE_REMOVED = 'handleDeviceRemoved';\nexports.MOCK_ADAPTER_STATE_CLEARED = 'mockAdapterStateCleared';\nexports.MOCK_DEVICE_ADDED_REMOVED = 'mockDeviceAddedRemoved';\nexports.MOCK_DEVICE_ADD_REMOVE_FAILED = 'mockDeviceAddRemoveFailed';\nexports.PAIRING_TIMEOUT = 'pairingTimeout';\nexports.PAIR_MOCK_DEVICE = 'pairMockDevice';\nexports.PLUGIN_ERROR = 'pluginError';\nexports.PLUGIN_UNLOADED = 'pluginUnloaded';\nexports.PROPERTY_CHANGED = 'propertyChanged';\nexports.PROPERTY_STATUS = 'propertyStatus';\nexports.REGISTER_PLUGIN = 'registerPlugin';\nexports.REGISTER_PLUGIN_REPLY = 'registerPluginReply';\nexports.REMOVE_ACTION = 'removeAction';\nexports.REMOVE_ACTION_REJECTED = 'removeActionRejected';\nexports.REMOVE_ACTION_RESOLVED = 'removeActionResolved';\nexports.REMOVE_THING = 'removeThing';\nexports.REQUEST_ACTION = 'requestAction';\nexports.REQUEST_ACTION_REJECTED = 'requestActionRejected';\nexports.REQUEST_ACTION_RESOLVED = 'requestActionResolved';\nexports.SET_PIN = 'setPin';\nexports.SET_PIN_REJECTED = 'setPinRejected';\nexports.SET_PIN_RESOLVED = 'setPinResolved';\nexports.SET_PROPERTY = 'setProperty';\nexports.START_PAIRING = 'startPairing';\nexports.THING_ADDED = 'thingAdded';\nexports.THING_REMOVED = 'thingRemoved';\nexports.UNLOAD_ADAPTER = 'unloadAdapter';\nexports.UNLOAD_PLUGIN = 'unloadPlugin';\nexports.UNPAIR_MOCK_DEVICE = 'unpairMockDevice';\n\n// Thing types\nexports.THING_TYPE_ON_OFF_SWITCH = 'onOffSwitch';\nexports.THING_TYPE_MULTI_LEVEL_SWITCH = 'multiLevelSwitch';\nexports.THING_TYPE_BINARY_SENSOR = 'binarySensor';\nexports.THING_TYPE_MULTI_LEVEL_SENSOR = 'multiLevelSensor';\nexports.THING_TYPE_SMART_PLUG = 'smartPlug';\nexports.THING_TYPE_ON_OFF_LIGHT = 'onOffLight';\nexports.THING_TYPE_DIMMABLE_LIGHT = 'dimmableLight';\nexports.THING_TYPE_ON_OFF_COLOR_LIGHT = 'onOffColorLight';\nexports.THING_TYPE_DIMMABLE_COLOR_LIGHT = 'dimmableColorLight';\n\n// OAuth things\nexports.ACCESS_TOKEN = 'access_token';\nexports.AUTHORIZATION_CODE = 'authorization_code';\nexports.USER_TOKEN = 'user_token';\nexports.READWRITE = 'readwrite';\nexports.READ = 'read';\n\n// Logging\nexports.LogSeverity = {\n  DEBUG: 0,\n  INFO: 1,\n  WARNING: 2,\n  ERROR: 3,\n};\n","/**\n * Actions Controller.\n *\n * Manages the top level actions queue for the gateway and things.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nconst PromiseRouter = require('express-promise-router');\nconst Action = require('../models/action');\nconst Actions = require('../models/actions');\nconst AddonManager = require('../addon-manager');\nconst Things = require('../models/things');\n\nconst ActionsController = PromiseRouter({mergeParams: true});\n\n/**\n * Handle creating a new action.\n */\nActionsController.post('/', async (request, response) => {\n  const keys = Object.keys(request.body);\n  if (keys.length != 1) {\n    const err = 'Incorrect number of parameters.';\n    console.log(err, request.body);\n    response.status(400).send(err);\n    return;\n  }\n\n  const actionName = keys[0];\n  const actionParams = request.body[actionName].input;\n  const thingId = request.params.thingId;\n  let action = null;\n\n  if (thingId) {\n    try {\n      const thing = await Things.getThing(thingId);\n      action = new Action(actionName, actionParams, thing);\n    } catch (e) {\n      console.error('Thing does not exist', thingId, e);\n      response.status(404).send(e);\n      return;\n    }\n  } else {\n    action = new Action(actionName, actionParams);\n  }\n\n  try {\n    if (thingId) {\n      await AddonManager.requestAction(\n        thingId, action.id, actionName, actionParams);\n    }\n    await Actions.add(action);\n\n    response.status(201).json({[actionName]: action.getDescription()});\n  } catch (e) {\n    console.error('Creating action', actionName, 'failed');\n    console.error(e);\n    response.status(400).send(e);\n  }\n});\n\n/**\n * Handle getting a list of actions.\n */\nActionsController.get('/', function(request, response) {\n  if (request.params.thingId) {\n    response.status(200).json(Actions.getByThing(request.params.thingId));\n  } else {\n    response.status(200).json(Actions.getGatewayActions());\n  }\n});\n\n/**\n * Handle getting a list of actions.\n */\nActionsController.get('/:actionName', function(request, response) {\n  const actionName = request.params.actionName;\n  if (request.params.thingId) {\n    response.status(200).json(Actions.getByThing(request.params.thingId,\n                                                 actionName));\n  } else {\n    response.status(200).json(Actions.getGatewayActions(actionName));\n  }\n});\n\n/**\n * Handle creating a new action.\n */\nActionsController.post('/:actionName', async (request, response) => {\n  const actionName = request.params.actionName;\n\n  const keys = Object.keys(request.body);\n  if (keys.length != 1) {\n    const err = 'Incorrect number of parameters.';\n    console.log(err, request.body);\n    response.status(400).send(err);\n    return;\n  }\n\n  if (actionName !== keys[0]) {\n    const err = `Action name must be ${actionName}`;\n    console.log(err, request.body);\n    response.status(400).send(err);\n    return;\n  }\n\n  const actionParams = request.body[actionName].input;\n  const thingId = request.params.thingId;\n  let action = null;\n\n  if (thingId) {\n    try {\n      const thing = await Things.getThing(thingId);\n      action = new Action(actionName, actionParams, thing);\n    } catch (e) {\n      console.error('Thing does not exist', thingId, e);\n      response.status(404).send(e);\n      return;\n    }\n  } else {\n    action = new Action(actionName, actionParams);\n  }\n\n  try {\n    if (thingId) {\n      await AddonManager.requestAction(\n        thingId, action.id, actionName, actionParams);\n    }\n    await Actions.add(action);\n\n    response.status(201).json({[actionName]: action.getDescription()});\n  } catch (e) {\n    console.error('Creating action', actionName, 'failed');\n    console.error(e);\n    response.status(400).send(e);\n  }\n});\n\n/**\n * Handle getting a particular action.\n */\nActionsController.get('/:actionName/:actionId', function(request, response) {\n  const actionId = request.params.actionId;\n  const action = Actions.get(actionId);\n  if (action) {\n    response.status(200).json({[action.name]: action.getDescription()});\n  } else {\n    const error = `Action \"${actionId}\" not found`;\n    console.error(error);\n    response.status(404).send(error);\n  }\n});\n\n/**\n * Handle cancelling an action.\n */\nActionsController.delete(\n  '/:actionName/:actionId',\n  async (request, response) => {\n    const actionName = request.params.actionName;\n    const actionId = request.params.actionId;\n    const thingId = request.params.thingId;\n\n    if (thingId) {\n      try {\n        await AddonManager.removeAction(thingId, actionId, actionName);\n      } catch (e) {\n        console.error('Removing action', actionId, 'failed');\n        console.error(e);\n        response.status(400).send(e);\n        return;\n      }\n    }\n\n    try {\n      Actions.remove(actionId);\n    } catch (e) {\n      console.error('Removing action', actionId, 'failed');\n      console.error(e);\n      response.status(404).send(e);\n      return;\n    }\n\n    response.status(204).end();\n  });\n\nmodule.exports = ActionsController;\n","/**\n * Adapter Controller.\n *\n * Manages HTTP requests to /adapters.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst express = require('express');\nconst addonManager = require('../addon-manager');\n\nconst adaptersController = express.Router();\n\n/**\n * Return a list of adapters\n */\nadaptersController.get('/', (request, response) => {\n  const adapters = addonManager.getAdapters();\n  const adapterList = Array.from(adapters.values()).map((adapter) => {\n    return adapter.asDict();\n  });\n  response.json(adapterList);\n});\n\n/**\n * Get a particular adapter.\n */\nadaptersController.get('/:adapterId/', (request, response) => {\n  const adapterId = request.params.adapterId;\n  const adapter = addonManager.getAdapter(adapterId);\n  if (adapter) {\n    response.json(adapter.asDict());\n  } else {\n    response.status(404).send(`Adapter \"${adapterId}\" not found.`);\n  }\n});\n\nmodule.exports = adaptersController;\n","const PromiseRouter = require('express-promise-router');\nconst AddonManager = require('../addon-manager');\nconst Settings = require('../models/settings');\n\nconst AddonsController = PromiseRouter();\n\nAddonsController.get('/', async (request, response) => {\n  Settings.getAddonSettings().then(function(result) {\n    if (typeof result === 'undefined') {\n      response.status(404).json([]);\n    } else {\n      const installedAddons = [];\n      for (const setting of result) {\n        // Remove the leading 'addons.' from the settings key to get the\n        // package name.\n        const packageName = setting.key.substr(setting.key.indexOf('.') + 1);\n        if (packageName.length <= 0) {\n          continue;\n        }\n\n        if (AddonManager.isAddonInstalled(packageName)) {\n          installedAddons.push(setting);\n        }\n      }\n\n      response.status(200).json(installedAddons);\n    }\n  }).catch(function(e) {\n    console.error('Failed to get add-on settings.');\n    console.error(e);\n    response.status(400).send(e);\n  });\n});\n\nAddonsController.put('/:addonName', async (request, response) => {\n  const addonName = request.params.addonName;\n\n  if (!request.body || !request.body.hasOwnProperty('enabled')) {\n    response.status(400).send('Enabled property not defined');\n    return;\n  }\n\n  const enabled = request.body.enabled;\n\n  const key = `addons.${addonName}`;\n\n  let current;\n  try {\n    current = await Settings.get(key);\n    if (typeof current === 'undefined') {\n      throw new Error('Setting is undefined.');\n    }\n  } catch (e) {\n    console.error(`Failed to get current settings for add-on ${addonName}`);\n    console.error(e);\n    response.status(400).send(e);\n    return;\n  }\n\n  current.moziot.enabled = enabled;\n  try {\n    await Settings.set(key, current);\n  } catch (e) {\n    console.error(`Failed to set settings for add-on ${addonName}`);\n    console.error(e);\n    response.status(400).send(e);\n    return;\n  }\n\n  try {\n    if (enabled) {\n      await AddonManager.loadAddon(addonName);\n    } else {\n      await AddonManager.unloadAddon(addonName);\n    }\n\n    response.status(200).json({enabled: enabled});\n  } catch (e) {\n    console.error(`Failed to toggle add-on ${addonName}`);\n    console.error(e);\n    response.status(400).send(e);\n  }\n});\n\nAddonsController.put('/:addonName/config', async (request, response) => {\n  const addonName = request.params.addonName;\n\n  if (!request.body || !request.body.hasOwnProperty('config')) {\n    response.status(400).send('Config property not defined');\n    return;\n  }\n\n  const config = request.body.config;\n\n  const key = `addons.${addonName}`;\n\n  let current;\n  try {\n    current = await Settings.get(key);\n    if (typeof current === 'undefined') {\n      throw new Error('Setting is undefined.');\n    }\n  } catch (e) {\n    console.error(`Failed to get current settings for add-on ${addonName}`);\n    console.error(e);\n    response.status(400).send(e);\n    return;\n  }\n\n  current.moziot.config = config;\n  try {\n    await Settings.set(key, current);\n  } catch (e) {\n    console.error(`Failed to set settings for add-on ${addonName}`);\n    console.error(e);\n    response.status(400).send(e);\n    return;\n  }\n\n  try {\n    await AddonManager.unloadAddon(addonName, true);\n    await AddonManager.loadAddon(addonName);\n\n    response.status(200).json({config});\n  } catch (e) {\n    console.error(`Failed to apply config add-on ${addonName}`);\n    console.error(e);\n    response.status(400).send(e);\n  }\n});\n\nAddonsController.post('/', async (request, response) => {\n  if (!request.body ||\n      !request.body.hasOwnProperty('name') ||\n      !request.body.hasOwnProperty('url') ||\n      !request.body.hasOwnProperty('checksum')) {\n    response.status(400).send('Missing required parameter(s).');\n    return;\n  }\n\n  const name = request.body.name;\n  const url = request.body.url;\n  const checksum = request.body.checksum;\n\n  try {\n    await AddonManager.installAddonFromUrl(name, url, checksum, true);\n    const key = `addons.${name}`;\n    const savedSettings = await Settings.get(key);\n    response.status(200).json(savedSettings);\n  } catch (e) {\n    response.status(400).send(e);\n  }\n});\n\nAddonsController.patch('/:addonName', async (request, response) => {\n  const name = request.params.addonName;\n\n  if (!request.body ||\n      !request.body.hasOwnProperty('url') ||\n      !request.body.hasOwnProperty('checksum')) {\n    response.status(400).send('Missing required parameter(s).');\n    return;\n  }\n\n  const url = request.body.url;\n  const checksum = request.body.checksum;\n\n  try {\n    await AddonManager.uninstallAddon(name, true, false);\n    await AddonManager.installAddonFromUrl(name, url, checksum, true);\n    response.sendStatus(200);\n  } catch (e) {\n    console.error(`Failed to update add-on: ${name}\\n${e}`);\n    response.status(400).send(e);\n  }\n});\n\nAddonsController.delete('/:addonName', async (request, response) => {\n  const addonName = request.params.addonName;\n\n  try {\n    await AddonManager.uninstallAddon(addonName, false, true);\n    response.sendStatus(200);\n  } catch (e) {\n    console.error(`Failed to uninstall add-on: ${addonName}\\n${e}`);\n    response.status(400).send(e);\n  }\n});\n\nmodule.exports = AddonsController;\n","/**\n * Commands Controller.\n *\n * Manages HTTP requests to /commands.\n *\n * Grammar that the parser understands:\n *  Turn the <tag> light <on|off>\n *  Turn <tag> <on|off>\n *  Shut <tag> <on|off>\n *  Shut the <tag> light <on|off>\n *\n * <tag> must match the .name property of one of the /things objects\n *  in order for the command to be executed.\n *\n * Sample curl command to test from the command line:\n * curl -H 'Authorization:Bearer '<JSONWebToken>'\n *        -H \"Content-Type: application/json\"\n *        -H \"Accept: application/json\"\n *        -d '{\"text\":\"turn the kitchen light on\"}'\n *        https://localhost:4443/commands\n *        -k\n *\n * HTTP Response Codes        Status message\n *              201           Command Created\n *              400           Text element not defined\n *              404           Thing Not Found\n *              406           Unable to understand command\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst PromiseRouter = require('express-promise-router');\nconst AddonManager = require('../addon-manager');\nconst CommandUtils = require('../command-utils');\nconst IntentParser = require('../models/intentparser');\nconst Things = require('../models/things');\n\nconst CommandsController = PromiseRouter();\n\n/**\n * Parses the intent for a text sentence and sends to the intent parser to\n * determine intent. Then executes the intent as an action on the thing API.\n */\nCommandsController.post('/', async (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('text')) {\n    response.status(400).json({\n      message: 'Text element not defined',\n    });\n    return;\n  }\n\n  let names = await Things.getThingNames();\n  names = names.map((n) => n.toLowerCase());\n\n  const internalError = () => {\n    response.status(400).json({\n      message: 'Sorry, something went wrong.',\n    });\n  };\n\n  const thingNotFound = () => {\n    response.status(400).json({\n      message: 'Sorry, that thing wasn\\'t found.',\n    });\n  };\n\n  const invalidForDevice = () => {\n    response.status(400).json({\n      message: 'Sorry, I\\'m afraid I can\\'t do that.',\n    });\n  };\n\n  const invalidCommand = () => {\n    response.status(400).json({\n      message: 'Sorry, I didn\\'t understand that.',\n    });\n  };\n\n  const failedToSet = () => {\n    response.status(400).json({\n      message: 'Sorry, that didn\\'t work.',\n    });\n  };\n\n  try {\n    await IntentParser.train(names);\n  } catch (e) {\n    console.log('Error training:', e);\n    internalError();\n    return;\n  }\n\n  let payload;\n  try {\n    payload = await IntentParser.query(request.body.text);\n  } catch (e) {\n    console.log('Error parsing intent:', e);\n    invalidCommand();\n    return;\n  }\n\n  const name = payload.thing;\n  const thing = await Things.getThingByName(name);\n\n  if (!thing) {\n    thingNotFound();\n    return;\n  }\n\n  let propertyName, value;\n\n  const properties = {\n    on: CommandUtils.findProperty(thing, 'OnOffProperty', 'on'),\n    color: CommandUtils.findProperty(thing, 'ColorProperty', 'color'),\n    colorTemperature: CommandUtils.findProperty(thing,\n                                                'ColorTemperatureProperty',\n                                                'colorTemperature'),\n    level: CommandUtils.findProperty(thing, 'LevelProperty', 'level'),\n    brightness: CommandUtils.findProperty(thing,\n                                          'BrightnessProperty',\n                                          'level'),\n  };\n\n  if (['on', 'off'].includes(payload.value)) {\n    if (!properties.on) {\n      invalidForDevice();\n      return;\n    }\n\n    propertyName = properties.on;\n    value = payload.value === 'on';\n  } else if (['warmer', 'cooler'].includes(payload.value)) {\n    if (!properties.colorTemperature) {\n      invalidForDevice();\n      return;\n    }\n\n    propertyName = properties.colorTemperature;\n\n    let current;\n    try {\n      current = await AddonManager.getProperty(thing.id, propertyName);\n    } catch (e) {\n      failedToSet();\n      return;\n    }\n\n    value = payload.value === 'warmer' ? current - 100 : current + 100;\n  } else if (['dim', 'brighten'].includes(payload.keyword) ||\n             CommandUtils.percentages.hasOwnProperty(payload.value)) {\n    if (!properties.brightness) {\n      invalidForDevice();\n      return;\n    }\n\n    propertyName = properties.brightness;\n\n    const percent =\n      payload.value ? CommandUtils.percentages[payload.value] : 10;\n\n    if (payload.keyword === 'set') {\n      value = percent;\n    } else if (payload.keyword === 'dim' || payload.keyword === 'brighten') {\n      let current;\n      try {\n        current = await AddonManager.getProperty(thing.id, propertyName);\n      } catch (e) {\n        failedToSet();\n        return;\n      }\n\n      if (payload.keyword === 'dim') {\n        value = current - percent;\n      } else {\n        value = current + percent;\n      }\n    }\n  } else if (CommandUtils.colors.hasOwnProperty(payload.value)) {\n    if (!properties.color) {\n      invalidForDevice();\n      return;\n    }\n\n    propertyName = properties.color;\n    value = CommandUtils.colors[payload.value];\n  } else {\n    invalidCommand();\n    return;\n  }\n\n  try {\n    await AddonManager.setProperty(thing.id, propertyName, value);\n  } catch (e) {\n    failedToSet();\n    return;\n  }\n\n  // Returning 201 to signify that the command was mapped to an\n  // intent and matched a 'thing' in our list. Return a response to\n  // caller with this status before the command finishes execution\n  // as the execution can take some time (e.g. blinds)\n  response.status(201).json({\n    message: 'Command Created',\n    payload: payload,\n  });\n});\n\nmodule.exports = CommandsController;\n","/**\n * Debug Controller.\n *\n * Manages HTTP requests to /debug/adapters.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Constants = require('../constants');\nconst express = require('express');\nconst addonManager = require('../addon-manager');\n\nconst debugController = express.Router();\n\naddonManager.on(Constants.ADAPTER_ADDED, (adapter) => {\n  console.log('debug: Got:', Constants.ADAPTER_ADDED,\n              'notification for', adapter.id, adapter.name);\n});\n\naddonManager.on(Constants.THING_ADDED, (thing) => {\n  console.log('debug: Got:', Constants.THING_ADDED,\n              'notification for', thing.name);\n});\n\naddonManager.on(Constants.THING_REMOVED, (thing) => {\n  console.log('debug: Got:', Constants.THING_REMOVED,\n              'notification for', thing.name);\n});\n\naddonManager.on(Constants.PROPERTY_CHANGED, (property) => {\n  console.log('debug: Got:', Constants.PROPERTY_CHANGED,\n              'notification for:', property.device.name,\n              'property:', property.name,\n              'value:', property.value);\n});\n\naddonManager.on(Constants.PAIRING_TIMEOUT, () => {\n  console.log('debug: Got:', Constants.PAIRING_TIMEOUT,\n              'notification');\n});\n\n/**\n * List all known adapters\n */\ndebugController.get('/adapters', (request, response) => {\n  const adapters = addonManager.getAdapters();\n  response.status(200).json(Array.from(adapters.values()).map((adapter) => {\n    return adapter.asDict();\n  }));\n});\n\n/**\n * Add a new device\n */\ndebugController.get('/addNewThing', (request, response) => {\n  addonManager.addNewThing(60).then((thing) => {\n    console.log('debugController: addNewThing added thing', thing);\n  }, () => {\n    console.log('debugController: addNewThing cancelled');\n  });\n  response.status(204).send();\n});\n\n/**\n * Cancel adding a new device\n */\ndebugController.get('/cancelAddNewThing', (request, response) => {\n  addonManager.cancelAddNewThing();\n  response.status(204).send();\n});\n\n/**\n * Cancel removing a device;\n */\ndebugController.get('/cancelRemoveThing/:thingId', (request, response) => {\n  const thingId = request.params.thingId;\n  addonManager.cancelRemoveThing(thingId);\n  response.status(204).send();\n});\n\n/**\n * Get a list of devices ids registered with the add-on manager.\n */\ndebugController.get('/deviceIds', (request, response) => {\n  const devices = addonManager.getDevices();\n  const deviceList = [];\n  for (const deviceId in devices) {\n    const device = addonManager.devices[deviceId];\n    deviceList.push(device.id);\n  }\n  response.status(200).json(deviceList);\n});\n\n/**\n * Get a list of the devices registered with the add-on manager.\n */\ndebugController.get('/devices', (request, response) => {\n  const devices = addonManager.getDevices();\n  const deviceList = [];\n  for (const deviceId in devices) {\n    const device = addonManager.devices[deviceId];\n    deviceList.push(device.asDict());\n  }\n  response.status(200).json(deviceList);\n});\n\n/**\n * Get a particular device registered with the add-on manager.\n */\ndebugController.get('/device/:deviceId', (request, response) => {\n  const deviceId = request.params.deviceId;\n  const device = addonManager.getDevice(deviceId);\n  if (device) {\n    response.status(200).json(device.asDict());\n  } else {\n    response.status(404).send(`Device \"${deviceId}\" not found.`);\n  }\n});\n\n/**\n * Gets an property from a device.\n */\ndebugController.get('/device/:deviceId/:propertyName', (request, response) => {\n  const deviceId = request.params.deviceId;\n  const propertyName = request.params.propertyName;\n  const device = addonManager.getDevice(deviceId);\n  if (device) {\n    device.getProperty(propertyName).then((value) => {\n      const valueDict = {};\n      valueDict[propertyName] = value;\n      response.status(200).json(valueDict);\n    }).catch((error) => {\n      console.log(`Device \"${deviceId}\"`);\n      console.log(error);\n      response.status(404).send(`Device \"${deviceId}${error}`);\n    });\n  } else {\n    response.status(404).send(`Device \"${deviceId}\" not found.`);\n  }\n});\n\n/**\n * Sends a debug command to a particular device.\n */\ndebugController.put('/device/:deviceId/cmd/:cmd', (request, response) => {\n  const deviceId = request.params.deviceId;\n  const device = addonManager.getDevice(deviceId);\n  if (device) {\n    device.debugCmd(request.params.cmd, request.body);\n    response.status(200).json(request.body);\n  } else {\n    response.status(404).send(`Device \"${deviceId}\" not found.`);\n  }\n});\n\n/**\n * Sets an property associated with a device.\n */\ndebugController.put('/device/:deviceId/:propertyName', (request, response) => {\n  const deviceId = request.params.deviceId;\n  const propertyName = request.params.propertyName;\n  const device = addonManager.getDevice(deviceId);\n  if (device) {\n    const propertyValue = request.body[propertyName];\n    if (typeof propertyValue !== 'undefined') {\n      device.setProperty(propertyName, propertyValue).then((updatedValue) => {\n        const valueDict = {};\n        valueDict[propertyName] = updatedValue;\n        response.status(200).json(valueDict);\n      }).catch((error) => {\n        console.log(`Device \"${deviceId}\"`);\n        console.log(error);\n        response.status(404).send(`Device \"${deviceId}\" ${error}`);\n      });\n    } else {\n      response.status(404).send(`Device \"${deviceId\n      }\" property \"${propertyName\n      }\" not found in request.`);\n    }\n  } else {\n    response.status(404).send(`Device \"${deviceId}\" not found.`);\n  }\n});\n\n/**\n * Get a list of plugins\n */\ndebugController.get('/plugins', (request, response) => {\n  const plugins = Array.from(addonManager.pluginServer.plugins.values());\n  response.status(200).json(plugins.map((plugin) => {\n    return plugin.asDict();\n  }));\n});\n\n/**\n * Get a list of the things registered with the add-on manager.\n */\ndebugController.get('/things', (request, response) => {\n  response.status(200).json(addonManager.getThings());\n});\n\n/**\n * Get a particular thing registered with the add-on manager.\n */\ndebugController.get('/thing/:thingId', (request, response) => {\n  const thingId = request.params.thingId;\n  const thing = addonManager.getThing(thingId);\n  if (thing) {\n    response.status(200).json(thing);\n  } else {\n    response.status(404).send(`Thing \"${thingId}\" not found.`);\n  }\n});\n\n/**\n * Gets a property associated with a thing.\n */\ndebugController.get('/thing/:thingId/:propertyName', (request, response) => {\n  const thingId = request.params.thingId;\n  const propertyName = request.params.propertyName;\n  const thing = addonManager.getThing(thingId);\n  if (thing) {\n    addonManager.getProperty(thing.id, propertyName).then((value) => {\n      const valueDict = {};\n      valueDict[propertyName] = value;\n      response.status(200).json(valueDict);\n    }).catch((error) => {\n      response.status(404).send(`Thing \"${thingId} ${error}`);\n    });\n  } else {\n    response.status(404).send(`Thing \"${thingId}\" not found.`);\n  }\n});\n\n/**\n * Sets a property associated with a thing.\n */\ndebugController.put('/thing/:thingId/:propertyName', (request, response) => {\n  const thingId = request.params.thingId;\n  const propertyName = request.params.propertyName;\n  const thing = addonManager.getThing(thingId);\n  if (thing) {\n    const propertyValue = request.body[propertyName];\n    if (typeof propertyValue !== 'undefined') {\n      addonManager.setProperty(propertyName, propertyValue).then((value) => {\n        const valueDict = {};\n        valueDict[propertyName] = value;\n        response.status(200).json(valueDict);\n      }).catch((error) => {\n        console.log(`Thing \"${thingId}`);\n        console.log(error);\n        response.status(404).send(`Thing \"${thingId} ${error}`);\n      });\n    } else {\n      response.status(404).send(`Thing \"${thingId\n      }\" property \"${propertyName\n      }\" not found in request.`);\n    }\n  } else {\n    response.status(404).send(`Thing \"${thingId}\" not found.`);\n  }\n});\n\n/**\n * Remove an existing Thing.\n */\ndebugController.get('/removeThing/:thingId', (request, response) => {\n  const thingId = request.params.thingId;\n  addonManager.removeThing(thingId).then((thingIdRemoved) => {\n    console.log('debugController: removed', thingIdRemoved);\n    if (thingId != thingIdRemoved) {\n      console.log('debugController: Actually removed', thingIdRemoved,\n                  'even though request was for:', thingId);\n    }\n    response.status(200).json({removed: thingIdRemoved});\n  }, (str) => {\n    console.log('debugController: remove failed:', str);\n    response.status(500).send(`remove of ${thingId} failed: ${str}`);\n  });\n});\n\n/**\n * Unload add-ons\n */\ndebugController.get('/unloadAddons', (request, response) => {\n  console.log('debugController: Unloading Add-ons');\n  addonManager.unloadAddons();\n  response.status(200).send('');\n});\n\nmodule.exports = debugController;\n","/**\n * Events Controller.\n *\n * Manages the top level events queue for the gateway and things.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nconst express = require('express');\nconst Events = require('../models/events');\n\nconst EventsController = express.Router({mergeParams: true});\n\n/**\n * Handle getting a list of events.\n */\nEventsController.get('/', function(request, response) {\n  if (request.params.thingId) {\n    response.status(200).json(Events.getByThing(request.params.thingId));\n  } else {\n    response.status(200).json(Events.getGatewayEvents());\n  }\n});\n\n/**\n * Handle getting a list of events.\n */\nEventsController.get('/:eventName', function(request, response) {\n  const eventName = request.params.eventName;\n\n  if (request.params.thingId) {\n    response.status(200).json(Events.getByThing(request.params.thingId,\n                                                eventName));\n  } else {\n    response.status(200).json(Events.getGatewayEvents(eventName));\n  }\n});\n\nmodule.exports = EventsController;\n","/**\n * LogOut Controller.\n *\n * Handles logging out the user.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Router = require('express-promise-router');\n\nconst JSONWebToken = require('../models/jsonwebtoken');\n\nconst LogOutController = new Router();\n\n/**\n * Log out the user\n */\nLogOutController.post('/', async (request, response) => {\n  const {jwt} = request;\n  await JSONWebToken.revokeToken(jwt.keyId);\n  response.sendStatus(200);\n});\n\nmodule.exports = LogOutController;\n","/**\n * Login Controller.\n *\n * Handles user login.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst path = require('path');\n\nconst Router = require('express-promise-router');\nconst Users = require('../models/users');\nconst JSONWebToken = require('../models/jsonwebtoken');\nconst Passwords = require('../passwords');\nconst Constants = require('../constants');\n\nconst LoginController = Router();\n\nconst loginRoot = path.join(Constants.BUILD_STATIC_PATH, 'login');\n\n/**\n * Serve the static login page\n */\nLoginController.get('/', async (request, response) => {\n  response.sendFile('index.html', {root: loginRoot});\n});\n\n/**\n * Handle login request.\n */\nLoginController.post('/', async (request, response) => {\n  const {body} = request;\n  if (!body || !body.email || !body.password) {\n    response.status(400).send('User requires email and password');\n    return;\n  }\n\n  const user = await Users.getUser(body.email.toLowerCase());\n  if (!user) {\n    response.sendStatus(401);\n    return;\n  }\n\n  const passwordMatch = await Passwords.compare(\n    body.password,\n    user.password\n  );\n\n  if (!passwordMatch) {\n    response.sendStatus(401);\n    return;\n  }\n\n  // Issue a new JWT for this user.\n  const jwt = await JSONWebToken.issueToken(user.id);\n\n  response.send({\n    jwt,\n  });\n});\n\nmodule.exports = LoginController;\n","/**\n * Logs Controller.\n *\n * Allows user to download current set of logs.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nconst AddonManager = require('../addon-manager');\nconst archiver = require('archiver');\nconst express = require('express');\nconst fs = require('fs');\nconst path = require('path');\nconst jwtMiddleware = require('../jwt-middleware');\nconst UserProfile = require('../user-profile');\nconst Utils = require('../utils');\nconst WebSocket = require('ws');\n\nconst LogsController = express.Router();\n\n/**\n * Generate an index of log files.\n */\nLogsController.get('/', async (request, response) => {\n  const jwt = jwtMiddleware.extractJWTHeader(request) ||\n    jwtMiddleware.extractJWTQS(request);\n  const files = fs.readdirSync(UserProfile.logDir)\n    .filter((f) => !f.startsWith('.'));\n  files.sort();\n\n  let content =\n    '<!DOCTYPE html>' +\n    '<html lang=\"en\">' +\n    '<head>' +\n    '<meta charset=\"utf-8\">' +\n    '<title>Things Gateway - Logs</title>' +\n    '</head>' +\n    '<body>' +\n    '<ul>';\n\n  for (const name of files) {\n    if (fs.lstatSync(path.join(UserProfile.logDir, name)).isFile()) {\n      content +=\n        `${'<li>' +\n        `<a href=\"/logs/files/${encodeURIComponent(name)}?jwt=${jwt}\">`}${\n          Utils.escapeHtml(name)\n        }</a>` +\n        `</li>`;\n    }\n  }\n\n  content +=\n    '</ul>' +\n    '</body>' +\n    '</html>';\n\n  response.send(content);\n});\n\n/**\n * Static handler for log files.\n */\nLogsController.use('/files', express.static(UserProfile.logDir));\n\n/**\n * Handle request for logs.zip.\n */\nLogsController.get('/zip', async (request, response) => {\n  const archive = archiver('zip');\n\n  archive.on('error', (err) => {\n    response.status(500).send(err.message);\n  });\n\n  response.attachment('logs.zip');\n\n  archive.pipe(response);\n  fs.readdirSync(\n    UserProfile.logDir\n  ).map((f) => {\n    const fullPath = path.join(UserProfile.logDir, f);\n    if (!f.startsWith('.') && fs.lstatSync(fullPath).isFile()) {\n      archive.file(fullPath, {name: path.join('logs', f)});\n    }\n  });\n  archive.finalize();\n});\n\nLogsController.ws('/', (websocket) => {\n  if (websocket.readyState !== WebSocket.OPEN) {\n    return;\n  }\n\n  const heartbeat = setInterval(() => {\n    try {\n      websocket.ping();\n    } catch (e) {\n      websocket.terminate();\n    }\n  }, 30 * 1000);\n\n  const onLog = (message) => {\n    websocket.send(JSON.stringify(message), (err) => {\n      if (err) {\n        console.error('WebSocket sendMessage failed:', err);\n      }\n    });\n  };\n\n  AddonManager.pluginServer.on('log', onLog);\n\n  const cleanup = () => {\n    AddonManager.pluginServer.removeListener('log', onLog);\n    clearInterval(heartbeat);\n  };\n\n  websocket.on('error', cleanup);\n  websocket.on('close', cleanup);\n});\n\nmodule.exports = LogsController;\n","/**\n * New Things Controller.\n *\n * /new_things returns a list of Things connected/paired with the gateway which\n * haven't yet been added to the gateway database.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst PromiseRouter = require('express-promise-router');\nconst fetch = require('node-fetch');\nconst WebSocket = require('ws');\nconst Things = require('../models/things');\n\nconst NewThingsController = PromiseRouter();\n\n/**\n * Handle GET requests to /new_things\n */\nNewThingsController.get('/', function(request, response) {\n  Things.getNewThings().then(function(newThings) {\n    response.json(newThings);\n  }).catch(function(error) {\n    console.error(`Error getting a list of new things from adapters ${error}`);\n    response.status(500).send(error);\n  });\n});\n\n/**\n * Handle a WebSocket request on /new_things\n */\nNewThingsController.ws('/', function(websocket) {\n  // Since the Gateway have the asynchronous express middlewares, there is a\n  // possibility that the WebSocket have been closed.\n  if (websocket.readyState !== WebSocket.OPEN) {\n    return;\n  }\n  console.log('Opened a new things socket');\n  // Register the WebSocket with the Things model so new devices can be pushed\n  // to the client as they are added.\n  Things.registerWebsocket(websocket);\n  // Send a list of things the adapter manager already knows about\n  Things.getNewThings().then(function(newThings) {\n    newThings.forEach(function(newThing) {\n      websocket.send(JSON.stringify(newThing));\n    }, this);\n  }).catch(function(error) {\n    console.error(`Error getting a list of new things from adapters ${error}`);\n  });\n});\n\n/**\n * Handle POST requests to /new_things\n */\nNewThingsController.post('/', async (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('url')) {\n    response.status(400).send('No URL in thing description');\n    return;\n  }\n\n  const url = request.body.url;\n  try {\n    const res = await fetch(url, {headers: {Accept: 'application/json'}});\n\n    if (!res.ok) {\n      response.status(400).send('Web thing not found');\n      return;\n    }\n\n    const description = await res.json();\n\n    // Verify some high level thing description properties.\n    if (description.hasOwnProperty('name') &&\n        (description.hasOwnProperty('type') ||\n         description.hasOwnProperty('@type')) &&\n        description.hasOwnProperty('properties')) {\n      response.json(description);\n    } else if (Array.isArray(description)) {\n      response.status(400).send('Web things must be added individually');\n    } else {\n      response.status(400).send('Invalid thing description');\n    }\n  } catch (e) {\n    response.status(400).send('Web thing not found');\n  }\n});\n\nmodule.exports = NewThingsController;\n","/**\n * OAuth Controller.\n *\n * Handles a simple OAuth2 flow with a hardcoded client\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport * as express from 'express';\nimport { URL } from 'url';\nimport * as assert from 'assert';\nconst JSONWebToken = require('../models/jsonwebtoken');\nimport * as Database from '../db';\nimport {\n  scopeValidSubset, Scope, ScopeAccess, ScopeRaw, ClientId, ClientRegistry\n} from '../oauth-types';\n\nimport OAuthClients from '../models/oauthclients';\nimport * as jwtMiddleware from '../jwt-middleware';\nimport * as Constants from '../constants';\n\nconst auth = jwtMiddleware.middleware();\n\nconst OAuthController = express.Router();\n\ntype InvalidRequest = 'invalid_request';\ntype UnauthorizedClient = 'unauthorized_client';\n\ntype OAuthRequest = {\n  client_id: ClientId,\n  redirect_uri: URL|undefined,\n  state?: string\n};\n\n// https://tools.ietf.org/html/rfc6749#section-4.1.1\ntype AuthorizationRequest = {\n  response_type: 'code', // no suppport or desire for implicit auth\n  client_id: ClientId,\n  redirect_uri: URL|undefined,\n  scope: ScopeRaw,\n  state?: string\n};\n\ntype AuthorizationCode = string;\ntype AuthorizationError =\n  'invalid_request' | 'unauthorized_client' | 'access_denied' |\n  'unsupported_response_type' | 'invalid_scope' | 'server_error' |\n  'temporarily_unavailable';\n\ntype AuthorizationSuccessResponse = {\n  code: AuthorizationCode,\n  state: string|undefined\n};\n\ntype ErrorResponse<T> = {\n  error: T,\n  error_description?: string,\n  error_uri?: URL,\n  state?: string\n};\n\ntype AuthorizationErrorResponse = ErrorResponse<AuthorizationError>;\n\ntype AuthorizationResponse =\n  AuthorizationSuccessResponse|AuthorizationErrorResponse;\n\n// https://tools.ietf.org/html/rfc6749#section-4.1.3\ntype AccessTokenRequest = {\n  grant_type: 'authorization_code',\n  code: AuthorizationCode,\n  redirect_uri: URL|undefined,\n  client_id: ClientId\n};\n\ntype Token = string; // JWT\n\ntype AccessTokenSuccessResponse = {\n  access_token: Token,\n  token_type: 'bearer',\n  expires_in?: number,\n  refresh_token?: Token,\n  scope: ScopeRaw\n};\n\ntype AccessTokenError =\n  'invalid_request' | 'invalid_client' | 'invalid_grant' |\n  'unauthorized_client' | 'unsupported_grant_type' | 'invalid_scope';\n\ntype AccessTokenErrorResponse = ErrorResponse<AccessTokenError>;\ntype AccessTokenResponse = AccessTokenSuccessResponse|AccessTokenErrorResponse;\n\ntype RefreshTokenRequest = {\n  grant_type: 'refresh_token',\n  refresh_token: Token,\n  scope: ScopeRaw\n};\n\ntype RefreshTokenResponse = AccessTokenResponse;\n\nfunction redirect(response: express.Response, baseURL: URL, params: {[key: string]: any}) {\n  let url = new URL(baseURL.toString());\n  for (let key in params) {\n    if (!params.hasOwnProperty(key)) {\n      continue;\n    }\n    if (typeof params[key] !== 'undefined') {\n      url.searchParams.set(key, params[key].toString());\n    }\n  }\n  if (url.hostname === 'gateway.localhost') {\n    response.redirect(url.toString().replace(/^https:\\/\\/gateway\\.localhost/, ''));\n    return;\n  }\n  response.redirect(url.toString());\n}\n\nfunction verifyClient(request: OAuthRequest, response: express.Response):\n  ClientRegistry|null {\n  let client = OAuthClients.get(request.client_id, request.redirect_uri);\n  if (!client) {\n    let err: ErrorResponse<UnauthorizedClient> = {\n      error: 'unauthorized_client',\n      error_description: 'client id unknown',\n      state: request.state\n    };\n\n    response.status(400).json(err);\n    return null;\n  }\n\n  if (!request.redirect_uri) {\n    request.redirect_uri = client.redirect_uri;\n  }\n\n  if (request.redirect_uri!.toString() !== client.redirect_uri.toString()) {\n    let err: ErrorResponse<InvalidRequest> = {\n      error: 'invalid_request',\n      error_description: 'mismatched redirect_uri',\n      state: request.state\n    };\n\n    response.status(400).json(err);\n    return null;\n  }\n\n  return client;\n}\n\nfunction verifyClientAuthorization(client: ClientRegistry,\n  request: express.Request, response: express.Response): boolean {\n  let authorization = request.headers.authorization;\n  if (typeof authorization !== 'string' || !authorization.startsWith('Basic ')) {\n    let err: ErrorResponse<UnauthorizedClient> = {\n      error: 'unauthorized_client',\n      error_description: 'authorization header missing or malformed',\n    };\n\n    response.status(400).json(err);\n    return false;\n  }\n\n  let userPassB64 = authorization.substring('Basic '.length);\n  let userPass = Buffer.from(userPassB64, 'base64').toString();\n\n  let parts = userPass.split(':');\n  if (parts.length !== 2) {\n    let err: ErrorResponse<UnauthorizedClient> = {\n      error: 'unauthorized_client',\n      error_description: 'authorization header missing or malformed',\n    };\n\n    response.status(400).json(err);\n    return false;\n  }\n\n  let clientId = decodeURIComponent(parts[0].replace(/\\+/g, '%20'));\n  let clientSecret = decodeURIComponent(parts[1].replace(/\\+/g, '%20'));\n\n  if (client.id !== clientId || client.secret !== clientSecret) {\n    let err: ErrorResponse<UnauthorizedClient> = {\n      error: 'unauthorized_client',\n      error_description: 'authorization header mismatch',\n    };\n\n    response.status(400).json(err);\n    return false;\n  }\n\n  return true;\n}\n\nfunction verifyAuthorizationRequest(authRequest: AuthorizationRequest,\n                                    response: express.Response):\n                                      ClientRegistry|undefined {\n  let client = verifyClient(authRequest, response);\n  if (!client) {\n    return;\n  }\n\n  if (authRequest.response_type !== 'code') {\n    let err: AuthorizationErrorResponse = {\n      error: 'unsupported_response_type',\n      state: authRequest.state\n    };\n    redirect(\n      response,\n      client.redirect_uri,\n      err\n    );\n    return;\n  }\n\n  if (!scopeValidSubset(client.scope, authRequest.scope)) {\n    let err: AuthorizationErrorResponse = {\n      error: 'invalid_scope',\n      error_description: 'client scope does not cover requested scope',\n      state: authRequest.state\n    };\n    redirect(\n      response,\n      client.redirect_uri,\n      err\n    );\n    return;\n  }\n\n  return client;\n}\n\nOAuthController.get('/authorize', async (request: express.Request, response: express.Response) => {\n  // From query component construct\n  let authRequest: AuthorizationRequest = {\n    response_type: request.query.response_type,\n    client_id: request.query.client_id,\n    redirect_uri: request.query.redirect_uri && new URL(request.query.redirect_uri),\n    scope: request.query.scope,\n    state: request.query.state\n  };\n\n  let client = verifyAuthorizationRequest(authRequest, response);\n  if (!client) {\n    return;\n  }\n\n  response.render('authorize', {\n    name: client.name,\n    domain: client.redirect_uri.host,\n    request: authRequest\n  });\n});\n\nOAuthController.get('/local-token-service', async (request: express.Request, response: express.Response) => {\n  let localClient: ClientRegistry = OAuthClients.get('local-token', undefined)!;\n  let tokenRequest: AccessTokenRequest = {\n    grant_type: 'authorization_code',\n    code: request.query.code,\n    redirect_uri: localClient.redirect_uri,\n    client_id: localClient.id\n  };\n  request.body = tokenRequest;\n  request.headers.authorization = 'Basic ' +\n    new Buffer(localClient.id + ':' + localClient.secret).toString('base64');\n  let token = await handleAccessTokenRequest(request, response);\n  if (token) {\n    response.render('local-token-service', {\n      token: token.access_token\n    });\n  }\n});\n\nOAuthController.get('/allow', auth, async (request: express.Request, response: express.Response) => {\n  let authRequest: AuthorizationRequest = {\n    response_type: request.query.response_type,\n    client_id: request.query.client_id,\n    redirect_uri: request.query.redirect_uri && new URL(request.query.redirect_uri),\n    scope: request.query.scope,\n    state: request.query.state\n  };\n\n  let client = verifyAuthorizationRequest(authRequest, response);\n  if (!client) {\n    return;\n  }\n\n  let jwt = (request as any).jwt;\n  if (!jwt) {\n    return;\n  }\n\n  if (!jwt.payload || jwt.payload.role !== 'user_token') {\n    response.status(401).send('Authorization must come from user');\n    return;\n  }\n\n  // TODO: should expire in 10 minutes\n  let code = await JSONWebToken.issueOAuthToken(client, jwt.user, {\n    role: 'authorization_code',\n    scope: authRequest.scope\n  });\n\n  let success: AuthorizationSuccessResponse = {\n    code: code,\n    state: authRequest.state\n  };\n\n  redirect(\n    response,\n    client.redirect_uri,\n    success\n  );\n});\n\nOAuthController.post('/token', async (request: express.Request, response: express.Response) => {\n  const requestData = request.body;\n  if (requestData.grant_type === 'authorization_code') {\n    let token = await handleAccessTokenRequest(request, response);\n    if (token) {\n      response.json(token);\n    }\n    return;\n  }\n  // if (requestData.grant_type === 'refresh_token') {\n  //   handleRefreshTokenRequest(request, response);\n  // }\n  let err: AccessTokenErrorResponse = {\n    error: 'unsupported_grant_type',\n    state: requestData.state\n  };\n  response.status(400).json(err);\n});\n\n/**\n * Handles the request for an access token using an authorization code.\n * On error sends a 400 with a JSON reason.\n */\nasync function handleAccessTokenRequest(request: express.Request, response: express.Response):\n    Promise<AccessTokenSuccessResponse|undefined> {\n  const requestData = request.body;\n  let tokenRequest: AccessTokenRequest = {\n    grant_type: requestData.grant_type,\n    code: requestData.code,\n    redirect_uri: requestData.redirect_uri && new URL(requestData.redirect_uri),\n    client_id: requestData.client_id\n  };\n\n  let client = verifyClient(tokenRequest, response);\n  if (!client) {\n    return;\n  }\n\n  if (!verifyClientAuthorization(client, request, response)) {\n    return;\n  }\n  let tokenData = await JSONWebToken.verifyJWT(tokenRequest.code);\n  if (!tokenData) {\n    let err: AccessTokenErrorResponse = {\n      error: 'invalid_grant',\n      error_description: 'included JWT is invalid',\n      state: request.body.state\n    };\n\n    response.status(400).json(err);\n    return;\n  }\n\n  let payload = tokenData.payload;\n  if (!payload || payload.role !== 'authorization_code' || payload.client_id !== client.id) {\n    let err: AccessTokenErrorResponse = {\n      error: 'invalid_grant',\n      state: request.body.state\n    };\n\n    response.status(400).json(err);\n    return;\n  }\n\n  let accessToken = await JSONWebToken.issueOAuthToken(client, tokenData.user, {\n    role: Constants.ACCESS_TOKEN,\n    scope: tokenData.payload.scope\n  });\n\n  // let refreshToken = await JSONWebToken.issueOAuthToken(client, 'refresh_token');\n\n  let res: AccessTokenSuccessResponse = {\n    access_token: accessToken,\n    token_type: 'bearer',\n    // refresh_token: refreshToken,\n    scope: client.scope\n  };\n\n  return res;\n}\n\nexport default OAuthController;\n","/**\n * OAuthClients Controller.\n *\n * Lists and revokes oauth client authorizations\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nimport * as express from 'express';\n\nconst PromiseRouter = require('express-promise-router');\nimport OAuthClients from '../models/oauthclients';\nimport {ClientRegistry} from '../oauth-types';\n\nconst OAuthClientsController = PromiseRouter();\n\n/**\n * Get the currently authorized clients\n */\nOAuthClientsController.get('/', async (request: express.Request, response: express.Response) => {\n  let user = (request as any).jwt.user;\n  let clients = await OAuthClients.getAuthorized(user);\n\n  response.json(clients.map((client: ClientRegistry) => {\n    return client.getDescription();\n  }));\n});\n\nOAuthClientsController.delete('/:clientId', async (request: express.Request, response: express.Response) => {\n  let clientId = request.params.clientId;\n  if (!OAuthClients.get(clientId, undefined)) {\n    response.status(404).send('Client not found');\n    return;\n  }\n  let user = (request as any).jwt.user;\n\n  await OAuthClients.revokeClientAuthorization(user, clientId);\n  response.sendStatus(200);\n});\n\nexport default OAuthClientsController;\n","/**\n * Ping Controller.\n *\n * Handles requests to /ping, used for connectivity checks.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst express = require('express');\n\nconst PingController = express.Router();\n\nPingController.get('/', (request, response) => {\n  response.status(204).end();\n});\n\nmodule.exports = PingController;\n","/**\n * Push API Controller.\n *\n * Implements the Push API for notifications to use\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nconst PromiseRouter = require('express-promise-router');\nconst PushService = require('../push-service');\n\nconst PushController = PromiseRouter();\n\n/**\n * Handle requests for the public key\n */\nPushController.get('/vapid-public-key', async (request, response) => {\n  const vapid = await PushService.getVAPIDKeys();\n  if (!vapid) {\n    response.status(500).json({error: 'vapid not configured'});\n    return;\n  }\n  response.status(200).json({publicKey: vapid.publicKey});\n});\n\nPushController.post('/register', async (request, response) => {\n  const subscription = request.body.subscription;\n  try {\n    await PushService.createPushSubscription(subscription);\n  } catch (err) {\n    console.error(`PushController: Failed to register ${subscription}`, err);\n    response.status(500).json({error: 'register failed'});\n    return;\n  }\n  response.status(200).json({});\n});\n\nmodule.exports = PushController;\n","/**\n * Root Controller.\n *\n * Handles requests to /.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst express = require('express');\nconst Constants = require('../constants');\nconst TunnelService = require('../ssltunnel');\n\nconst RootController = express.Router();\n\n/**\n * Get the home page.\n */\nRootController.get('/', TunnelService.isTunnelSet, function(request, response) {\n  response.sendFile('index.html', {\n    root: Constants.BUILD_STATIC_PATH,\n  });\n});\n\nmodule.exports = RootController;\n","/**\n * Settings Controller.\n *\n * Manages gateway settings.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\n/* jshint unused:false */\n\nconst PromiseRouter = require('express-promise-router');\nconst greenlock = require('greenlock');\nconst leChallengeDns = require('le-challenge-dns').create({debug: false});\nconst config = require('config');\nconst fetch = require('node-fetch');\nconst fs = require('fs');\nconst path = require('path');\nconst Constants = require('../constants');\nconst Platform = require('../platform');\nconst Settings = require('../models/settings');\nconst TunnelService = require('../ssltunnel');\nconst UserProfile = require('../user-profile');\nconst mDNSserver = require('../mdns-server');\nconst pkg = require('../../package.json');\n\nconst SettingsController = PromiseRouter();\n\n/**\n * Set an experiment setting.\n */\nSettingsController.put(\n  '/experiments/:experimentName',\n  async (request, response) => {\n    const experimentName = request.params.experimentName;\n\n    if (!request.body || !request.body.hasOwnProperty('enabled')) {\n      response.status(400).send('Enabled property not defined');\n      return;\n    }\n\n    const enabled = request.body.enabled;\n\n    try {\n      const result =\n        await Settings.set(`experiments.${experimentName}.enabled`,\n                           enabled);\n      response.status(200).json({enabled: result});\n    } catch (e) {\n      console.error(`Failed to set setting experiments.${experimentName}`);\n      console.error(e);\n      response.status(400).send(e);\n    }\n  });\n\n/**\n * Get an experiment setting.\n */\nSettingsController.get(\n  '/experiments/:experimentName',\n  async (request, response) => {\n    const experimentName = request.params.experimentName;\n\n    try {\n      const result =\n        await Settings.get(`experiments.${experimentName}.enabled`);\n      if (typeof result === 'undefined') {\n        response.status(404).send('Setting not found');\n      } else {\n        response.status(200).json({enabled: result});\n      }\n    } catch (e) {\n      console.error(`Failed to get setting experiments.${experimentName}`);\n      console.error(e);\n      response.status(400).send(e);\n    }\n  });\n\nSettingsController.post('/reclaim', async (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('subdomain')) {\n    response.statusMessage = 'Subdomain missing from request';\n    response.status(400).end();\n    return;\n  }\n\n  const subdomain = request.body.subdomain;\n\n  try {\n    await fetch(`${config.get('ssltunnel.registration_endpoint')\n    }/reclaim?name=${subdomain}`);\n    response.status(200).end();\n  } catch (e) {\n    console.error(e);\n    response.statusMessage = `Error reclaiming domain - ${e}`;\n    response.status(400).end();\n  }\n});\n\nSettingsController.post('/subscribe', async (request, response) => {\n  if (!request.body ||\n      !request.body.hasOwnProperty('email') ||\n      !request.body.hasOwnProperty('subdomain')) {\n    response.statusMessage = 'Invalid request';\n    response.status(400).end();\n    return;\n  }\n\n  const email = request.body.email.toLowerCase();\n  const reclamationToken = request.body.reclamationToken;\n  const subdomain = request.body.subdomain;\n  const fulldomain = `${subdomain}.${config.get('ssltunnel.domain')}`;\n\n  function returnError(message) {\n    console.error(message);\n    response.statusMessage = `Error issuing certificate - ${message}`;\n    response.status(400).end();\n  }\n\n  const leStore = require('le-store-certbot').create({\n    webrootPath: Constants.BUILD_STATIC_PATH,\n    configDir: path.join(UserProfile.baseDir, 'etc'),\n    logsDir: path.join(UserProfile.baseDir, 'var', 'log'),\n    workDir: path.join(UserProfile.baseDir, 'var', 'lib'),\n  });\n  const le = greenlock.create({\n    server: greenlock.productionServerUrl,\n    challengeType: 'dns-01',\n    challenges: {'dns-01': leChallengeDns},\n    approveDomains: [fulldomain],\n    agreeTos: true,\n    store: leStore,\n    version: 'draft-11',\n  });\n\n  let token;\n  // promise to be resolved when LE has the dns challenge ready for us\n  leChallengeDns.leDnsResponse =\n    (challenge, keyAuthorization, keyAuthDigest) => {\n      return new Promise((resolve) => {\n        // ok now that we have a challenge, we call our gateway to setup\n        // the TXT record\n        fetch(`${config.get('ssltunnel.registration_endpoint')\n        }/dnsconfig?token=${token}&challenge=${keyAuthDigest}`)\n          .catch(function(e) {\n            returnError(e);\n          })\n          .then(function(res) {\n            return res.text();\n          })\n          .then(function() {\n            resolve('Success!');\n          });\n      });\n    };\n\n  let jsonToken;\n  try {\n    let subscribeUrl = `${config.get('ssltunnel.registration_endpoint')\n    }/subscribe?name=${subdomain}&email=${email}`;\n    if (reclamationToken) {\n      subscribeUrl += `&reclamationToken=${reclamationToken.trim()}`;\n    }\n\n    const res = await fetch(subscribeUrl);\n    const body = await res.text();\n\n    jsonToken = JSON.parse(body);\n    if (jsonToken.error) {\n      returnError(jsonToken.error);\n      return;\n    }\n\n    // store the token in the db\n    token = jsonToken.token;\n    await Settings.set('tunneltoken', jsonToken);\n  } catch (e) {\n    returnError(e);\n    return;\n  }\n\n  // Register Let's Encrypt\n  try {\n    const results = await le.register({\n      domains: [fulldomain],\n      email: config.get('ssltunnel.certemail'),\n      agreeTos: true,\n      rsaKeySize: 2048,\n      challengeType: 'dns-01',\n    });\n\n    console.log('success', results);\n\n    // ok. we got the certificates. let's save them\n    fs.writeFileSync(\n      path.join(UserProfile.sslDir, 'certificate.pem'), results.cert);\n    fs.writeFileSync(\n      path.join(UserProfile.sslDir, 'privatekey.pem'), results.privkey);\n    fs.writeFileSync(\n      path.join(UserProfile.sslDir, 'chain.pem'), results.chain);\n\n    // now we associate user's emails with the subdomain, unless it was\n    // reclaimed.\n    if (!reclamationToken) {\n      try {\n        await fetch(`${config.get('ssltunnel.registration_endpoint')\n        }/setemail?token=${token}&email=${email}`);\n        console.log('Online account created.');\n      } catch (e) {\n        // https://github.com/mozilla-iot/gateway/issues/358\n        // we should store this error and display to the user on\n        // settings page to allow him to retry\n        returnError(e);\n        return;\n      }\n    }\n\n    const endpoint_url = `https://${subdomain}.${\n      config.get('ssltunnel.domain')}`;\n    TunnelService.start(response, endpoint_url);\n    TunnelService.switchToHttps();\n  } catch (err) {\n    returnError(err.detail ||\n                err.message.substring(0, err.message.indexOf('\\n')));\n  }\n});\n\nSettingsController.post('/skiptunnel', async (request, response) => {\n  try {\n    await Settings.set('notunnel', true);\n    response.status(200).end();\n  } catch (e) {\n    console.error('Failed to set notunnel setting.');\n    console.error(e);\n    response.status(400).send(e);\n  }\n});\n\nSettingsController.get('/tunnelinfo', async (request, response) => {\n  try {\n    const localDomainSettings = await Settings.getTunnelInfo();\n    response.send(localDomainSettings);\n    response.status(200).end();\n  } catch (e) {\n    console.error('Failed to retrieve default settings for ' +\n      'tunneltoken or local service discovery setting');\n    console.error(e);\n    response.status(400).send(e);\n  }\n});\n\n/* This is responsible for controlling dynamically the local domain name\n * settings (via mDNS) and changing or updating mozilla tunnel endpoints.\n * The /domain endpoint is invoked from:\n *   MainMenu -> Settings -> Doamin\n *\n * JSON data: {\n *              local: {\n *                multicastDNSstate: boolean,\n *                localDNSname: string, - e.g. MyHome\n *              },\n *              mozillaTunnel: {\n *                tunnel: boolean,\n *                tunnelName: string, - e.g. MyName\n *                tunnelEmail: string\n *              }\n *            }\n */\nSettingsController.put('/domain', async (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('local')) {\n    response.statusMessage = 'Invalid request.';\n    response.status(400).end();\n    return;\n  }\n\n  try {\n    if (request.body.local.hasOwnProperty('localDNSname')) {\n      const requestDomainName = request.body.local.localDNSname;\n      await Settings.set('localDNSname', requestDomainName);\n      mDNSserver.server.setLocalDomain(requestDomainName);\n    } else if (request.body.local.hasOwnProperty('multicastDNSstate')) {\n      const requestState = request.body.local.multicastDNSstate;\n      await Settings.set('multicastDNSstate', requestState);\n      mDNSserver.server.setState(requestState);\n    } else {\n      response.statusMessage = 'Invalid request.';\n      response.status(400).end();\n      return;\n    }\n\n    let protocol, port;\n    if (request.secure) {\n      protocol = 'https';\n      port = config.get('ports.https');\n    } else {\n      protocol = 'http';\n      port = config.get('ports.http');\n    }\n\n    const url = `${protocol}://${mDNSserver.server.localDomain}.local:${port}`;\n    const localDomainSettings = {localDomain: url,\n                                 update: true,\n                                 mDNSstate: mDNSserver.server.serviceState};\n    response.status(200).json(localDomainSettings);\n  } catch (err) {\n    console.error(`Failed setting domain with: ${err} `);\n    const localDomainSettings = {localDomain: mDNSserver.server.localDomain,\n                                 update: false,\n                                 mDNSstate: mDNSserver.server.serviceState,\n                                 error: err.message};\n    response.status(400).json(localDomainSettings);\n  }\n});\n\nSettingsController.get('/addonsInfo', (request, response) => {\n  response.json({\n    url: config.get('addonManager.listUrl'),\n    api: config.get('addonManager.api'),\n    architecture: Platform.getArchitecture(),\n    version: pkg.version,\n    nodeVersion: Platform.getNodeVersion(),\n    pythonVersions: Platform.getPythonVersions(),\n    testAddons: config.get('addonManager.testAddons'),\n  });\n});\n\nSettingsController.get('/system/platform', (request, response) => {\n  response.json({\n    architecture: Platform.getArchitecture(),\n    raspberryPi: Platform.isRaspberryPi(),\n  });\n});\n\nSettingsController.get('/system/ssh', (request, response) => {\n  response.json({\n    toggleImplemented: Platform.isToggleSshImplemented(),\n    enabled: Platform.isSshEnabled(),\n  });\n});\n\nSettingsController.put('/system/ssh', (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('enabled')) {\n    response.status(400).send('Enabled property not defined');\n    return;\n  }\n\n  const enabled = request.body.enabled;\n  if (Platform.toggleSsh(enabled)) {\n    response.status(200).json({enabled});\n  } else {\n    response.status(400).send('Failed to toggle');\n  }\n});\n\nSettingsController.post('/system/actions', (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('action')) {\n    response.status(400).send('Action property not defined');\n    return;\n  }\n\n  const action = request.body.action;\n  switch (action) {\n    case 'restartGateway':\n      if (Platform.restartGateway()) {\n        response.status(200).end();\n      } else {\n        response.status(500).send('Failed to restart gateway');\n      }\n      break;\n    case 'restartSystem':\n      if (Platform.restartSystem()) {\n        response.status(200).end();\n      } else {\n        response.status(500).send('Failed to restart system');\n      }\n      break;\n    default:\n      response.status(400).send('Unsupported action');\n      break;\n  }\n});\n\nmodule.exports = SettingsController;\n","/**\n * Things Controller.\n *\n * Manages HTTP requests to /things.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Action = require('../models/action');\nconst Actions = require('../models/actions');\nconst ActionsController = require('./actions_controller');\nconst AddonManager = require('../addon-manager');\nconst Ajv = require('ajv');\nconst Constants = require('../constants');\nconst EventsController = require('./events_controller');\nconst PromiseRouter = require('express-promise-router');\nconst Settings = require('../models/settings');\nconst Things = require('../models/things');\nconst WebSocket = require('ws');\n\nconst ThingsController = PromiseRouter();\nconst ajv = new Ajv();\n\n/**\n * Get a list of Things.\n */\nThingsController.get('/', (request, response) => {\n  if (request.jwt.payload.role !== Constants.USER_TOKEN) {\n    if (!request.jwt.payload.scope) {\n      response.status(400).send('Token must contain scope');\n    } else {\n      const scope = request.jwt.payload.scope;\n      if (scope.indexOf(' ') === -1 && scope.indexOf('/') == 0 &&\n        scope.split('/').length == 2 &&\n        scope.split(':')[0] === Constants.THINGS_PATH) {\n        Things.getThingDescriptions(request.get('Host'), request.secure)\n          .then((things) => {\n            response.status(200).json(things);\n          });\n      } else {\n        // Get hrefs of things in scope\n        const paths = scope.split(' ');\n        const hrefs = new Array(0);\n        for (const path of paths) {\n          const parts = path.split(':');\n          hrefs.push(parts[0]);\n        }\n        Things.getListThingDescriptions(hrefs,\n                                        request.get('Host'),\n                                        request.secure)\n          .then((things) => {\n            response.status(200).json(things);\n          });\n      }\n    }\n  } else {\n    Things.getThingDescriptions(request.get('Host'), request.secure)\n      .then((things) => {\n        response.status(200).json(things);\n      });\n  }\n});\n\nThingsController.patch('/', async (request, response) => {\n  if (!request.body ||\n      !request.body.hasOwnProperty('thingId') ||\n      !request.body.hasOwnProperty('pin') ||\n      !request.body.thingId ||\n      request.body.pin.trim().length === 0) {\n    response.status(400).send('Invalid request');\n    return;\n  }\n\n  const thingId = request.body.thingId;\n  const pin = request.body.pin.trim();\n\n  try {\n    const device = await AddonManager.setPin(thingId, pin);\n    response.status(200).json(device);\n  } catch (e) {\n    console.error(`Failed to set PIN for ${thingId}: ${e}`);\n    response.status(400).send(e);\n  }\n});\n\n/**\n * Handle creating a new thing.\n */\nThingsController.post('/', async (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('id')) {\n    response.status(400).send('No id in thing description');\n    return;\n  }\n  const description = request.body;\n  const id = description.id;\n  delete description.id;\n\n  try {\n    // If the thing already exists, bail out.\n    await Things.getThing(id);\n    const err = 'Web thing already added';\n    console.log(err, id);\n    response.status(400).send(err);\n    return;\n  } catch (_e) {\n    // Do nothing, this is what we want.\n  }\n\n  // If we're adding a native webthing, we need to update the config for\n  // thing-url-adapter so that it knows about it.\n  let webthing = false;\n  if (description.hasOwnProperty('webthingUrl')) {\n    webthing = true;\n\n    const key = 'addons.thing-url-adapter';\n    try {\n      const current = await Settings.get(key);\n      if (typeof current === 'undefined') {\n        throw new Error('Setting is undefined.');\n      }\n\n      current.moziot.config.urls.push(description.webthingUrl);\n      await Settings.set(key, current);\n    } catch (e) {\n      console.error('Failed to update settings for thing-url-adapter');\n      console.error(e);\n      response.status(400).send(e);\n      return;\n    }\n\n    delete description.webthingUrl;\n  }\n\n  try {\n    const thing = await Things.createThing(id, description, webthing);\n    console.log(`Successfully created new thing ${thing.name}`);\n    response.status(201).send(thing);\n  } catch (error) {\n    console.error('Error saving new thing', id, description);\n    console.error(error);\n    response.status(500).send(error);\n  }\n\n  // If this is a web thing, we need to restart thing-url-adapter.\n  if (webthing) {\n    try {\n      await AddonManager.unloadAddon('thing-url-adapter', true);\n      await AddonManager.loadAddon('thing-url-adapter');\n    } catch (e) {\n      console.error('Failed to restart thing-url-adapter');\n      console.error(e);\n    }\n  }\n});\n\n/**\n * Get a Thing.\n */\nThingsController.get('/:thingId', (request, response) => {\n  const id = request.params.thingId;\n  Things.getThingDescription(id, request.get('Host'), request.secure)\n    .then((thing) => {\n      response.status(200).json(thing);\n    })\n    .catch((error) => {\n      console.error(`Error getting thing description for thing with id ${id}`);\n      console.error(`Error: ${error}`);\n      response.status(404).send(error);\n    });\n});\n\n/**\n * Get the properties of a Thing.\n */\nThingsController.get('/:thingId/properties', async (request, response) => {\n  const thingId = request.params.thingId;\n\n  let thing;\n  try {\n    thing = await Things.getThing(thingId);\n  } catch (e) {\n    console.error('Failed to get thing:', e);\n    response.status(404).send(e);\n    return;\n  }\n\n  const result = {};\n  for (const name in thing.properties) {\n    try {\n      const value = await AddonManager.getProperty(thingId, name);\n      result[name] = value;\n    } catch (e) {\n      console.error(`Failed to get property ${name}:`, e);\n    }\n  }\n\n  response.status(200).json(result);\n});\n\n/**\n * Get a property of a Thing.\n */\nThingsController.get(\n  '/:thingId/properties/:propertyName',\n  (request, response) => {\n    const thingId = request.params.thingId;\n    const propertyName = request.params.propertyName;\n    AddonManager.getProperty(thingId, propertyName).then((value) => {\n      const result = {};\n      result[propertyName] = value;\n      response.status(200).json(result);\n    }).catch((error) => {\n      console.error('Error getting value for thingId:', thingId,\n                    'property:', propertyName);\n      console.error(error);\n      response.status(500).send(error);\n    });\n  });\n\n/**\n * Set a property of a Thing.\n */\nThingsController.put(\n  '/:thingId/properties/:propertyName',\n  (request, response) => {\n    const thingId = request.params.thingId;\n    const propertyName = request.params.propertyName;\n    if (!request.body || typeof request.body[propertyName] === 'undefined') {\n      response.status(400).send('Invalid property name');\n      return;\n    }\n    const value = request.body[propertyName];\n    Things.getThingDescription(thingId, request.get('Host'), request.secure)\n      .then((thing) => {\n        if (!thing.properties.hasOwnProperty(propertyName)) {\n          response.status(404).send('Property not found');\n          return;\n        }\n\n        if (thing.properties[propertyName].readOnly) {\n          response.status(400).send('Read-only property');\n          return;\n        }\n\n        const valid = ajv.validate(thing.properties[propertyName], value);\n        if (!valid) {\n          response.status(400).send('Invalid property value');\n          return;\n        }\n\n        AddonManager.setProperty(thingId, propertyName, value)\n          .then((updatedValue) => {\n            // Note: it's possible that updatedValue doesn't match value.\n            const result = {};\n            result[propertyName] = updatedValue;\n            response.status(200).json(result);\n          }).catch((error) => {\n            console.error('Error setting value for thingId:', thingId,\n                          'property:', propertyName,\n                          'value:', value);\n            response.status(500).send(error);\n          });\n      }).catch(() => {\n        response.status(404).send('Thing not found');\n      });\n  });\n\n/**\n * Use an ActionsController to handle each thing's actions.\n */\nThingsController.use(`/:thingId${Constants.ACTIONS_PATH}`, ActionsController);\n\n/**\n * Use an EventsController to handle each thing's events.\n */\nThingsController.use(`/:thingId${Constants.EVENTS_PATH}`, EventsController);\n\n/**\n * Modify a Thing's floorplan position.\n */\nThingsController.patch('/:thingId', (request, response) => {\n  const thingId = request.params.thingId;\n  if (!request.body ||\n      !request.body.hasOwnProperty('floorplanX') ||\n      !request.body.hasOwnProperty('floorplanY')) {\n    response.status(400).send('x and y properties needed to position Thing');\n    return;\n  }\n  Things.getThing(thingId).then((thing) => {\n    // return\n    return thing.setCoordinates(\n      request.body.floorplanX, request.body.floorplanY);\n  }).then((description) => {\n    response.status(200).json(description);\n  }).catch((e) => {\n    response.status(500).send(`Failed to update thing ${thingId}: ${e}`);\n  });\n});\n\n/**\n * Modify a Thing.\n */\nThingsController.put('/:thingId', async (request, response) => {\n  const thingId = request.params.thingId;\n  if (!request.body || !request.body.hasOwnProperty('name')) {\n    response.status(400).send('name parameter required');\n    return;\n  }\n\n  const name = request.body.name.trim();\n  if (name.length === 0) {\n    response.status(400).send('Invalid name');\n    return;\n  }\n\n  let thing;\n  try {\n    thing = await Things.getThing(thingId);\n  } catch (e) {\n    response.status(500).send(`Failed to retrieve thing ${thingId}: ${e}`);\n  }\n\n  if (request.body.selectedCapability) {\n    try {\n      await thing.setSelectedCapability(request.body.selectedCapability);\n    } catch (e) {\n      response.status(500).send(`Failed to update thing ${thingId}: ${e}`);\n    }\n  }\n\n  if (request.body.iconData) {\n    try {\n      await thing.setIcon(request.body.iconData, true);\n    } catch (e) {\n      response.status(500).send(`Failed to update thing ${thingId}: ${e}`);\n    }\n  }\n\n  let description;\n  try {\n    description = await thing.setName(name);\n  } catch (e) {\n    response.status(500).send(`Failed to update thing ${thingId}: ${e}`);\n  }\n\n  response.status(200).json(description);\n});\n\n/**\n * Remove a Thing.\n */\nThingsController.delete('/:thingId', (request, response) => {\n  const thingId = request.params.thingId;\n  AddonManager.removeThing(thingId).\n    then(() => {\n      Things.removeThing(thingId).then(() => {\n        console.log(`Successfully deleted ${thingId} from database.`);\n        response.status(204).send();\n      }).catch((e) => {\n        response.status(500).send(`Failed to remove thing ${thingId}: ${e}`);\n      });\n    }).catch((e) => {\n      response.status(500).send(`Failed to remove thing ${thingId}: ${e}`);\n    });\n});\n\n/**\n * Connect to receive messages from a Thing\n */\nThingsController.ws('/:thingId/', (websocket, request) => {\n  // Since the Gateway have the asynchronous express middlewares, there is a\n  // possibility that the WebSocket have been closed.\n  if (websocket.readyState !== WebSocket.OPEN) {\n    return;\n  }\n  const thingId = request.params.thingId;\n  const subscribedEventNames = {};\n\n  function sendMessage(message) {\n    websocket.send(message, (err) => {\n      if (err) {\n        console.error('WebSocket sendMessage failed', err);\n      }\n    });\n  }\n\n  function onPropertyChanged(property) {\n    if (property.device.id !== thingId) {\n      return;\n    }\n    sendMessage(JSON.stringify({\n      messageType: Constants.PROPERTY_STATUS,\n      data: {\n        [property.name]: property.value,\n      },\n    }));\n  }\n\n  function onActionStatus(action) {\n    sendMessage(JSON.stringify({\n      messageType: Constants.ACTION_STATUS,\n      data: {\n        [action.name]: action.getDescription(),\n      },\n    }));\n  }\n\n  function onEvent(event) {\n    if (!subscribedEventNames[event.name]) {\n      return;\n    }\n    sendMessage(JSON.stringify({\n      messageType: Constants.EVENT,\n      data: {\n        [event.name]: event.getDescription(),\n      },\n    }));\n  }\n\n  function onConnected(connected) {\n    sendMessage(JSON.stringify({\n      messageType: Constants.CONNECTED,\n      data: connected,\n    }));\n  }\n\n  Things.getThing(thingId).then((thing) => {\n    thing.registerWebsocket(websocket);\n    thing.addEventSubscription(onEvent);\n    thing.addConnectedSubscription(onConnected);\n\n    websocket.on('close', () => {\n      thing.removeEventSubscription(onEvent);\n      thing.removeConnectedSubscription(onConnected);\n    });\n  }).catch(() => {\n    console.error('WebSocket opened on nonexistent thing', thingId);\n    sendMessage(JSON.stringify({\n      messageType: Constants.ERROR,\n      data: {\n        status: '404 Not Found',\n        message: `Thing ${thingId} not found`,\n      },\n    }));\n    websocket.close();\n  });\n\n  AddonManager.on(Constants.PROPERTY_CHANGED, onPropertyChanged);\n  Actions.on(Constants.ACTION_STATUS, onActionStatus);\n\n  const heartbeatInterval = setInterval(() => {\n    try {\n      websocket.ping();\n    } catch (e) {\n      // Do nothing. Let cleanup() handle things if necessary.\n      websocket.terminate();\n    }\n  }, 30 * 1000);\n\n  const cleanup = () => {\n    AddonManager.removeListener(Constants.PROPERTY_CHANGED, onPropertyChanged);\n    Actions.removeListener(Constants.ACTION_STATUS, onActionStatus);\n    clearInterval(heartbeatInterval);\n  };\n\n  websocket.on('error', cleanup);\n  websocket.on('close', cleanup);\n\n  websocket.on('message', (requestText) => {\n    let request = null;\n    try {\n      request = JSON.parse(requestText);\n    } catch (e) {\n      sendMessage(JSON.stringify({\n        messageType: Constants.ERROR,\n        data: {\n          status: '400 Bad Request',\n          message: 'Parsing request failed',\n        },\n      }));\n      return;\n    }\n\n    const device = AddonManager.getDevice(thingId);\n    if (!device) {\n      sendMessage(JSON.stringify({\n        messageType: Constants.ERROR,\n        data: {\n          status: '400 Bad Request',\n          message: `Thing ${thingId} not found`,\n          request: request,\n        },\n      }));\n      return;\n    }\n\n    switch (request.messageType) {\n      case Constants.SET_PROPERTY: {\n        const setRequests = Object.keys(request.data).map((property) => {\n          const value = request.data[property];\n          return device.setProperty(property, value);\n        });\n        Promise.all(setRequests).catch((err) => {\n          // If any set fails, send an error\n          sendMessage(JSON.stringify({\n            messageType: Constants.ERROR,\n            data: {\n              status: '400 Bad Request',\n              message: err,\n              request: request,\n            },\n          }));\n        });\n        break;\n      }\n\n      case Constants.ADD_EVENT_SUBSCRIPTION: {\n        for (const eventName in request.data) {\n          subscribedEventNames[eventName] = true;\n        }\n        break;\n      }\n\n      case Constants.REQUEST_ACTION: {\n        for (const actionName in request.data) {\n          const actionParams = request.data[actionName].input;\n          Things.getThing(thingId).then((thing) => {\n            const action = new Action(actionName, actionParams, thing);\n            return Actions.add(action).then(() => {\n              return AddonManager.requestAction(\n                thingId, action.id, actionName, actionParams);\n            });\n          }).catch((err) => {\n            sendMessage(JSON.stringify({\n              messageType: Constants.ERROR,\n              data: {\n                status: '400 Bad Request',\n                message: err.message,\n                request: request,\n              },\n            }));\n          });\n        }\n        break;\n      }\n\n      default: {\n        sendMessage(JSON.stringify({\n          messageType: Constants.ERROR,\n          data: {\n            status: '400 Bad Request',\n            message: `Unknown messageType: ${request.messageType}`,\n            request: request,\n          },\n        }));\n        break;\n      }\n    }\n  });\n});\n\nmodule.exports = ThingsController;\n","const childProcess = require('child_process');\nconst config = require('config');\nconst fs = require('fs');\nconst fetch = require('node-fetch');\nconst semver = require('semver');\nconst PromiseRouter = require('express-promise-router');\n\nconst pkg = require('../../package.json');\n\nconst UpdatesController = PromiseRouter();\n\nfunction readVersion(packagePath) {\n  return new Promise(function(resolve, reject) {\n    fs.readFile(packagePath, {encoding: 'utf8'}, function(err, data) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      try {\n        const pkgJson = JSON.parse(data);\n\n        if (!semver.valid(pkgJson.version)) {\n          reject(new Error(`Invalid gateway semver: ${pkgJson.version}`));\n          return;\n        }\n\n        resolve(pkgJson.version);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  });\n}\n\nfunction stat(path) {\n  return new Promise(function(resolve, reject) {\n    fs.stat(path, function(err, stats) {\n      if (err) {\n        if (err.code === 'ENOENT') {\n          resolve(null);\n        } else {\n          reject(err);\n        }\n      } else {\n        resolve(stats);\n      }\n    });\n  });\n}\n\nconst cacheLatest = {\n  tag: null,\n  time: 0,\n  value: {version: null},\n};\nconst cacheDuration = 60 * 1000;\n\nfunction cacheLatestInsert(response, value) {\n  cacheLatest.tag = response.get('etag');\n  cacheLatest.time = Date.now();\n  cacheLatest.value = value;\n}\n\n/**\n * Send the client an object describing the latest release\n */\nUpdatesController.get('/latest', async function(request, response) {\n  const etag = request.get('If-None-Match');\n  if (etag) {\n    if (cacheLatest.tag === etag &&\n        Date.now() - cacheLatest.time < cacheDuration) {\n      response.sendStatus(304);\n      return;\n    }\n  }\n\n  const res = await fetch(\n    config.get('updateUrl'),\n    {headers: {'User-Agent': `mozilla-iot-gateway/${pkg.version}`}});\n\n  const releases = await res.json();\n  if (!releases || !releases.filter) {\n    console.warn('API returned invalid releases, rate limit likely exceeded');\n    const value = {version: null};\n    response.send(value);\n    cacheLatestInsert(response, value);\n    return;\n  }\n  const latestRelease = releases.filter((release) => {\n    return !release.prerelease && !release.draft;\n  })[0];\n  if (!latestRelease) {\n    console.warn('No releases found');\n    const value = {version: null};\n    response.send(value);\n    cacheLatestInsert(response, value);\n    return;\n  }\n  const releaseVer = latestRelease.tag_name;\n  const value = {version: releaseVer};\n  response.send(value);\n  cacheLatestInsert(response, value);\n});\n\n/**\n * Send an object describing the update status of the gateway\n */\nUpdatesController.get('/status', async function(request, response) {\n  // gateway, gateway_failed, gateway_old\n  // oldVersion -> gateway_old's package.json version\n  // if (gateway_failed.version > thisversion) {\n  //  update failed, last attempt was ctime of gateway_failed\n  // }\n  const currentVersion = pkg.version;\n\n  const oldStats = await stat('../gateway_old/package.json');\n  let oldVersion = null;\n  if (oldStats) {\n    try {\n      oldVersion = await readVersion('../gateway_old/package.json');\n    } catch (e) {\n      console.error('Failed to read ../gateway_old/package.json:', e);\n    }\n  }\n\n  const failedStats = await stat('../gateway_failed/package.json');\n  let failedVersion = null;\n  if (failedStats) {\n    try {\n      failedVersion = await readVersion('../gateway_failed/package.json');\n    } catch (e) {\n      console.error('Failed to read ../gateway_failed/package.json:', e);\n    }\n  }\n\n  if (failedVersion && semver.gt(failedVersion, currentVersion)) {\n    response.send({\n      success: false,\n      version: currentVersion,\n      failedVersion: failedVersion,\n      timestamp: failedStats.ctime,\n    });\n  } else {\n    let timestamp = null;\n    if (oldStats) {\n      timestamp = oldStats.ctime;\n    }\n    response.send({\n      success: true,\n      version: currentVersion,\n      oldVersion: oldVersion,\n      timestamp: timestamp,\n    });\n  }\n});\n\nUpdatesController.post('/update', async function(request, response) {\n  childProcess.exec('sudo systemctl start ' +\n    'mozilla-iot-gateway.check-for-update.service');\n\n  response.end();\n});\n\nmodule.exports = UpdatesController;\n","/**\n * Uploads Controller.\n *\n * Manages file uploads.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst express = require('express');\nconst fs = require('fs');\nconst path = require('path');\nconst Constants = require('../constants');\nconst UserProfile = require('../user-profile');\n\nconst UPLOADS_PATH = UserProfile.uploadsDir;\nconst FLOORPLAN_PATH = path.join(UPLOADS_PATH, 'floorplan.svg');\nconst FALLBACK_FLOORPLAN_PATH = path.join(Constants.STATIC_PATH,\n                                          'images',\n                                          'floorplan.svg');\n\n// On startup, copy the default floorplan, if necessary.\nif (!fs.existsSync(FLOORPLAN_PATH)) {\n  try {\n    fs.copyFileSync(FALLBACK_FLOORPLAN_PATH, FLOORPLAN_PATH);\n  } catch (err) {\n    console.error(`Failed to copy floorplan: ${err}`);\n  }\n}\n\nconst UploadsController = express.Router();\n\n/**\n * Upload a file.\n */\nUploadsController.post('/', function(request, response) {\n  if (!request.files || !request.files.file) {\n    return response.status(500).send('No file provided for upload');\n  }\n\n  try {\n    if (fs.existsSync(FLOORPLAN_PATH)) {\n      fs.unlinkSync(FLOORPLAN_PATH);\n    }\n  } catch (err) {\n    return response.status(500).send(`Failed to unlink old floorplan: ${err}`);\n  }\n\n  const file = request.files.file;\n  file.mv(FLOORPLAN_PATH, function(error) {\n    if (error) {\n      // On error, try to copy the fallback.\n      try {\n        fs.copyFileSync(FALLBACK_FLOORPLAN_PATH, FLOORPLAN_PATH);\n      } catch (err) {\n        console.error(`Failed to copy floorplan: ${err}`);\n      }\n\n      return response.status(500).send(\n        `Failed to save uploaded file: ${error}`);\n    }\n\n    response.status(201).send('Successfully uploaded file');\n  });\n});\n\nmodule.exports = UploadsController;\n","/**\n * Users Controller.\n *\n * Manages HTTP requests to /users.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst PromiseRouter = require('express-promise-router');\nconst Passwords = require('../passwords');\nconst Users = require('../models/users');\nconst JSONWebToken = require('../models/jsonwebtoken');\nconst jwtMiddleware = require('../jwt-middleware');\nconst auth = jwtMiddleware.middleware();\n\nconst UsersController = PromiseRouter();\n\n/**\n * Get the count of users.\n *\n * NOTE: This is temporary while we figure out mutli user UI.\n */\nUsersController.get('/count', async (request, response) => {\n  const count = await Users.getCount();\n  return response.status(200).send({count});\n});\n\n/**\n * Get info about all users.\n */\nUsersController.get('/info', auth, async (request, response) => {\n  const users = await Users.getUsers();\n  const descriptions = users.map((user) => {\n    const loggedIn = user.id === request.jwt.user;\n    return Object.assign(user.getDescription(), {loggedIn});\n  });\n  return response.status(200).send(descriptions);\n});\n\n/**\n * Get a user.\n */\nUsersController.get('/:userId', auth, async (request, response) => {\n  const user = await Users.getUserById(request.params.userId);\n\n  if (!user) {\n    response.sendStatus(404);\n    return;\n  }\n\n  response.status(200).json(user.getDescription());\n});\n\n/**\n * Create a user\n */\nUsersController.post('/', async (request, response) => {\n  const body = request.body;\n\n  if (!body || !body.email || !body.password) {\n    response.status(400).send('User requires email and password.');\n    return;\n  }\n\n  // If a user has already been created, this path must be authenticated.\n  const count = await Users.getCount();\n  if (count > 0) {\n    const jwt = await jwtMiddleware.authenticate(request);\n    if (!jwt) {\n      response.sendStatus(401);\n      return;\n    }\n  }\n\n  // See if this user already exists.\n  const found = await Users.getUser(body.email);\n  if (found) {\n    response.status(400).send('User already exists.');\n    return;\n  }\n\n  // TODO: user facing errors...\n  const hash = await Passwords.hash(body.password);\n  const user = await Users.createUser(body.email, hash, body.name);\n  const jwt = await JSONWebToken.issueToken(user.id);\n\n  response.send({\n    jwt,\n  });\n});\n\n/**\n * Edit a user\n */\nUsersController.put('/:userId', auth, async (request, response) => {\n  const user = await Users.getUserById(request.params.userId);\n\n  if (!user) {\n    response.sendStatus(404);\n    return;\n  }\n\n  const body = request.body;\n  if (!body || !body.email || !body.password) {\n    response.status(400).send('User requires email and password.');\n    return;\n  }\n\n  const passwordMatch = await Passwords.compare(body.password, user.password);\n  if (!passwordMatch) {\n    response.status(400).send('Passwords do not match.');\n    return;\n  }\n\n  if (body.newPassword) {\n    user.password = await Passwords.hash(body.newPassword);\n  }\n\n  user.email = body.email;\n  user.name = body.name;\n\n  await Users.editUser(user);\n  response.sendStatus(200);\n});\n\n/**\n * Delete a user\n */\nUsersController.delete('/:userId', auth, async (request, response) => {\n  const userId = request.params.userId;\n\n  await Users.deleteUser(userId);\n  response.sendStatus(200);\n});\n\nmodule.exports = UsersController;\n","/**\n * Things Gateway Database.\n *\n * Stores a list of Things connected to the gateway.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst config = require('config');\nconst sqlite3 = require('sqlite3').verbose();\nconst fs = require('fs');\nconst path = require('path');\nconst Passwords = require('./passwords');\nconst assert = require('assert');\n\n// Imported as a module so we use a relative path.\nconst ThingsData = require('../static/things.json');\n\nconst TABLES = [\n  'users',\n  'jsonwebtokens',\n  'things',\n  'settings',\n  'pushSubscriptions',\n];\n\nconst DEBUG = false || (process.env.NODE_ENV === 'test');\n\nconst Database = {\n  /**\n   * SQLite3 Database object.\n   */\n  db: null,\n\n  /**\n   * Open the database.\n   */\n  open: function() {\n    // If the database is already open, just return.\n    if (this.db) {\n      return;\n    }\n\n    // Don't pull this from user-profile.js, because that would cause a\n    // circular dependency.\n    let filename;\n    let exists = false;\n    if (process.env.NODE_ENV === 'test') {\n      filename = ':memory:';\n    } else {\n      filename = path.join(config.get('profileDir'), 'config', 'db.sqlite3');\n\n      const removeBeforeOpen = config.get('database.removeBeforeOpen');\n\n      // Check if database already exists\n      exists = fs.existsSync(filename);\n      if (exists && removeBeforeOpen) {\n        fs.unlinkSync(filename);\n        exists = false;\n      }\n    }\n\n    console.log(exists ? 'Opening' : 'Creating', 'database:', filename);\n    // Open database or create it if it doesn't exist\n    this.db = new sqlite3.Database(filename);\n\n    // Set a timeout in case the database is locked. 10 seconds is a bit long,\n    // but it's better than crashing.\n    this.db.configure('busyTimeout', 10000);\n\n    this.db.serialize(() => {\n      this.createTables();\n      this.migrate();\n      // If database newly created, populate with default data\n      if (!exists) {\n        this.populate();\n      }\n    });\n  },\n\n  createTables: function() {\n    // Create Things table\n    this.db.run('CREATE TABLE IF NOT EXISTS things (' +\n      'id TEXT PRIMARY KEY,' +\n      'description TEXT' +\n    ');');\n\n    // Create Users table\n    this.db.run('CREATE TABLE IF NOT EXISTS users (' +\n      'id INTEGER PRIMARY KEY ASC,' +\n      'email TEXT UNIQUE,' +\n      'password TEXT,' +\n      'name TEXT' +\n    ');');\n\n    /**\n     * This really should have a foreign key constraint but it does not work\n     * with our version of node-sqlite / sqlite.\n     *\n     * https://github.com/mapbox/node-sqlite3/pull/660\n     *\n     * Instead, the INTEGER user is either the id of the user or -1 if NULL\n     */\n    this.db.run('CREATE TABLE IF NOT EXISTS jsonwebtokens (' +\n      'id INTEGER PRIMARY KEY ASC,' +\n      'keyId TEXT UNIQUE,' + // public id (kid in JWT terms).\n      'user INTEGER,' +\n      'issuedAt DATE,' +\n      'publicKey TEXT,' +\n      'payload TEXT' +\n    ');');\n\n    // Create Settings table\n    this.db.run('CREATE TABLE IF NOT EXISTS settings (' +\n      'key TEXT PRIMARY KEY,' +\n      'value TEXT' +\n    ');');\n\n    this.db.run(`CREATE TABLE IF NOT EXISTS pushSubscriptions (\n      id INTEGER PRIMARY KEY,\n      subscription TEXT UNIQUE\n    );`);\n  },\n\n  /**\n   * Do anything necessary to migrate from old database schemas.\n   */\n  migrate: function() {\n    this.db.run('DROP TABLE IF EXISTS jsonwebtoken_to_user');\n  },\n\n  /**\n   * Populate the database with default data.\n   */\n  populate: function() {\n    console.log('Populating database with default things...');\n    // Populate Things table\n    const insertSQL = this.db.prepare(\n      'INSERT INTO things (id, description) VALUES (?, ?)');\n    for (const thing of ThingsData) {\n      const thingId = thing.id;\n      delete thing.id;\n      insertSQL.run(thingId, JSON.stringify(thing));\n    }\n    insertSQL.finalize();\n\n    // Add default user if provided\n    const defaultUser = config.get('authentication.defaultUser');\n    if (defaultUser) {\n      const passwordHash = Passwords.hashSync(defaultUser.password);\n      this.db.run(\n        'INSERT INTO users (email, password, name) VALUES (?, ?, ?)',\n        [defaultUser.email.toLowerCase(), passwordHash, defaultUser.name],\n        function(error) {\n          if (error) {\n            console.error('Failed to save default user.');\n          } else {\n            console.log(`Saved default user ${defaultUser.email}`);\n          }\n        });\n    }\n\n    // Add any settings provided.\n    const generateSettings = function(obj, baseKey) {\n      const settings = [];\n\n      for (const key in obj) {\n        let newKey;\n        if (baseKey !== '') {\n          newKey = `${baseKey}.${key}`;\n        } else {\n          newKey = key;\n        }\n\n        if (typeof obj[key] === 'object') {\n          settings.push(...generateSettings(obj[key], newKey));\n        } else {\n          settings.push([newKey, obj[key]]);\n        }\n      }\n      return settings;\n    };\n\n    const settings = generateSettings(config.get('settings.defaults'), '');\n    for (const setting of settings) {\n      this.db.run(\n        'INSERT INTO settings (key, value) VALUES (?, ?)',\n        [setting[0], setting[1]],\n        function(error) {\n          if (error) {\n            console.error(`Failed to insert setting ${\n              setting[0]}`);\n          } else if (DEBUG) {\n            console.log(`Saved setting ${setting[0]} = ${\n              setting[1]}`);\n          }\n        });\n    }\n  },\n\n  /**\n   * Get all Things stored in the database.\n   *\n   * @return Promise which resolves with a list of Thing objects.\n   */\n  getThings: function() {\n    return new Promise((function(resolve, reject) {\n      this.db.all(\n        'SELECT id, description FROM things',\n        (function(err, rows) {\n          if (err) {\n            reject(err);\n          } else {\n            const things = [];\n            for (const row of rows) {\n              const thing = JSON.parse(row.description);\n              thing.id = row.id;\n              things.push(thing);\n            }\n            resolve(things);\n          }\n        }));\n    }).bind(this));\n  },\n\n  /**\n   * Add a new Thing to the Database.\n   *\n   * @param String id The ID to give the new Thing.\n   * @param String description A serialised Thing description.\n   */\n  createThing: function(id, description) {\n    return new Promise((function(resolve, reject) {\n      const db = this.db;\n      db.run(\n        'INSERT INTO things (id, description) VALUES (?, ?)',\n        [id, JSON.stringify(description)],\n        function(error) {\n          if (error) {\n            reject(error);\n          } else {\n            resolve(description);\n          }\n        });\n    }).bind(this));\n  },\n\n  /**\n   * Update a Thing in the Database.\n   *\n   * @param String id ID of the thing to update.\n   * @param String description A serialised Thing description.\n   */\n  updateThing: function(id, description) {\n    return new Promise((function(resolve, reject) {\n      const db = this.db;\n      db.run(\n        'UPDATE things SET description=? WHERE id=?',\n        [JSON.stringify(description), id],\n        function(error) {\n          if (error) {\n            reject(error);\n          } else {\n            resolve(description);\n          }\n        });\n    }).bind(this));\n  },\n\n  /**\n   * Remove a Thing from the Database.\n   *\n   * @param String id The ID of the Thing to remove.\n   */\n  removeThing: function(id) {\n    return new Promise((function(resolve, reject) {\n      const db = this.db;\n      db.run('DELETE FROM things WHERE id = ?', id, function(error) {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    }).bind(this));\n  },\n\n  /**\n   * Get a user by their email address.\n   */\n  getUser: function(email) {\n    return new Promise((function(resolve, reject) {\n      const db = this.db;\n      db.get(\n        'SELECT * FROM users WHERE email = ?',\n        email,\n        function(error, row) {\n          if (error) {\n            reject(error);\n          } else {\n            resolve(row);\n          }\n        });\n    }).bind(this));\n  },\n\n  /**\n   * Get a user by it's primary key (id).\n   */\n  getUserById: async function(id) {\n    assert(typeof id === 'number');\n    return await this.get(\n      'SELECT * FROM users WHERE id = ?',\n      id\n    );\n  },\n\n  /**\n   * Get all Users stored in the database.\n   *\n   * @return {Promise<Array<User>>} resolves with a list of User objects\n   */\n  getUsers: function() {\n    return new Promise((resolve, reject) => {\n      this.db.all('SELECT * FROM users', (err, rows) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(rows);\n        }\n      });\n    });\n  },\n\n  getUserCount: async function() {\n    const {count} = await this.get('SELECT count(*) as count FROM users');\n    return count;\n  },\n\n  /**\n   * Get a setting or return undefined\n   * @param {String} key\n   * @return {Promise<Object?>} value\n   */\n  getSetting: async function(key) {\n    const res = await this.get('SELECT value FROM settings WHERE key=?', key);\n    if (DEBUG) {\n      console.log('getSetting', key, res);\n    }\n\n    if (!res) {\n      return;\n    }\n\n    const {value} = res;\n    if (typeof value === 'undefined') {\n      return value;\n    } else {\n      return JSON.parse(value);\n    }\n  },\n\n  /**\n   * Set a setting. Assumes that the only access to the database is\n   * single-threaded.\n   *\n   * @param {String} key\n   * @param {Object} value\n   * @return {Promise}\n   */\n  setSetting: async function(key, value) {\n    value = JSON.stringify(value);\n    const currentValue = await this.getSetting(key);\n    if (typeof currentValue === 'undefined') {\n      return this.run('INSERT INTO settings (key, value) VALUES (?, ?)',\n                      [key, value]);\n    } else {\n      return this.run('UPDATE settings SET value=? WHERE key=?', [value, key]);\n    }\n  },\n\n  /**\n   * Remove a setting. Assumes that the only access to the database is\n   * single-threaded.\n   *\n   * @param {String} key\n   * @return {Promise}\n   */\n  deleteSetting: async function(key) {\n    this.run('DELETE FROM settings WHERE key = ?', [key]);\n  },\n\n  /**\n   * Get a list of add-on-related settings.\n   *\n   * @return {Promise<Array<Setting>>} resolves with a list of setting objects\n   */\n  getAddonSettings: async function() {\n    return new Promise((resolve, reject) => {\n      this.db.all('SELECT * FROM settings WHERE key LIKE \"addons.%\"',\n                  (err, rows) => {\n                    if (err) {\n                      reject(err);\n                    } else {\n                      resolve(rows);\n                    }\n                  });\n    });\n  },\n\n  /**\n   * Create a user\n   * @param {User} user\n   * @return {Promise<User>}\n   */\n  createUser: async function(user) {\n    const result = await this.run(\n      'INSERT INTO users (email, password, name) VALUES (?, ?, ?)',\n      [user.email, user.password, user.name]\n    );\n    assert(typeof result.lastID === 'number');\n    return result.lastID;\n  },\n\n  /**\n   * Edit a user.\n   * @param {User} user\n   * @return Promise that resolves when operation is complete.\n   */\n  editUser: async function(user) {\n    assert(typeof user.id === 'number');\n    return this.run(\n      'UPDATE users SET email=?, password=?, name=? WHERE id=?',\n      [user.email, user.password, user.name, user.id]\n    );\n  },\n\n  /**\n   * Delete a user.\n   * @param {Number} userId\n   * @return Promise that resolves when operation is complete.\n   */\n  deleteUser: function(userId) {\n    assert(typeof userId === 'number');\n    const deleteUser = this.run(\n      'DELETE FROM users WHERE id = ?',\n      [userId]\n    );\n    const deleteTokens = this.deleteJSONWebTokensForUser(userId);\n    /**\n     * XXX: This is a terrible hack until we get foreign key constraint support\n     * turned on with node-sqlite. As is this could leave junk around in the db.\n     */\n    return Promise.all([deleteTokens, deleteUser]);\n  },\n\n  /**\n   * Delete all jsonwebtoken's for a given user.\n   */\n  deleteJSONWebTokensForUser: function(userId) {\n    assert(typeof userId === 'number');\n    return this.run(\n      'DELETE FROM jsonwebtokens WHERE user = ?',\n      [userId]\n    );\n  },\n\n  /**\n   * Insert a JSONWebToken into the database\n   * @param {JSONWebToken} token\n   * @return {Promise<number>} resolved to JWT's primary key\n   */\n  createJSONWebToken: async function(token) {\n    const {keyId, user, publicKey, issuedAt, payload} = token;\n    const result = await this.run(\n      'INSERT INTO jsonwebtokens (keyId, user, issuedAt, publicKey, payload) ' +\n      'VALUES (?, ?, ?, ?, ?)',\n      [keyId, user, issuedAt, publicKey, JSON.stringify(payload)]\n    );\n    assert(typeof result.lastID === 'number');\n    return result.lastID;\n  },\n\n  /**\n   * Get a JWT by its key id.\n   * @param {string} keyId\n   * @return {Promise<Object>} jwt data\n   */\n  getJSONWebTokenByKeyId: function(keyId) {\n    assert(typeof keyId === 'string');\n    return this.get(\n      'SELECT * FROM jsonwebtokens WHERE keyId = ?',\n      keyId\n    );\n  },\n\n  /**\n   * Get all known JWTs of a user\n   * @param {number} userId\n   * @return {Promise<Array<Object>>}\n   */\n  getJSONWebTokensByUser: function(userId) {\n    return new Promise((resolve, reject) => {\n      this.db.all(\n        'SELECT * FROM jsonwebtokens WHERE user = ?',\n        [userId],\n        (err, rows) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(rows);\n          }\n        });\n    });\n  },\n\n  /**\n   * Delete a JWT by it's key id.\n   * @param {string} keyId\n   * @return {Promise<boolean>} whether deleted\n   */\n  deleteJSONWebTokenByKeyId: async function(keyId) {\n    assert(typeof keyId === 'string');\n    const result = await this.run(\n      'DELETE FROM jsonwebtokens WHERE keyId = ?',\n      keyId\n    );\n    return result.changes !== 0;\n  },\n\n  /**\n   * Store a new Push subscription\n   * @param {Object} subscription\n   * @return {Promise<number>} resolves to sub id\n   */\n  createPushSubscription: function(desc) {\n    const description = JSON.stringify(desc);\n\n    const insert = () => {\n      return this.run(\n        'INSERT INTO pushSubscriptions (subscription) VALUES (?)',\n        [description]\n      ).then((res) => {\n        return parseInt(res.lastID);\n      });\n    };\n\n    return this.get(\n      'SELECT id FROM pushSubscriptions WHERE subscription = ?',\n      description\n    ).then((res) => {\n      if (typeof res === 'undefined') {\n        return insert();\n      }\n\n      return res.id;\n    }).catch(() => {\n      return insert();\n    });\n  },\n\n  /**\n   * Get all push subscriptions\n   * @return {Promise<Array<PushSubscription>>}\n   */\n  getPushSubscriptions: function() {\n    return new Promise((resolve, reject) => {\n      this.db.all(\n        'SELECT id, subscription FROM pushSubscriptions',\n        [],\n        function(err, rows) {\n          if (err) {\n            reject(err);\n            return;\n          }\n          const subs = [];\n          for (const row of rows) {\n            const sub = JSON.parse(row.subscription);\n            sub.id = row.id;\n            subs.push(sub);\n          }\n          resolve(subs);\n        }\n      );\n    });\n  },\n\n  /**\n   * Delete a single subscription\n   * @param {number} id\n   */\n  deletePushSubscription: function(id) {\n    return this.run('DELETE FROM pushSubscriptions WHERE id = ?', [id]);\n  },\n\n  /**\n   * ONLY for tests (clears all tables).\n   */\n  deleteEverything: async function() {\n    return Promise.all(TABLES.map((t) => {\n      return this.run(`DELETE FROM ${t}`);\n    }));\n  },\n\n  get: function(sql, ...params) {\n    return new Promise((accept, reject) => {\n      params.push(function(err, row) {\n        if (err) {\n          reject(err);\n          return;\n        }\n        accept(row);\n      });\n\n      try {\n        this.db.get(sql, ...params);\n      } catch (err) {\n        reject(err);\n      }\n    });\n  },\n\n  /**\n   * Run a SQL statement\n   * @param {String} sql\n   * @param {Array<any>} values\n   * @return {Promise<Object>} promise resolved to `this` of statement result\n   */\n  run: function(sql, values) {\n    return new Promise((accept, reject) => {\n      try {\n        this.db.run(sql, values, function(err) {\n          if (err) {\n            reject(err);\n            return;\n          }\n          // node-sqlite puts results on \"this\" so avoid arrrow fn.\n          accept(this);\n        });\n      } catch (err) {\n        reject(err);\n      }\n    });\n  },\n};\n\nmodule.exports = Database;\n","/**\n * Wraps up a promise in a slightly more convenient manner for passing\n * around, or saving.\n *\n * @module Deferred\n */\n\n'use strict';\n\nconst DEBUG = false;\n\nlet id = 0;\n\nclass Deferred {\n  constructor() {\n    this.id = ++id;\n    this.promise = new Promise((resolve, reject) => {\n      this.resolveFunc = resolve;\n      this.rejectFunc = reject;\n    });\n    if (DEBUG) {\n      console.log('Deferred: Created deferred promise id:', this.id);\n    }\n  }\n\n  resolve(arg) {\n    if (DEBUG) {\n      console.log('Deferred: Resolving deferred promise id:', this.id,\n                  'arg:', arg);\n    }\n    return this.resolveFunc(arg);\n  }\n\n  reject(arg) {\n    if (DEBUG) {\n      console.log('Deferred: Rejecting deferred promise id:', this.id,\n                  'arg:', arg);\n    }\n    return this.rejectFunc(arg);\n  }\n}\n\nmodule.exports = Deferred;\n","/**\n * Elliptic curve helpers for the ES256 curve.\n *\n * This file contains the logic to generate public/private key pairs and return\n * them in the format openssl/crypto expects.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\nimport * as asn1 from 'asn1.js';\nimport * as crypto from 'crypto';\n\n/**\n * This curve goes by different names in different standards.\n *\n * These are all equivilent for our uses:\n *\n * prime256v1 = ES256 (JWT) = secp256r1 (rfc5480) = P256 (NIST).\n */\nconst CURVE = 'prime256v1';\n\n// https://tools.ietf.org/html/rfc5915#section-3\nconst ECPrivateKeyASN = asn1.define('ECPrivateKey', function() {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('privateKey').octstr(),\n    this.key('parameters').explicit(0).objid().optional(),\n    this.key('publicKey').explicit(1).bitstr().optional()\n  );\n});\n\n// https://tools.ietf.org/html/rfc3280#section-4.1\nconst SubjectPublicKeyInfoASN = asn1.define('SubjectPublicKeyInfo', function() {\n  this.seq().obj(\n    this.key('algorithm').seq().obj(\n      this.key('id').objid(),\n      this.key('namedCurve').objid()\n    ),\n    this.key('pub').bitstr()\n  )\n});\n\n// Chosen because it is _must_ implement.\n// https://tools.ietf.org/html/rfc5480#section-2.1.1\nconst UNRESTRICTED_ALGORITHM_ID = [1, 2, 840, 10045, 2, 1];\n// https://tools.ietf.org/html/rfc5480#section-2.1.1.1 (secp256r1)\nconst SECP256R1_CURVE = [1, 2, 840, 10045, 3, 1, 7];\n\n/**\n * Generate a public/private key pair.\n *\n * The returned keys are formatted in PEM for use with openssl (crypto).\n *\n * @return {Object} .public in PEM. .prviate in PEM.\n */\nexport function generateKeyPair() {\n  const key = crypto.createECDH(CURVE);\n  key.generateKeys();\n\n  const priv = ECPrivateKeyASN.encode({\n    version: 1,\n    privateKey: key.getPrivateKey(),\n    parameters: SECP256R1_CURVE,\n  }, 'pem', {\n    // https://tools.ietf.org/html/rfc5915#section-4\n    label: 'EC PRIVATE KEY',\n  });\n\n  const pub = SubjectPublicKeyInfoASN.encode({\n    pub: {\n      unused: 0,\n      data: key.getPublicKey(),\n    },\n    algorithm: {\n      id: UNRESTRICTED_ALGORITHM_ID,\n      namedCurve: SECP256R1_CURVE,\n    },\n  }, 'pem', {\n    label: 'PUBLIC KEY',\n  });\n\n  return { public: pub, private: priv };\n}\n\nexport const JWT_ALGORITHM = 'ES256';","/**\n * JWT authorization middleware.\n *\n * Contains logic to create a middleware which validates the presence of a JWT\n * token in either the header or query parameters (for websockets).\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\nconst Constants = require('./constants');\nconst JSONWebToken = require('./models/jsonwebtoken');\n\nconst AUTH_TYPE = 'Bearer';\n\n/**\n * Attempt to find the JWT in query parameters.\n *\n * @param {Request} req incoming http request.\n * @return {string|false} JWT string or false.\n */\nfunction extractJWTQS(req) {\n  if (typeof req.query === 'object' && req.query.jwt) {\n    return req.query.jwt;\n  }\n  return false;\n}\n\n/**\n *  Attempt to find the JWT in the Authorization header.\n *\n * @param {Request} req incoming http request.\n * @return {string|false} JWT string or false.\n */\nfunction extractJWTHeader(req) {\n  const {authorization} = req.headers;\n  if (!authorization) {\n    return false;\n  }\n  const [type, sig] = authorization.split(' ');\n  if (type !== AUTH_TYPE) {\n    console.warn('JWT header extraction failed: invalid auth type');\n    return false;\n  }\n  return sig;\n}\n\n/**\n * Authenticate the incoming call by checking it's JWT.\n *\n * TODO: User error messages.\n */\nasync function authenticate(req) {\n  const sig = extractJWTHeader(req) || extractJWTQS(req);\n  if (!sig) {\n    return false;\n  }\n  return await JSONWebToken.verifyJWT(sig);\n}\n\nfunction scopeAllowsRequest(scope, request) {\n  const requestPath = request.originalUrl;\n  if (!scope) {\n    return true;\n  }\n  const paths = scope.split(' ');\n  for (let path of paths) {\n    const parts = path.split(':');\n    if (parts.length !== 2) {\n      console.warn('Invalid scope', scope);\n      return false;\n    }\n    const access = parts[1];\n    const readwrite = access === Constants.READWRITE;\n    path = parts[0];\n    const allowedDirect = requestPath.startsWith(path);\n    const allowedThings = requestPath === Constants.THINGS_PATH &&\n      path.startsWith(Constants.THINGS_PATH);\n    const allowedCommands = requestPath === Constants.COMMANDS_PATH &&\n      path.startsWith(Constants.THINGS_PATH);\n\n    if (allowedDirect || allowedThings || allowedCommands) {\n      if (!readwrite && request.method !== 'GET' &&\n          request.method !== 'OPTIONS') {\n        return false;\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction middleware() {\n  return (req, res, next) => {\n    authenticate(req, res).\n      then((jwt) => {\n        if (!jwt) {\n          res.status(401).end();\n          return;\n        }\n        let scope = jwt.payload.scope;\n        if (jwt.payload.role === Constants.AUTHORIZATION_CODE) {\n          scope = `${Constants.OAUTH_PATH}:${Constants.READWRITE}`;\n        }\n        if (!scopeAllowsRequest(scope, req)) {\n          res.status(401).send(\n            `Token of role ${jwt.payload.role} used out of scope: ${scope}`);\n          return;\n        }\n        if (jwt.payload.role !== Constants.USER_TOKEN) {\n          if (!jwt.payload.scope) {\n            res.status(400)\n              .send('Token must contain scope');\n            return;\n          }\n        }\n\n        req.jwt = jwt;\n        next();\n      }).\n      catch((err) => {\n        console.error('error running jwt middleware', err.stack);\n        next(err);\n      });\n  };\n}\n\nmodule.exports = {\n  middleware,\n  authenticate,\n  extractJWTQS,\n  extractJWTHeader,\n};\n","/**\n * @module log-timestamps\n *\n * Modifies console.log and friends to prepend a timestamp to log lines.\n */\n/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\n'use strict';\n\nconst winston = require('winston');\nconst DailyRotateFile = require('winston-daily-rotate-file');\nconst UserProfile = require('./user-profile');\nconst format = require('util').format;\n\nclass CustomFormatter {\n  transform(info) {\n    const level = info.level.toUpperCase().padEnd(7, ' ');\n    info.message = `${info.timestamp} ${level}: ${info.message}`;\n    return info;\n  }\n}\n\nconst timestampFormat = winston.format.timestamp({\n  format: 'YYYY-MM-DD HH:mm:ss.SSS',\n});\n\nconst logger = winston.createLogger({\n  level: 'debug',\n  transports: [\n    new winston.transports.Console({\n      format: winston.format.combine(\n        timestampFormat,\n        new CustomFormatter(),\n        winston.format.colorize({\n          all: true,\n          colors: {\n            debug: 'white',\n            info: 'dim white',\n            warn: 'yellow',\n            error: 'red',\n          },\n        }),\n        winston.format.printf((info) => info.message)\n      ),\n    }),\n    new DailyRotateFile({\n      dirname: UserProfile.logDir,\n      filename: 'run-app.log',\n      zippedArchive: false,\n      maxSize: '10m',\n      maxFiles: 10,\n      format: winston.format.combine(\n        timestampFormat,\n        new CustomFormatter(),\n        winston.format.printf((info) => info.message)\n      ),\n    }),\n  ],\n  exitOnError: false,\n});\n\nfunction logPrefix() {\n  const currTime = new Date();\n  return `${currTime.getFullYear()}-${\n    (`0${currTime.getMonth() + 1}`).slice(-2)}-${\n    (`0${currTime.getDate()}`).slice(-2)} ${\n    (`0${currTime.getHours()}`).slice(-2)}:${\n    (`0${currTime.getMinutes()}`).slice(-2)}:${\n    (`0${currTime.getSeconds()}`).slice(-2)}.${\n    (`00${currTime.getMilliseconds()}`).slice(-3)} `;\n}\n\nif (!console.constructor.hooked) {\n  console.constructor.hooked = true;\n\n  // BufferedConsole is used (under jest) when running multiple tests\n  // CustomConsole is used (under jest) when running a single test\n\n  if (console.constructor.name === 'BufferedConsole') {\n    // The code for the write function comes from the jest source code:\n    // https://github.com/facebook/jest/blob/master/packages/jest-util/\n    //    src/buffered_console.js\n\n    const callsites = require('callsites');\n\n    console.constructor.write = function write(buffer, type, message, level) {\n      const call = callsites()[level != null ? level : 2];\n      const origin = `${call.getFileName()}:${call.getLineNumber()}`;\n      buffer.push({message: logPrefix() + message, origin, type});\n      return buffer;\n    };\n\n    console.log = function log() {\n      console.constructor.write(\n        this._buffer, 'log', format.apply(null, arguments));\n    };\n    console.info = function info() {\n      console.constructor.write(\n        this._buffer, 'info', format.apply(null, arguments));\n    };\n    console.warn = function warn() {\n      console.constructor.write(\n        this._buffer, 'warn', format.apply(null, arguments));\n    };\n    console.error = function error() {\n      console.constructor.write(\n        this._buffer, 'error', format.apply(null, arguments));\n    };\n    // jest's BufferedConsole doesn't provide a debug, so we skip it as well.\n  } else if (console.constructor.name === 'CustomConsole') {\n    // See: https://github.com/facebook/jest/blob/master/packages/jest-util/\n    //        src/Console.js\n    //      for the implementation of _log\n\n    console.log = function log() {\n      console._log('log', logPrefix() + format.apply(null, arguments));\n    };\n\n    console.info = function info() {\n      console._log('info', logPrefix() + format.apply(null, arguments));\n    };\n\n    console.warn = function warn() {\n      console._log('warn', logPrefix() + format.apply(null, arguments));\n    };\n\n    console.error = function error() {\n      console._log('error', logPrefix() + format.apply(null, arguments));\n    };\n    // jest's CustomConsole doesn't provide a debug, so we skip it as well.\n  } else {\n    // This path is for the normal non-jest output\n    const FUNCS = ['info', 'debug', 'error', 'warn', 'verbose', 'silly'];\n\n    for (const func of FUNCS) {\n      console[func] = function() {\n        logger[func](format.apply(null, arguments));\n      };\n    }\n\n    console.log = console.info;\n  }\n}\n","/*\n * mDNS service handler.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n// External dependencies\nconst config = require('config');\nconst dnssd = require('dnssd');\n\n// Internal dependencies\nconst Platform = require('./platform');\nconst Settings = require('./models/settings');\nconst TunnelService = require('./ssltunnel');\n\nconst server = new DNSserviceDiscovery();\n\n/**\n * DNS Service Discovery object.\n *\n * Creates an object which contains the 'profile' used to have a mDNS service\n * discovery process running. The object will be instantiated with default\n * values to ensure it will always work no matter DB or Config state.\n *\n * It provides methods to interact with the object. This object is created\n * quite early on since the starting process in app.js and parts of the UI in\n * settings_controller.js need to use its methods.\n */\nfunction DNSserviceDiscovery() {\n  this.serviceState = false;\n  if (process.env.NODE_ENV === 'test') {\n    this.port = 8080;\n  } else if (TunnelService.hasCertificates()) {\n    this.port = config.get('ports.https');\n  } else {\n    this.port = config.get('ports.http');\n  }\n  this.localDomain = config.get(\n    'settings.defaults.domain.localControl.mdnsServiceDomain');\n  this.localName = config.get(\n    'settings.defaults.domain.localControl.mdnsServiceName');\n  this.protocol = config.get(\n    'settings.defaults.domain.localControl.mdnsTxt.protocol');\n  this.power = config.get(\n    'settings.defaults.domain.localControl.mdnsTxt.power');\n  this.description = config.get(\n    'settings.defaults.domain.localControl.mdnsTxt.desc');\n  const txt = {desc: this.description,\n               protocols: this.protocol,\n               power: this.power};\n  const options = {name: this.localName, host: this.localDomain, txt};\n\n  this.handleError = (e) => {\n    console.debug(`mDNS error: ${e}`);\n    setTimeout(() => {\n      if (this.serviceState) {\n        this.dnssdHandle.start();\n      }\n    }, 10000);\n  };\n\n  // Initialize our object and make sure it's not started on object creation.\n  this.dnssdHandle =\n    dnssd.Advertisement(dnssd.tcp('http'), this.port, options);\n  this.dnssdHandle.on('error', this.handleError);\n  this.dnssdHandle.stop();\n}\n\n/**\n * Update the internal state of the mDNS service discovery, then restart it if\n * necessary.\n *\n * @param {boolean} state Whether or not to enable the service.\n */\nDNSserviceDiscovery.prototype.setState = function(state) {\n  this.serviceState = !!state;    // Make sure it's a boolean value\n\n  const success = Platform.togglemDns(state);\n  if (!success) {\n    if (this.serviceState) {\n      this.dnssdHandle.start();\n    } else {\n      this.dnssdHandle.stop(true);\n    }\n  }\n\n  console.log(`Service Discovery: state changed to: ${this.serviceState}`);\n};\n\n/**\n * Update the local name of the mDNS service discovery.\n *\n * Updating the localDomain name, stop the old service, and then create a new\n * dnssd object. The DNS name must be < 63 chars [a-z,0-9] and no hyphen as the\n * first character.\n *\n * @param {string} localDomain local DNS name. e.g. 'Myhome-iot'\n */\nDNSserviceDiscovery.prototype.setLocalDomain = function(localDomain) {\n  // Check any letter or number a-Z, A-Z, 0-9 and '-' any number of times with\n  // a length less than 63\n  localDomain = localDomain.toLowerCase();\n  const re = new RegExp(/^([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/);\n  const valid = re.test(localDomain) && localDomain.length <= 63;\n\n  if (valid) {\n    // Change our object data member and stop the old service first.\n    console.log(`Service Discovery: localDomain changed to: ${localDomain} `);\n    this.localDomain = localDomain;\n\n    const success = Platform.setHostname(this.localDomain);\n    if (!success) {\n      this.dnssdHandle.stop();\n\n      // Now let's start a new service with the new name.\n      const txt = {\n        desc: this.description,\n        protocols: this.protocol,\n        power: this.power,\n      };\n      const options = {\n        name: this.localName,\n        host: this.localDomain,\n        txt: txt,\n      };\n\n      this.dnssdHandle = dnssd.Advertisement(dnssd.tcp('http'),\n                                             this.port, options);\n      this.dnssdHandle.on('error', this.handleError);\n      this.dnssdHandle.start();\n    }\n  } else {\n    console.error('Service Discovery:',\n                  `Domain name did not match [a-z,A-Z,0-9,-]+: ${localDomain}`);\n    throw new Error('Invalid local domain name. It should only consist ' +\n                    'of characters a-Z, A-Z, 0-9, or -');\n  }\n};\n\n/**\n * This method will take a new profile 'object' and use this to update\n * the objects internal variables. It then will create a new mDNS\n * advertiser object using the new profile and restart the advertiser\n * depending on the state of the DNSserviceDiscovery manager.\n *\n * @return\n *\n * @param {object} newProfile For example:\n *   newProfile = {\n *     name: \"Mozilla IoT Gateway\",\n *     host: \"mozillaGateway\",     // Local DNS name\n *     txt: {\n *       desc: \"descriptive text\",\n *       protocols:  \"http, https, oauth2 etc..\",\n *       power: \"default power\"\n *     }\n *   }\n */\nDNSserviceDiscovery.prototype.changeProfile = function(newProfile) {\n  try {\n    console.log('Service Discovery: changing profile - local domain is now:',\n                newProfile.host);\n    this.localName = newProfile.name;\n    this.localDomain = newProfile.host;\n    this.description = newProfile.txt.desc;\n    this.protocol = newProfile.txt.protocols;\n    this.power = newProfile.txt.power;\n\n    const txt = {desc: this.description,\n                 protocols: this.protocol,\n                 power: this.power};\n    const options = {name: this.localName,\n                     host: this.localDomain,\n                     txt: txt};\n\n    this.dnssdHandle = dnssd.Advertisement(dnssd.tcp('http'),\n                                           this.port, options);\n    this.dnssdHandle.on('error', this.handleError);\n\n    // Check to see if the profile should be active or not.\n    if (this.serviceState) {\n      this.dnssdHandle.start();\n    } else {\n      this.dnssdHandle.stop();\n    }\n  } catch (err) {\n    // We should never get here. Don't attempt to start service discovery\n    // and log an error message. But allow the application to carry on\n    console.error('Service Discovery: could not change profile settings:', err);\n  }\n};\n\n/**\n * Stop the node mDNS service.\n */\nDNSserviceDiscovery.prototype.cleanup = function() {\n  this.dnssdHandle.stop(true);\n};\n\n/**\n * Look at settings that may be in the DB (set by the user) or default settings.\n * It will safely return a profile that will work for the calling application to\n * use.\n *\n * @return: {Object} mDNS config options, for example:\n *   Options = {\n *     name: \"Mozilla IoT Gateway\",\n *     host: \"mozillaGateway\",     // Local DNS name\n *     txt: {\n *       desc: \"descriptive text\",\n *       protocols:  \"http, https, oauth2 etc..\",\n *       power: \"default power\"\n *     }\n *   }\n * This function searches /config or db.sqlite3 DB\n */\nasync function getmDNSconfig() {\n  let mDNSserviceDomain;\n\n  try {\n    mDNSserviceDomain = await Settings.get('localDNSname');\n\n    // There is no local service discovery name stored in the DB -\n    // use the default value\n    if (!mDNSserviceDomain) {\n      mDNSserviceDomain = config.get(\n        'settings.defaults.domain.localControl.mdnsServiceDomain');\n    }\n    const locName = config.get(\n      'settings.defaults.domain.localControl.mdnsServiceName');\n    const locProtocols = config.get(\n      'settings.defaults.domain.localControl.mdnsTxt.protocol');\n    const powerCons = config.get(\n      'settings.defaults.domain.localControl.mdnsTxt.power');\n    const description = config.get(\n      'settings.defaults.domain.localControl.mdnsTxt.desc');\n\n    const txt = {desc: description, protocols: locProtocols, power: powerCons};\n    const options = {name: locName, host: mDNSserviceDomain, txt: txt};\n\n    return options;\n  } catch (err) {\n    // We should never get here. Don't attempt to start service discovery.\n    // Just log an error message and allow the application to carry on.\n    console.error('Service Discovery: could not find configuration settings:',\n                  err);\n  }\n}\n\n/**\n * Get the current enablement state of the mDNS service.\n *\n * @return: {boolean} 'True' if mDNS service discovery has a default or user\n * configured state requesting it to be started. 'False' if default or user\n * configured or no state if found.\n */\nasync function getmDNSstate() {\n  let mDNSstate;\n  try {\n    mDNSstate = await Settings.get('multicastDNSstate');\n    if (typeof mDNSstate === 'undefined') {\n      return config.get('settings.defaults.domain.localAccess');\n    }\n    return mDNSstate;\n  } catch (err) {\n    // Catch this DB error. Since we don't know what state the mDNS process\n    // should be in make sure it's off\n    console.error(\n      'Service Discovery: Error getting DB entry for multicast DNS state:',\n      err);\n\n    return config.get('settings.defaults.domain.localAccess');\n  }\n}\n\nmodule.exports = {\n  server: server,\n  getmDNSconfig: getmDNSconfig,\n  getmDNSstate: getmDNSstate,\n};\n","/**\n * Action Model.\n *\n * Manages Action data model and business logic.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Actions = require('../models/actions');\nconst Constants = require('../constants');\nconst EventEmitter = require('events');\nconst {Utils} = require('gateway-addon');\n\nclass Action extends EventEmitter {\n  /**\n   * Create a new Action\n   * @param {String} name\n   * @param {Object} input\n   * @param {Thing?} thing\n   */\n  constructor(name, input, thing) {\n    super();\n\n    this.id = Actions.generateId();\n    this.name = name;\n    this.input = input || {};\n    if (thing) {\n      this.href = `${thing.href}${Constants.ACTIONS_PATH}/${name}/${this.id}`;\n      this.thingId = thing.id;\n    } else {\n      this.href = `${Constants.ACTIONS_PATH}/${name}/${this.id}`;\n    }\n    this.status = 'created';\n    this.timeRequested = Utils.timestamp();\n    this.timeCompleted = null;\n    this.error = '';\n  }\n\n  getDescription() {\n    const description = {\n      input: this.input,\n      href: this.href,\n      status: this.status,\n      timeRequested: this.timeRequested,\n    };\n\n    if (this.timeCompleted) {\n      description.timeCompleted = this.timeCompleted;\n    }\n\n    if (this.error) {\n      description.error = this.error;\n    }\n\n    return description;\n  }\n\n  /**\n   * Update status and notify listeners\n   * @param {String} newStatus\n   */\n  updateStatus(newStatus) {\n    if (this.status === newStatus) {\n      return;\n    }\n\n    if (newStatus === 'completed') {\n      this.timeCompleted = Utils.timestamp();\n    }\n\n    this.status = newStatus;\n    this.emit(Constants.ACTION_STATUS, this);\n  }\n\n  /**\n   * Update from another action.\n   */\n  update(action) {\n    this.timeRequested = action.timeRequested;\n    this.timeCompleted = action.timeCompleted;\n\n    if (this.status !== action.status) {\n      this.status = action.status;\n      this.emit(Constants.ACTION_STATUS, this);\n    }\n  }\n}\n\nmodule.exports = Action;\n","/**\n * Actions.\n *\n * Manages a collection of Actions.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Things = require('../models/things');\nconst AddonManager = require('../addon-manager');\nconst Constants = require('../constants');\nconst EventEmitter = require('events');\n\nclass Actions extends EventEmitter {\n\n  constructor() {\n    super();\n\n    /**\n     * A map of action requests.\n     */\n    this.actions = {};\n\n    /**\n     * A counter to generate action IDs.\n     */\n    this.nextId = 0;\n\n    this.onActionStatus = this.onActionStatus.bind(this);\n  }\n\n  /**\n   * Reset actions state.\n   */\n  clearState() {\n    this.nextId = 0;\n    for (const id in this.actions) {\n      this.remove(id);\n    }\n  }\n\n  /**\n   * Generate an ID for a new action.\n   *\n   * @returns {integer} An id.\n   */\n  generateId() {\n    return ++this.nextId;\n  }\n\n  /**\n   * Get a particular action.\n   *\n   * @returns {Object} The specified action, or undefined if the action\n   * doesn't exist.\n   */\n  get(id) {\n    return this.actions[id];\n  }\n\n  /**\n   * Get a list of all current actions.\n   *\n   * @returns {Array} A list of current actions.\n   */\n  getAll() {\n    return Object.keys(this.actions).map((id) => {\n      return this.actions[id];\n    });\n  }\n\n  /**\n   * Get only the actions which are not associated with a specific thing and\n   * therefore belong to the root Gateway\n   */\n  getGatewayActions(actionName) {\n    return this.getAll().filter((action) => {\n      return !action.thingId;\n    }).filter((action) => {\n      if (actionName) {\n        return actionName === action.name;\n      }\n\n      return true;\n    }).map((action) => {\n      return {[action.name]: action.getDescription()};\n    });\n  }\n\n\n  /**\n   * Get only the actions which are associated with a specific thing\n   */\n  getByThing(thingId, actionName) {\n    return this.getAll().filter((action) => {\n      return action.thingId === thingId;\n    }).filter((action) => {\n      if (actionName) {\n        return actionName === action.name;\n      }\n\n      return true;\n    }).map((action) => {\n      return {[action.name]: action.getDescription()};\n    });\n  }\n\n  /**\n   * Add a new action.\n   *\n   * @param {Action} action An Action object.\n   * @return {Promise} resolved when action added or rejected if failed\n   */\n  add(action) {\n    const id = action.id;\n    this.actions[id] = action;\n\n    // Call this initially for the 'created' status.\n    this.onActionStatus(action);\n\n    action.on(Constants.ACTION_STATUS, this.onActionStatus);\n\n    if (action.thingId) {\n      return Things.getThing(action.thingId).then((thing) => {\n        const success = thing.addAction(action);\n        if (!success) {\n          delete this.actions[id];\n          throw new Error(`Invalid thing action name: \"${action.name}\"`);\n        }\n      });\n    }\n\n    // Only update the action status if it's being handled internally\n    action.updateStatus('pending');\n\n    switch (action.name) {\n      case 'pair':\n        AddonManager.addNewThing(action.input.timeout).then(function() {\n          action.updateStatus('completed');\n        }).catch(function(error) {\n          action.error = error;\n          action.updateStatus('error');\n          console.error('Thing was not added');\n          console.error(error);\n        });\n        break;\n      case 'unpair':\n        if (action.input.id) {\n          AddonManager.removeThing(action.input.id)\n            .then(function(thingIdUnpaired) {\n              console.log('unpair: thing:', thingIdUnpaired, 'was unpaired');\n              Things.removeThing(thingIdUnpaired);\n              action.updateStatus('completed');\n            }).catch(function(error) {\n              action.error = error;\n              action.updateStatus('error');\n              console.error('unpair of thing:',\n                            action.input.id, 'failed.');\n              console.error(error);\n            });\n        } else {\n          const msg = 'unpair missing \"id\" parameter.';\n          action.error = msg;\n          action.updateStatus('error');\n          console.error(msg);\n        }\n        break;\n      default:\n        delete this.actions[id];\n        return Promise.reject(\n          new Error(`Invalid action name: \"${action.name}\"`));\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * Forward the actionStatus event\n   */\n  onActionStatus(action) {\n    this.emit(Constants.ACTION_STATUS, action);\n  }\n\n  /**\n   * Remove an action from the action list.\n   *\n   * @param integer id Action ID.\n   *\n   * If the action has not yet been completed, it is cancelled.\n   */\n  remove(id) {\n    const action = this.actions[id];\n    if (!action) {\n      throw `Invalid action id: ${id}`;\n    }\n\n    if (action.status === 'pending') {\n      if (action.thingId) {\n        Things.getThing(action.thingId).then((thing) => {\n          if (!thing.removeAction(action)) {\n            throw `Invalid thing action name: \"${action.name}\"`;\n          }\n        }).catch((err) => {\n          console.error('Error removing thing action', err);\n        });\n      } else {\n        switch (action.name) {\n          case 'pair':\n            AddonManager.cancelAddNewThing();\n            break;\n          case 'unpair':\n            AddonManager.cancelRemoveThing(action.input.id);\n            break;\n          default:\n            throw `Invalid action name: \"${action.name}\"`;\n        }\n      }\n    }\n\n    action.updateStatus('deleted');\n    action.removeListener(Constants.ACTION_STATUS, this.onActionStatus);\n    delete this.actions[id];\n  }\n}\n\nmodule.exports = new Actions();\n","/**\n * Event Model.\n *\n * Manages Event data model\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst {Utils} = require('gateway-addon');\n\nclass Event {\n  /**\n   * Create a new Event\n   * @param {String} name\n   * @param {*} data\n   * @param {String?} thingId\n   * @param {String?} timestamp\n   */\n  constructor(name, data, thingId, timestamp) {\n    this.name = name;\n    this.data = data || null;\n    this.thingId = thingId;\n    this.timestamp = timestamp || Utils.timestamp();\n  }\n\n  getDescription() {\n    return {\n      data: this.data,\n      timestamp: this.timestamp,\n    };\n  }\n}\n\nmodule.exports = Event;\n","/**\n * Events.\n *\n * Manages a collection of Events.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Things = require('../models/things');\n\nclass Events {\n\n  constructor() {\n    this.events = [];\n  }\n\n  /**\n   * Reset events state.\n   */\n  clearState() {\n    this.events = [];\n  }\n\n  /**\n   * Get only the events which are not associated with a specific thing and\n   * therefore belong to the root Gateway.\n   */\n  getGatewayEvents(eventName) {\n    return this.events.filter((event) => {\n      return !event.thingId;\n    }).filter((event) => {\n      if (eventName) {\n        return eventName === event.name;\n      }\n\n      return true;\n    }).map((event) => {\n      return {[event.name]: event.getDescription()};\n    });\n  }\n\n\n  /**\n   * Get only the events which are associated with a specific thing.\n   */\n  getByThing(thingId, eventName) {\n    return this.events.filter((event) => {\n      return event.thingId === thingId;\n    }).filter((event) => {\n      if (eventName) {\n        return eventName === event.name;\n      }\n\n      return true;\n    }).map((event) => {\n      return {[event.name]: event.getDescription()};\n    });\n  }\n\n  /**\n   * Add a new event.\n   *\n   * @param {Object} event An Event object.\n   */\n  add(event) {\n    this.events.push(event);\n\n    if (event.thingId) {\n      Things.getThing(event.thingId).then(\n        (thing) => thing.dispatchEvent(event));\n    }\n  }\n}\n\nmodule.exports = new Events();\n","/**\n * Intent Parser Model\n *\n * Interface to the intent parser.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n'use strict';\n\nconst CommandUtils = require('../command-utils');\nconst net = require('net');\nconst IntentParser = {\n  keywords: [\n    'turn',\n    'switch',\n    'make',\n    'change',\n    'set',\n    'dim',\n    'brighten',\n  ],\n\n  types: Object.keys(CommandUtils.colors).\n    concat(Object.keys(CommandUtils.percentages)).\n    concat([\n      'on',\n      'off',\n      'red',\n      'warmer',\n      'cooler',\n    ]),\n\n  buildMessage: function(data) {\n    data = JSON.stringify(data);\n    const buffer = Buffer.alloc(4 + data.length);\n    buffer.writeUInt32BE(data.length, 0);\n    buffer.write(data, 4);\n    return buffer;\n  },\n\n  /**\n  * Interface train the intent parser\n  */\n  train: function(things) {\n    return new Promise((resolve, reject) => {\n      const socket_client = new net.Socket();\n      socket_client.connect(5555, '127.0.0.1', function() {\n        console.log('Connected to intent parser server');\n\n        socket_client.on('data', function(data) {\n          console.log(`Training result: ${data}`);\n          try {\n            const response = JSON.parse(data);\n            if (response.hasOwnProperty('status')) {\n              if (response.status === 'success') {\n                resolve();\n              } else {\n                reject(response.error);\n              }\n            } else {\n              reject('Failed to train intent parser.');\n            }\n          } catch (e) {\n            reject('Failed to train intent parser.');\n          }\n        });\n\n        socket_client.write(IntentParser.buildMessage({\n          command: 'train',\n          data: {\n            keywords: IntentParser.keywords,\n            types: IntentParser.types,\n            locations: things,\n          },\n        }));\n      });\n      socket_client.on('error', function(data) {\n        console.log(`Training error: ${data}`);\n        reject('Failed to train intent parser.');\n      });\n    });\n  },\n\n  /**\n  * Interface to query the intent parser\n  */\n  query: function(query) {\n    return new Promise((resolve, reject) => {\n      const socket_client = new net.Socket();\n      socket_client.connect(5555, '127.0.0.1', function() {\n        socket_client.on('data', function(data) {\n          console.log(`Query result: ${data}`);\n          try {\n            const response = JSON.parse(data);\n            if (response.hasOwnProperty('status') &&\n                response.hasOwnProperty('data')) {\n              if (response.status === 'success') {\n                resolve({\n                  cmd: 'IOT',\n                  href: '',\n                  thing: response.data.Location,\n                  keyword: response.data.Keyword,\n                  value: response.data.Type,\n                });\n              } else {\n                reject(response.error);\n              }\n            } else {\n              reject('Failed to query intent parser.');\n            }\n          } catch (e) {\n            reject('Failed to query intent parser.');\n          }\n        });\n        socket_client.write(IntentParser.buildMessage({\n          command: 'query',\n          data: query,\n        }));\n      });\n      socket_client.on('error', function(data) {\n        console.log(`Query error: ${data}`);\n        reject('Failed to query intent parser.');\n      });\n    });\n  },\n};\n\nmodule.exports = IntentParser;\n","/**\n * JSONWebToken Model.\n *\n * Contains logic to create and verify JWT tokens.\n *\n * This file contains the logic to generate public/private key pairs and return\n * them in the format openssl/crypto expects.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\nconst uuid = require('uuid');\nconst jwt = require('jsonwebtoken');\nconst assert = require('assert');\n\nconst ec = require('../ec-crypto');\nconst Database = require('../db');\nconst Settings = require('./settings');\n\nconst ROLE_USER_TOKEN = 'user_token';\n\nclass JSONWebToken {\n\n  /**\n   * Verify a JWT by it's signature.\n   *\n   * @return {JSONWebToken|bool} false when invalid JSONWebToken when valid.\n   */\n  static async verifyJWT(sig) {\n    const decoded = jwt.decode(sig, {\n      complete: true,\n    });\n\n    if (!decoded || !decoded.header || !decoded.header.kid) {\n      return false;\n    }\n\n    const {kid} = decoded.header;\n\n    const tokenData = await Database.getJSONWebTokenByKeyId(kid);\n    if (!tokenData) {\n      return false;\n    }\n\n    const token = new JSONWebToken(tokenData);\n    token.payload = token.verify(sig);\n    if (token.payload) {\n      return token;\n    }\n\n    return false;\n  }\n\n  /**\n   * Issue a JWT token and store it in the database.\n   *\n   * @param {User} user to issue token for.\n   * @return {string} the JWT token signature.\n   */\n  static async issueToken(user) {\n    const {sig, token} = await this.create(user);\n    await Database.createJSONWebToken(token);\n    return sig;\n  }\n\n  /**\n   * Issue a JWT token for an OAuth2 client and store it in the\n   * database.\n   *\n   * @param {ClientRegistry} client to issue token for.\n   * @param {number} user user id associated with token\n   * @param {{role: String, scope: String}} payload of token\n   * @return {string} the JWT token signature.\n   */\n  static async issueOAuthToken(client, user, payload) {\n    const {sig, token} = await this.create(user, Object.assign({\n      client_id: client.id,\n    }, payload));\n    await Database.createJSONWebToken(token);\n    return sig;\n  }\n\n  /**\n   * Remove a JWT token from the database by it's key id.\n   *\n   * @param {string} keyId of the record to remove.\n   * @return bool true when a record was deleted.\n   */\n  static async revokeToken(keyId) {\n    assert(typeof keyId === 'string');\n    return Database.deleteJSONWebTokenByKeyId(keyId);\n  }\n\n  /**\n   * @param number user id of the user to create a token for.\n   * @return {Object} containing .sig (the jwt signature) and .token\n   *  for storage in the database.\n   */\n  static async create(user, payload = {role: ROLE_USER_TOKEN}) {\n    const pair = ec.generateKeyPair();\n\n    const keyId = uuid.v4();\n    const tunnelInfo = await Settings.getTunnelInfo();\n    const issuer = tunnelInfo.tunnelDomain;\n    const options = {\n      algorithm: ec.JWT_ALGORITHM,\n      keyid: keyId,\n    };\n    if (issuer) {\n      options.issuer = issuer;\n    }\n\n    const sig = jwt.sign(payload, pair.private, options);\n\n    const token = {\n      user,\n      issuedAt: new Date(),\n      publicKey: pair.public,\n      keyId,\n      payload,\n    };\n\n    return {sig, token};\n  }\n\n  constructor(obj) {\n    const {user, issuedAt, publicKey, keyId} = obj;\n    assert(typeof user === 'number');\n    assert(issuedAt);\n    assert(typeof publicKey === 'string');\n    assert(typeof keyId === 'string');\n    this.user = user;\n    this.issuedAt = issuedAt;\n    this.publicKey = publicKey;\n    this.keyId = keyId;\n    this.payload = {};\n  }\n\n  /**\n   * Verify that the given JWT matches this token.\n   *\n   * @param string sig jwt token.\n   * @returns {Object|false} jwt payload if signature matches.\n   */\n  verify(sig) {\n    try {\n      return jwt.verify(sig, this.publicKey, {\n        algorithms: [ec.JWT_ALGORITHM],\n      });\n    } catch (err) {\n      // If this error is thrown we know the token is invalid.\n      if (err.name === 'JsonWebTokenError') {\n        return false;\n      }\n      throw err;\n    }\n  }\n\n}\n\nmodule.exports = JSONWebToken;\n","import { URL } from 'url';\nimport {Scope, ClientId, ClientRegistry} from '../oauth-types';\nconst Database = require('../db');\n\n\nclass OAuthClients {\n  private clients: Map<string, Array<ClientRegistry>> = new Map();\n  constructor() {\n  }\n\n  register(client: ClientRegistry) {\n    if (this.clients.get(client.id)) {\n      this.clients.get(client.id)!.push(client);\n    } else {\n      this.clients.set(client.id, [client]);\n    }\n  }\n\n  get(id: string, redirectUri: URL|undefined): ClientRegistry|undefined {\n    const clients = this.clients.get(id);\n    if (!clients) {\n      return;\n    }\n    if (!redirectUri) {\n      return clients[0];\n    }\n    for (let client of clients) {\n      if (client.redirect_uri.href === redirectUri.href) {\n        return client;\n      }\n    }\n    return clients[0];\n  }\n\n  async getAuthorized(userId: number): Promise<Array<ClientRegistry>> {\n    let jwts = await Database.getJSONWebTokensByUser(userId);\n    let authorized = new Map();\n\n    for (let jwt of jwts) {\n      let payload = JSON.parse(jwt.payload);\n      if (payload.role !== 'access_token') {\n        continue;\n      }\n      if (!this.clients.has(payload.client_id)) {\n        console.warn('Orphaned access_token', jwt);\n        await Database.deleteJSONWebTokenByKeyId(jwt.keyId);\n        continue;\n      }\n      const defaultClient = this.clients.get(payload.client_id)![0];\n      if (!defaultClient) {\n        continue;\n      }\n      authorized.set(payload.client_id, defaultClient);\n    }\n\n    return Array.from(authorized.values());\n  }\n\n  async revokeClientAuthorization(userId: number, clientId: string) {\n    let jwts = await Database.getJSONWebTokensByUser(userId);\n\n    for (let jwt of jwts) {\n      let payload = JSON.parse(jwt.payload);\n      if (payload.client_id === clientId) {\n        await Database.deleteJSONWebTokenByKeyId(jwt.keyId);\n      }\n    }\n  }\n}\n\nlet oauthClients = new OAuthClients();\n\noauthClients.register(\n  new ClientRegistry(new URL('http://127.0.0.1:31338/callback'), 'test',\n                     'Test OAuth Client', 'super secret', '/things:readwrite')\n);\n\noauthClients.register(\n  new ClientRegistry(new URL('http://127.0.0.1:31338/bonus-entry'), 'test',\n                     'Test OAuth Client', 'other secret', '/things:readwrite')\n);\n\noauthClients.register(\n  new ClientRegistry(new URL('https://gateway.localhost/oauth/local-token-service'), 'local-token',\n                     'Local Token Service', 'super secret',\n                     '/things:readwrite')\n);\nexport default oauthClients;\n","/**\n * Settings Model.\n *\n * Manages the getting and setting of settings\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst config = require('config');\nconst Database = require('../db');\nconst util = require('util');\n\nconst DEBUG = false || (process.env.NODE_ENV === 'test');\n\nconst Settings = {\n\n  /**\n   * Get a setting.\n   *\n   * @param {String} key Key of setting to get.\n   */\n  get: function(key) {\n    return Database.getSetting(key).catch(function(e) {\n      console.error('Failed to get', key);\n      throw e;\n    });\n  },\n\n  /**\n   * Set a setting.\n   *\n   * @param {String} key Key of setting to set.\n   * @param value Value to set key to.\n   */\n  set: function(key, value) {\n    return Database.setSetting(key, value).then(function() {\n      if (DEBUG) {\n        console.log('Set', key, 'to',\n                    util.inspect(value, {breakLength: Infinity}));\n      }\n      return value;\n    }).catch(function(e) {\n      console.error('Failed to set', key, 'to',\n                    util.inspect(value, {breakLength: Infinity}));\n      throw e;\n    });\n  },\n\n  /**\n   * Delete a setting.\n   *\n   * @param {String} key Key of setting to delete.\n   */\n  delete: function(key) {\n    return Database.deleteSetting(key).catch(function(e) {\n      console.error('Failed to delete', key);\n      throw e;\n    });\n  },\n\n  /**\n   * Get an object of all add-on-related settings.\n   */\n  getAddonSettings: function() {\n    return Database.getAddonSettings().catch(function(e) {\n      console.error('Failed to get add-on settings');\n      throw e;\n    });\n  },\n\n  /**\n   * Get an object of all tunnel settings\n   * @return {localDomain, mDNSstate, tunnelDomain}\n   */\n  getTunnelInfo: async function() {\n    // Check to see if we have a tunnel endpoint first\n    const result = await Settings.get('tunneltoken');\n    let localDomain;\n    let mDNSstate;\n    let tunnelEndpoint;\n\n    if (typeof result === 'object') {\n      console.log(`Tunnel domain found. Tunnel name is: ${result.name} and`,\n                  `tunnel domain is: ${config.get('ssltunnel.domain')}`);\n      tunnelEndpoint =\n        `https://${result.name}.${config.get('ssltunnel.domain')}`;\n    } else {\n      tunnelEndpoint = 'Not set.';\n    }\n\n    // Find out our default local DNS name Check for a previous name in the\n    // DB, if that does not exist use the default.\n    try {\n      mDNSstate = await Settings.get('multicastDNSstate');\n      localDomain = await Settings.get('localDNSname');\n      // If our DB is empty use defaults\n      if (typeof mDNSstate === 'undefined') {\n        mDNSstate = config.get(\n          'settings.defaults.domain.localAccess');\n      }\n      if (typeof localDomain === 'undefined') {\n        localDomain = config.get(\n          'settings.defaults.domain.localControl.mdnsServiceDomain');\n      }\n    } catch (err) {\n      // Catch this DB error. Since we don't know what state the mDNS process\n      // should be in make sure it's off\n      console.error(`Error getting DB entry for multicast from the DB: ${err}`);\n      localDomain = config.get(\n        'settings.defaults.domain.localControl.mdnsServiceDomain');\n    }\n\n    console.log(`Tunnel name is set to: ${tunnelEndpoint}`);\n    console.log(`Local mDNS Service Domain Name is: ${localDomain}`);\n    return {\n      localDomain: localDomain,\n      mDNSstate: mDNSstate,\n      tunnelDomain: tunnelEndpoint,\n    };\n  },\n};\n\nmodule.exports = Settings;\n","/**\n * Thing Model.\n *\n * Represents a Web Thing.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Constants = require('../constants');\nconst Database = require('../db.js');\nconst EventEmitter = require('events');\nconst UserProfile = require('../user-profile');\nconst WebSocket = require('ws');\nconst fs = require('fs');\nconst path = require('path');\nconst tmp = require('tmp');\n\n/**\n * Thing constructor.\n *\n * Create a Thing object from an id and a valid Thing description.\n *\n * @param {String} id Unique ID.\n * @param {Object} description Thing description.\n */\nconst Thing = function(id, description) {\n  if (!id || !description) {\n    console.error('id and description needed to create new Thing');\n    return;\n  }\n  // Parse the Thing Description\n  this.id = id;\n  this.name = description.name || '';\n  this.type = description.type || '';\n  this['@context'] =\n    description['@context'] || 'https://iot.mozilla.org/schemas';\n  this['@type'] = description['@type'] || [];\n  this.description = description.description || '';\n  this.href = `${Constants.THINGS_PATH}/${this.id}`;\n  this.properties = {};\n  this.actions = description.actions || {};\n  this.events = description.events || {};\n  this.connected = false;\n  this.eventsDispatched = [];\n  this.emitter = new EventEmitter();\n  if (description.properties) {\n    for (const propertyName in description.properties) {\n      const property = description.properties[propertyName];\n      // Give the property a URL\n      property.href = `${Constants.THINGS_PATH}/${this.id\n      }${Constants.PROPERTIES_PATH}/${propertyName}`;\n      this.properties[propertyName] = property;\n    }\n  }\n  this.floorplanX = description.floorplanX;\n  this.floorplanY = description.floorplanY;\n  this.selectedCapability = description.selectedCapability;\n  this.websockets = [];\n  this.links = [\n    {\n      rel: 'properties',\n      href: `${this.href}/properties`,\n    },\n    {\n      rel: 'actions',\n      href: `${this.href}/actions`,\n    },\n    {\n      rel: 'events',\n      href: `${this.href}/events`,\n    },\n  ];\n\n  const uiLink = {\n    rel: 'alternate',\n    mediaType: 'text/html',\n    href: this.href,\n  };\n\n  if (description.hasOwnProperty('uiHref') && description.uiHref) {\n    uiLink.href = description.uiHref;\n  } else if (description.hasOwnProperty('links')) {\n    for (const link of description.links) {\n      if (link.rel === 'alternate' &&\n          link.mediaType === 'text/html' &&\n          link.href.startsWith('http')) {\n        uiLink.href = link.href;\n        break;\n      }\n    }\n  }\n\n  this.links.push(uiLink);\n\n  for (const actionName in this.actions) {\n    this.actions[actionName].href =\n      `${this.href}/actions/${actionName}`;\n  }\n\n  for (const eventName in this.events) {\n    this.events[eventName].href = `${this.href}/events/${eventName}`;\n  }\n\n  this.iconHref = null;\n  if (description.iconHref) {\n    this.iconHref = description.iconHref;\n  } else if (description.iconData) {\n    this.setIcon(description.iconData, false);\n  }\n};\n\n/**\n * Set the x and y co-ordinates for a Thing on the floorplan.\n *\n * @param {number} x The x co-ordinate on floorplan (0-100).\n * @param {number} y The y co-ordinate on floorplan (0-100).\n * @return {Promise} A promise which resolves with the description set.\n */\nThing.prototype.setCoordinates = function(x, y) {\n  this.floorplanX = x;\n  this.floorplanY = y;\n  return Database.updateThing(this.id, this.getDescription());\n};\n\n/**\n * Set the name of this Thing.\n *\n * @param {String} name The new name\n * @return {Promise} A promise which resolves with the description set.\n */\nThing.prototype.setName = function(name) {\n  this.name = name;\n  return Database.updateThing(this.id, this.getDescription());\n};\n\n/**\n * Set the custom icon for this Thing.\n *\n * @param {Object} iconData Base64-encoded icon and its mime-type.\n * @param {Boolean} updateDatabase Whether or not to update the database after\n *                                 setting.\n */\nThing.prototype.setIcon = function(iconData, updateDatabase) {\n  if (!iconData.data ||\n      !['image/jpeg', 'image/png', 'image/svg+xml'].includes(iconData.mime)) {\n    console.error('Invalid icon data:', iconData);\n    return;\n  }\n\n  if (this.iconHref) {\n    try {\n      fs.unlinkSync(path.join(UserProfile.baseDir, this.iconHref));\n    } catch (e) {\n      console.error('Failed to remove old icon:', e);\n      // continue\n    }\n\n    this.iconHref = null;\n  }\n\n  let extension;\n  switch (iconData.mime) {\n    case 'image/jpeg':\n      extension = '.jpg';\n      break;\n    case 'image/png':\n      extension = '.png';\n      break;\n    case 'image/svg+xml':\n      extension = '.svg';\n      break;\n  }\n\n  let tempfile;\n  try {\n    tempfile = tmp.fileSync({\n      mode: parseInt('0644', 8),\n      template: path.join(UserProfile.uploadsDir, `XXXXXX${extension}`),\n      detachDescriptor: true,\n      keep: true,\n    });\n\n    const data = Buffer.from(iconData.data, 'base64');\n    fs.writeFileSync(tempfile.fd, data);\n  } catch (e) {\n    console.error('Failed to write icon:', e);\n    if (tempfile) {\n      try {\n        fs.unlinkSync(tempfile.fd);\n      } catch (e) {\n        // pass\n      }\n    }\n\n    return;\n  }\n\n  this.iconHref = path.join('/uploads', path.basename(tempfile.name));\n\n  if (updateDatabase) {\n    return Database.updateThing(this.id, this.getDescription());\n  }\n};\n\n/**\n * Set the selected capability of this Thing.\n *\n * @param {String} capability The selected capability\n * @return {Promise} A promise which resolves with the description set.\n */\nThing.prototype.setSelectedCapability = function(capability) {\n  this.selectedCapability = capability;\n  return Database.updateThing(this.id, this.getDescription());\n};\n\n/**\n * Dispatch an event to all listeners subscribed to the Thing\n * @param {Event} event\n */\nThing.prototype.dispatchEvent = function(event) {\n  if (!event.thingId) {\n    event.thingId = this.id;\n  }\n  this.eventsDispatched.push(event);\n  this.emitter.emit(Constants.EVENT, event);\n};\n\n/**\n * Add a subscription to the Thing's events\n * @param {Function} callback\n */\nThing.prototype.addEventSubscription = function(callback) {\n  this.emitter.on(Constants.EVENT, callback);\n};\n\n/**\n * Remove a subscription to the Thing's events\n * @param {Function} callback\n */\nThing.prototype.removeEventSubscription = function(callback) {\n  this.emitter.removeListener(Constants.EVENT, callback);\n};\n\n/**\n * Add a subscription to the Thing's connected state\n * @param {Function} callback\n */\nThing.prototype.addConnectedSubscription = function(callback) {\n  this.emitter.on(Constants.CONNECTED, callback);\n  callback(this.connected);\n};\n\n/**\n * Remove a subscription to the Thing's connected state\n * @param {Function} callback\n */\nThing.prototype.removeConnectedSubscription = function(callback) {\n  this.emitter.removeListener(Constants.CONNECTED, callback);\n};\n\n/**\n * Get a JSON Thing Description for this Thing.\n *\n * @param {String} reqHost request host, if coming via HTTP\n * @param {Boolean} reqSecure whether or not the request is secure, i.e. TLS\n */\nThing.prototype.getDescription = function(reqHost, reqSecure) {\n  const links = JSON.parse(JSON.stringify(this.links));\n\n  if (typeof reqHost !== 'undefined') {\n    const wsLink = {\n      rel: 'alternate',\n      href: `${reqSecure ? 'wss' : 'ws'}://${reqHost}${this.href}`,\n    };\n\n    links.push(wsLink);\n  }\n\n  return {\n    name: this.name,\n    type: this.type,\n    '@context': this['@context'],\n    '@type': this['@type'],\n    description: this.description,\n    href: this.href,\n    properties: this.properties,\n    actions: this.actions,\n    events: this.events,\n    links: links,\n    floorplanX: this.floorplanX,\n    floorplanY: this.floorplanY,\n    selectedCapability: this.selectedCapability,\n    iconHref: this.iconHref,\n  };\n};\n\nThing.prototype.registerWebsocket = function(ws) {\n  this.websockets.push(ws);\n};\n\n/**\n * Remove and clean up the Thing\n */\nThing.prototype.remove = function() {\n  if (this.iconHref) {\n    try {\n      fs.unlinkSync(path.join(UserProfile.baseDir, this.iconHref));\n    } catch (e) {\n      console.error('Failed to remove old icon:', e);\n      // continue\n    }\n\n    this.iconHref = null;\n  }\n\n  this.websockets.forEach(function(ws) {\n    if (ws.readyState === WebSocket.OPEN ||\n        ws.readyState === WebSocket.CONNECTING) {\n      ws.close();\n    }\n  });\n};\n\n/**\n * Add an action\n * @param {Action} action\n * @return {boolean} Whether a known action\n */\nThing.prototype.addAction = function(action) {\n  return this.actions.hasOwnProperty(action.name);\n};\n\n/**\n * Remove an action\n * @param {Action} action\n * @return {boolean} Whether a known action\n */\nThing.prototype.removeAction = function(action) {\n  return this.actions.hasOwnProperty(action.name);\n};\n\n/**\n * Update a thing from a description.\n *\n * Thing descriptions can change as new capabilities are developed, so this\n * method allows us to update the stored thing description.\n *\n * @param {Object} description Thing description.\n * @return {Promise} A promise which resolves with the description set.\n */\nThing.prototype.updateFromDescription = function(description) {\n  // Update type\n  this.type = description.type || '';\n\n  // Update @context\n  this['@context'] =\n    description['@context'] || 'https://iot.mozilla.org/schemas';\n\n  // Update @type\n  this['@type'] = description['@type'] || [];\n\n  // Update description\n  this.description = description.description || '';\n\n  // Update properties\n  this.properties = {};\n  if (description.properties) {\n    for (const propertyName in description.properties) {\n      const property = description.properties[propertyName];\n      // Give the property a URL\n      property.href = `${Constants.THINGS_PATH}/${this.id\n      }${Constants.PROPERTIES_PATH}/${propertyName}`;\n      this.properties[propertyName] = property;\n    }\n  }\n\n  // Update actions\n  this.actions = description.actions || {};\n  for (const actionName in this.actions) {\n    this.actions[actionName].href =\n      `${this.href}/actions/${actionName}`;\n  }\n\n  // Update events\n  this.events = description.events || {};\n  for (const eventName in this.events) {\n    this.events[eventName].href = `${this.href}/events/${eventName}`;\n  }\n\n  let uiLink = {\n    rel: 'alternate',\n    mediaType: 'text/html',\n    href: this.href,\n  };\n  for (const link of this.links) {\n    if (link.rel === 'alternate' && link.mediaType === 'text/html') {\n      uiLink = link;\n      break;\n    }\n  }\n\n  // Update the UI href\n  if (description.hasOwnProperty('uiHref') && description.uiHref) {\n    uiLink.href = description.uiHref;\n  } else if (description.hasOwnProperty('links')) {\n    for (const link of description.links) {\n      if (link.rel === 'alternate' &&\n          link.mediaType === 'text/html' &&\n          link.href.startsWith('http')) {\n        uiLink.href = link.href;\n        break;\n      }\n    }\n  }\n\n  // If the previously selected capability is no longer present, reset it.\n  if (this.selectedCapability &&\n      !this['@type'].includes(this.selectedCapability)) {\n    this.selectedCapability = '';\n  }\n\n  return Database.updateThing(this.id, this.getDescription());\n};\n\n/**\n * Set the connected state of this thing.\n *\n * @param {boolean} connected - Whether or not the thing is connected\n */\nThing.prototype.setConnected = function(connected) {\n  this.connected = connected;\n  this.emitter.emit(Constants.CONNECTED, connected);\n};\n\nmodule.exports = Thing;\n","/**\n * Things Model.\n *\n * Manages the data model and business logic for a collection of Things.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Thing = require('./thing.js');\nconst Database = require('../db.js');\nconst AddonManager = require('../addon-manager');\nconst Constants = require('../constants');\n\nconst Things = {\n\n  /**\n   * A Map of Things in the Things database.\n   */\n  things: new Map(),\n\n  /**\n   * A collection of open websockets listening for new things.\n   */\n  websockets: [],\n\n  /**\n   * The promise object returned by Database.getThings()\n   */\n  getThingsPromise: null,\n\n  /**\n   * Get all Things known to the Gateway, initially loading them from the\n   * database,\n   *\n   * @return {Promise} which resolves with a Map of Thing objects.\n   */\n  getThings: function() {\n    if (this.things.size > 0) {\n      return Promise.resolve(this.things);\n    }\n    if (this.getThingsPromise) {\n      // We're still waiting for the database request.\n      return this.getThingsPromise.then((things) => {\n        return things;\n      });\n    }\n    this.getThingsPromise = Database.getThings().then((things) => {\n      this.getThingsPromise = null;\n      // Update the map of Things\n      this.things = new Map();\n      things.forEach((thing) => {\n        this.things.set(thing.id, new Thing(thing.id, thing));\n      });\n      return this.things;\n    });\n    return this.getThingsPromise;\n  },\n\n  /**\n   * Get the names of all things.\n   *\n   * @return {Promise<Array>} which resolves with a list of all thing names.\n   */\n  getThingNames: function() {\n    return this.getThings().then(function(things) {\n      return Array.from(things.values()).map((t) => t.name);\n    });\n  },\n\n  /**\n   * Get Thing Descriptions for all Things stored in the database.\n   *\n   * @param {String} reqHost request host, if coming via HTTP\n   * @param {Boolean} reqSecure whether or not the request is secure, i.e. TLS\n   * @return {Promise} which resolves with a list of Thing Descriptions.\n   */\n  getThingDescriptions: function(reqHost, reqSecure) {\n    return this.getThings().then(function(things) {\n      const descriptions = [];\n      for (const thing of things.values()) {\n        descriptions.push(thing.getDescription(reqHost, reqSecure));\n      }\n      return descriptions;\n    });\n  },\n\n  /**\n   * Get a list of Things by their hrefs.\n   *\n   * {Array} hrefs hrefs of the list of Things to get.\n   * @return {Promise} A promise which resolves with a list of Things.\n   */\n  getListThings: function(hrefs) {\n    return this.getThings().then(function(things) {\n      const listThings = [];\n      for (const href of hrefs) {\n        things.forEach(function(thing) {\n          if (thing.href === href) {\n            listThings.push(thing);\n          }\n        });\n      }\n      return listThings;\n    });\n  },\n\n  /**\n   * Get Thing Descriptions for a list of Things by their hrefs.\n   *\n   * @param {Array} hrefs The hrefs of the list of Things to get\n   *                      descriptions of.\n   * @param {String} reqHost request host, if coming via HTTP.\n   * @param {Boolean} reqSecure whether or not the request is secure, i.e. TLS.\n   * @return {Promise} which resolves with a list of Thing Descriptions.\n   */\n  getListThingDescriptions: function(hrefs, reqHost, reqSecure) {\n    return this.getListThings(hrefs).then(function(listThings) {\n      const descriptions = [];\n      for (const thing of listThings) {\n        descriptions.push(thing.getDescription(reqHost, reqSecure));\n      }\n      return descriptions;\n    });\n  },\n\n  /**\n   * Get a list of things which are connected to adapters but not yet saved\n   * in the gateway database.\n   *\n   * @returns Promise A promise which resolves with a list of Things.\n   */\n  getNewThings: function() {\n    // Get a map of things in the database\n    return this.getThings().then((function(storedThings) {\n      // Get a list of things connected to adapters\n      const connectedThings = AddonManager.getThings();\n      const newThings = [];\n      connectedThings.forEach(function(connectedThing) {\n        if (!storedThings.has(connectedThing.id)) {\n          connectedThing.href =\n           `${Constants.THINGS_PATH}/${connectedThing.id}`;\n          if (connectedThing.properties) {\n            for (const propertyName in connectedThing.properties) {\n              const property = connectedThing.properties[propertyName];\n              property.href = `${Constants.THINGS_PATH\n              }/${connectedThing.id\n              }${Constants.PROPERTIES_PATH}/${propertyName}`;\n            }\n          }\n          newThings.push(connectedThing);\n        }\n      });\n      return newThings;\n    }));\n  },\n\n  /**\n   * Create a new Thing with the given ID and description.\n   *\n   * @param String id ID to give Thing.\n   * @param Object description Thing description.\n   */\n  createThing: function(id, description) {\n    const thing = new Thing(id, description);\n    thing.connected = true;\n\n    return Database.createThing(thing.id, thing.getDescription())\n      .then(function(thingDesc) {\n        this.things.set(thing.id, thing);\n        return thingDesc;\n      }.bind(this));\n  },\n\n  /**\n   * Handle a new Thing having been discovered.\n   *\n   * @param {Object} newThing - New Thing description\n   */\n  handleNewThing: function(newThing) {\n    this.getThing(newThing.id).then((thing) => {\n      thing.setConnected(true);\n      return thing.updateFromDescription(newThing);\n    }).catch(() => {\n      // If we don't already know about this thing, notify each open websocket\n      this.websockets.forEach(function(socket) {\n        socket.send(JSON.stringify(newThing));\n      });\n    });\n  },\n\n  /**\n   * Handle a thing being removed by an adapter.\n   *\n   * @param {Object} thing - Thing which was removed\n   */\n  handleThingRemoved: function(thing) {\n    this.getThing(thing.id).then((thing) => {\n      thing.setConnected(false);\n    }).catch(() => {});\n  },\n\n  /**\n   * Handle a thing's connectivity state change.\n   *\n   * @param {string} thingId - ID of thing\n   * @param {boolean} connected - New connectivity state\n   */\n  handleConnected: function(thingId, connected) {\n    this.getThing(thingId).then((thing) => {\n      thing.setConnected(connected);\n    }).catch(() => {});\n  },\n\n  /**\n   * Add a websocket to the list of new Thing subscribers.\n   *\n   * @param {Websocket} websocket A websocket instance.\n   */\n  registerWebsocket: function(websocket) {\n    this.websockets.push(websocket);\n    websocket.on('close', () => {\n      const index = this.websockets.indexOf(websocket);\n      this.websockets.splice(index, 1);\n    });\n  },\n\n  /**\n   * Get a Thing by its ID.\n   *\n   * @param {String} id The ID of the Thing to get.\n   * @return {Promise<Thing>} A Thing object.\n   */\n  getThing: function(id) {\n    return this.getThings().then(function(things) {\n      if (things.has(id)) {\n        return things.get(id);\n      } else {\n        throw new Error(`Unable to find thing with id: ${id}`);\n      }\n    });\n  },\n\n  /**\n   * Get a Thing by its name.\n   *\n   * @param {String} name The name of the Thing to get.\n   * @return {Promise<Thing>} A Thing object.\n   */\n  getThingByName: function(name) {\n    name = name.toLowerCase();\n\n    return this.getThings().then(function(things) {\n      for (const thing of things.values()) {\n        if (thing.name.toLowerCase() === name) {\n          return thing;\n        }\n      }\n\n      throw new Error(`Unable to find thing with name: ${name}`);\n    });\n  },\n\n  /**\n   * Get a Thing description for a thing by its ID.\n   *\n   * @param {String} id The ID of the Thing to get a description of.\n   * @param {String} reqHost request host, if coming via HTTP\n   * @param {Boolean} reqSecure whether or not the request is secure, i.e. TLS\n   * @return {Promise<ThingDescription>} A Thing description object.\n   */\n  getThingDescription: function(id, reqHost, reqSecure) {\n    return this.getThing(id).then((thing) => {\n      return thing.getDescription(reqHost, reqSecure);\n    });\n  },\n\n  /**\n   * Remove a Thing.\n   *\n   * @param String id ID to give Thing.\n   */\n  removeThing: function(id) {\n    return Database.removeThing(id).then(() => {\n      const thing = this.things.get(id);\n      if (!thing) {\n        return;\n      }\n      thing.remove();\n      this.things.delete(id);\n    });\n  },\n\n  clearState: function() {\n    this.websockets = [];\n    this.things = new Map();\n  },\n};\n\nAddonManager.on(Constants.THING_ADDED, (thing) => {\n  Things.handleNewThing(thing);\n});\n\nAddonManager.on(Constants.THING_REMOVED, (thing) => {\n  Things.handleThingRemoved(thing);\n});\n\nAddonManager.on(Constants.CONNECTED, ({device, connected}) => {\n  Things.handleConnected(device.id, connected);\n});\n\nmodule.exports = Things;\n","/**\n * User Model.\n *\n * Represents a user.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Passwords = require('../passwords');\n\nconst User = function(id, email, password, name) {\n  this.id = id;\n  this.email = email;\n  this.password = password; // Hashed\n  this.name = name;\n};\n\nUser.generate = async function(email, rawPassword, name) {\n  const hash = await Passwords.hash(rawPassword);\n  return new User(null, email, hash, name);\n};\n\n/**\n * Get a JSON description for this user.\n *\n * @return {Object} JSON description of user.\n */\nUser.prototype.getDescription = function() {\n  return {\n    id: this.id,\n    email: this.email,\n    name: this.name,\n  };\n};\n\nmodule.exports = User;\n","/**\n * User Manager.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst User = require('./user.js');\nconst Database = require('../db.js');\n\nconst Users = {\n  /**\n   * Get a user from the database.\n   *\n   * @param {String} email Email address of user to look up.\n   * @return {Promise} Promise which resolves to user object\n   *   or false if user doesn't exist.\n   */\n  getUser: function(email) {\n    return Database.getUser(email).then((result) => {\n      if (!result) {\n        return false;\n      }\n      return new User(result.id, result.email, result.password, result.name);\n    });\n  },\n\n  getCount: function() {\n    return Database.getUserCount();\n  },\n\n  /**\n   * Get a user from the database.\n   *\n   * @param {number} id primary key.\n   * @return {Promise} Promise which resolves to user object\n   *   or false if user doesn't exist.\n   */\n  getUserById: async function(id) {\n    if (typeof id !== 'number') {\n      id = parseInt(id, 10);\n      if (isNaN(id)) {\n        return Promise.reject('Invalid user ID');\n      }\n    }\n\n    const row = await Database.getUserById(id);\n    if (!row) {\n      return row;\n    }\n    return new User(row.id, row.email, row.password, row.name);\n  },\n\n  /**\n   * Get all Users stored in the database\n   * @return {Promise<Array<User>>}\n   */\n  getUsers: function() {\n    return Database.getUsers().then((userRows) => {\n      return userRows.map((row) => {\n        return new User(row.id, row.email, row.password, row.name);\n      });\n    });\n  },\n\n  /**\n   * Create a new User\n   * @param {String} email\n   * @param {String} password\n   * @param {String?} name - optional name of user\n   * @return {User} user object.\n   */\n  createUser: async function(email, password, name) {\n    const user = new User(null, email.toLowerCase(), password, name);\n    user.id = await Database.createUser(user);\n    return user;\n  },\n\n  /**\n   * Edit an existing User\n   * @param {User} user to edit\n   * @return {Promise} Promise which resolves when operation is complete.\n   */\n  editUser: async function(user) {\n    user.email = user.email.toLowerCase();\n    await Database.editUser(user);\n  },\n\n  /**\n   * Delete an existing User\n   * @param {Number} userId\n   * @return {Promise} Promise which resolves when operation is complete.\n   */\n  deleteUser: async function(userId) {\n    if (typeof userId !== 'number') {\n      userId = parseInt(userId, 10);\n      if (isNaN(userId)) {\n        return Promise.reject('Invalid user ID');\n      }\n    }\n\n    await Database.deleteUser(userId);\n  },\n};\n\nmodule.exports = Users;\n","import { URL } from 'url';\nimport * as Constants from './constants';\n\ntype Read = 'read';\ntype ReadWrite = 'readwrite';\nexport type ScopeAccess = Read|ReadWrite;\nexport type Scope = {[path: string]: ScopeAccess};\n\nexport type ScopeRaw = string;\nexport type ClientId = string;\n\nexport class ClientRegistry {\n  constructor(public redirect_uri: URL, public id: ClientId, public name: string,\n              public secret: string, public scope: ScopeRaw) {\n  }\n\n  getDescription() {\n    return {\n      id: this.id,\n      name: this.name,\n      redirect_uri: this.redirect_uri,\n      scope: this.scope\n    };\n  }\n}\n\nfunction stringToScope(scopeRaw: ScopeRaw): Scope {\n  let scope: Scope = {};\n  let scopeParts = scopeRaw.split(' ');\n  for (let scopePart of scopeParts) {\n    let parts = scopePart.split(':');\n    let path = parts[0];\n    let readwrite = parts[1];\n    if (readwrite !== 'read' && readwrite !== 'readwrite') {\n      readwrite = 'read';\n    }\n    scope[path] = readwrite as 'read'|'readwrite';\n  }\n\n  return scope;\n}\n\nexport function scopeValidSubset(clientScopeRaw: ScopeRaw, requestScopeRaw: ScopeRaw): boolean {\n  if (clientScopeRaw === requestScopeRaw) {\n    return true;\n  }\n  let clientScope = stringToScope(clientScopeRaw);\n  let requestScope = stringToScope(requestScopeRaw);\n\n  if (!clientScope || !requestScope) {\n    return false;\n  }\n\n  for (let requestPath in requestScope) {\n    if (!requestPath.startsWith(Constants.THINGS_PATH)) {\n      console.warn('Invalid request for out-of-bounds scope', requestScopeRaw);\n      return false;\n    }\n    let requestAccess = requestScope[requestPath];\n    let access: ScopeAccess|undefined;\n    if (clientScope[requestPath]) {\n      access = clientScope[requestPath];\n    } else {\n      access = clientScope[Constants.THINGS_PATH];\n    }\n\n    if (!access) {\n      return false;\n    }\n\n    if (requestAccess === 'readwrite') {\n      if (access !== 'readwrite') {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n","/**\n * Password utilities.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nconst bcrypt = require('bcryptjs');\nconst config = require('config');\n\nlet rounds;\nif (config.has('bcryptRounds')) {\n  rounds = config.get('bcryptRounds');\n}\n\nmodule.exports = {\n  /**\n   * Hash a password asynchronously\n   * @param {String} password\n   * @return {Promise<String>} hashed password\n   */\n  hash: function(password) {\n    return bcrypt.hash(password, rounds);\n  },\n\n  /**\n   * Hash a password synchronously.\n   * WARNING: This will block for a very long time\n   *\n   * @param {String} password\n   * @return {String} hashed password\n   */\n  hashSync: function(password) {\n    return bcrypt.hashSync(password, rounds);\n  },\n\n  /**\n   * Compare two password hashes asynchronously\n   * @param {String} passwordText - a plain text password\n   * @param {String} passwordHash - the expected hash\n   * @return {Promise<boolean>} If the hashes are equal\n   */\n  compare: function(passwordText, passwordHash) {\n    return bcrypt.compare(passwordText, passwordHash);\n  },\n\n  /**\n   * Compare two password hashes\n   * @param {String} passwordText - a plain text password\n   * @param {String} passwordHash - the expected hash\n   * @return {boolean} If the hashes are equal\n   */\n  compareSync: function(passwordText, passwordHash) {\n    return bcrypt.compareSync(passwordText, passwordHash);\n  },\n};\n","/**\n * Platform-specific utilities.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nconst child_process = require('child_process');\nconst fs = require('fs');\nconst process = require('process');\n\n/**\n * Get the current architecture as \"os-machine\", i.e. darwin-x64.\n */\nfunction getArchitecture() {\n  return `${process.platform}-${process.arch}`;\n}\n\n/**\n * Get the current node version.\n */\nfunction getNodeVersion() {\n  return process.config.variables.node_module_version;\n}\n\n/**\n * Get a list of installed Python versions.\n */\nfunction getPythonVersions() {\n  const versions = new Set();\n  const parse = (output) => {\n    const parts = output.split(' ');\n    if (parts.length === 2) {\n      const match = parts[1].match(/^\\d+\\.\\d+/);\n      if (match) {\n        versions.add(match[0]);\n      }\n    }\n  };\n\n  for (const bin of ['python', 'python2', 'python3']) {\n    const proc = child_process.spawnSync(\n      bin,\n      ['--version'],\n      {encoding: 'utf8'}\n    );\n\n    if (proc.status === 0) {\n      const output = proc.stdout || proc.stderr;\n      parse(output);\n    }\n  }\n\n  return Array.from(versions).sort();\n}\n\n/**\n * Determine whether or not the SSH toggle is implemented.\n *\n * @return {Boolean} indicating implementation status\n */\nfunction isToggleSshImplemented() {\n  return isRaspberryPi();\n}\n\n/**\n * Determine whether or not SSH is enabled.\n *\n * @return {Boolean} indicating enablement status\n */\nfunction isSshEnabled() {\n  if (isRaspberryPi()) {\n    const proc = child_process.spawnSync(\n      'sudo', ['raspi-config', 'nonint', 'get_ssh']);\n\n    if (proc.status !== 0) {\n      return false;\n    }\n\n    return proc.stdout.toString().trim() === '0';\n  }\n\n  return false;\n}\n\n/**\n * Enable/disable SSH, if possible.\n *\n * @param {Boolean} enable Whether or not SSH should be enabled.\n * @return {Boolean} indicating success\n */\nfunction toggleSsh(enable) {\n  if (isRaspberryPi()) {\n    let arg = '1';\n    if (enable) {\n      arg = '0';\n    }\n\n    const proc = child_process.spawnSync(\n      'sudo', ['raspi-config', 'nonint', 'do_ssh', arg]);\n    return proc.status === 0;\n  }\n\n  return false;\n}\n\n/**\n * Enable/disable the system's mDNS server, if possible.\n *\n * @param {Boolean} enable Whether or not mDNS should be enabled.\n * @return {Boolean} indicating success\n */\nfunction togglemDns(enable) {\n  if (isRaspberryPi()) {\n    const command = enable ? 'start' : 'stop';\n    const proc = child_process.spawnSync(\n      'sudo', ['systemctl', command, 'avahi-daemon.service']);\n    return proc.status === 0;\n  }\n\n  return false;\n}\n\n/**\n * Set the system's hostname, if possible.\n *\n * @param {String} hostname The hostname to set\n * @returns {Boolean} indicating success\n */\nfunction setHostname(hostname) {\n  hostname = hostname.toLowerCase();\n  const re = new RegExp(/^([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/);\n  const valid = re.test(hostname) && hostname.length <= 63;\n  if (!valid) {\n    return false;\n  }\n\n  if (isRaspberryPi()) {\n    // Read in the current hostname\n    let original = fs.readFileSync('/etc/hostname', 'utf8');\n    if (original) {\n      original = original.trim();\n    }\n\n    // Do this with sed, as it's the easiest way to write the file as root.\n    let proc = child_process.spawnSync(\n      'sudo', ['sed', '-i', '-e', `s/^.*$/${hostname}/`, '/etc/hostname']);\n    if (proc.status !== 0) {\n      return false;\n    }\n\n    proc = child_process.spawnSync('sudo', ['hostname', hostname]);\n    if (proc.status !== 0) {\n      // Set the original hostname back\n      child_process.spawnSync(\n        'sudo', ['sed', '-i', '-e', `s/^.*$/${original}/`, '/etc/hostname']);\n\n      return false;\n    }\n\n    proc = child_process.spawnSync(\n      'sudo', ['systemctl', 'restart', 'avahi-daemon.service']);\n    if (proc.status !== 0) {\n      // Set the original hostname back\n      child_process.spawnSync(\n        'sudo', ['sed', '-i', '-e', `s/^.*$/${original}/`, '/etc/hostname']);\n      child_process.spawnSync('sudo', ['hostname', original]);\n\n      return false;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Determine whether or not gateway restart is implemented.\n *\n * @return {Boolean} indicating implementation status\n */\nfunction isRestartGatewayImplemented() {\n  return isRaspberryPi();\n}\n\n/**\n * Restart the gateway process.\n *\n * @return {Boolean} indicating success\n */\nfunction restartGateway() {\n  if (isRaspberryPi()) {\n    const proc = child_process.spawnSync(\n      'sudo', ['systemctl', 'restart', 'mozilla-iot-gateway.service']);\n\n    // This will probably not fire, but just in case.\n    return proc.status === 0;\n  }\n\n  return false;\n}\n\n/**\n * Determine whether or not system restart is implemented.\n *\n * @return {Boolean} indicating implementation status\n */\nfunction isRestartSystemImplemented() {\n  return isRaspberryPi();\n}\n\n/**\n * Restart the system.\n *\n * @return {Boolean} indicating success\n */\nfunction restartSystem() {\n  if (isRaspberryPi()) {\n    const proc = child_process.spawnSync('sudo', ['reboot']);\n\n    // This will probably not fire, but just in case.\n    return proc.status === 0;\n  }\n\n  return false;\n}\n\n/**\n * Determine whether or not we're running on the Raspberry Pi.\n */\nfunction isRaspberryPi() {\n  const proc = child_process.spawnSync('lsb_release', ['-i', '-s']);\n  return proc.status === 0 && proc.stdout.toString().trim() === 'Raspbian';\n}\n\nmodule.exports = {\n  getArchitecture,\n  getNodeVersion,\n  getPythonVersions,\n  isToggleSshImplemented,\n  isSshEnabled,\n  toggleSsh,\n  togglemDns,\n  setHostname,\n  isRestartGatewayImplemented,\n  restartGateway,\n  isRestartSystemImplemented,\n  restartSystem,\n  isRaspberryPi,\n};\n","/**\n * @module AdapterProxy base class.\n *\n * Manages Adapter data model and business logic.\n */\n/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\n'use strict';\n\nconst {Adapter} = require('gateway-addon');\nconst Constants = require('../constants');\nconst Deferred = require('../deferred');\nconst DeviceProxy = require('./device-proxy');\n\nconst DEBUG = false;\n\n/**\n * Class used to describe an adapter from the perspective\n * of the gateway.\n */\nclass AdapterProxy extends Adapter {\n\n  constructor(addonManager, adapterId, name, packageName, plugin) {\n    super(addonManager, adapterId, packageName);\n    this.name = name;\n    this.plugin = plugin;\n    this.deferredMock = null;\n    this.unloadCompletedPromise = null;\n  }\n\n  startPairing(timeoutSeconds) {\n    DEBUG && console.log('AdapterProxy: startPairing',\n                         this.name, 'id', this.id);\n    this.sendMsg(Constants.START_PAIRING, {timeout: timeoutSeconds});\n  }\n\n  cancelPairing() {\n    DEBUG && console.log('AdapterProxy: cancelPairing',\n                         this.name, 'id', this.id);\n    this.sendMsg(Constants.CANCEL_PAIRING, {});\n  }\n\n  removeThing(device) {\n    DEBUG && console.log('AdapterProxy:', this.name, 'id', this.id,\n                         'removeThing:', device.id);\n    this.sendMsg(Constants.REMOVE_THING, {deviceId: device.id});\n  }\n\n  cancelRemoveThing(device) {\n    DEBUG && console.log('AdapterProxy:', this.name, 'id', this.id,\n                         'cancelRemoveThing:', device.id);\n    this.sendMsg(Constants.CANCEL_REMOVE_THING, {deviceId: device.id});\n  }\n\n  sendMsg(methodType, data, deferred) {\n    data.adapterId = this.id;\n    return this.plugin.sendMsg(methodType, data, deferred);\n  }\n\n  /**\n   * Unloads an adapter.\n   *\n   * @returns a promise which resolves when the adapter has\n   *          finished unloading.\n   */\n  unload() {\n    if (this.unloadCompletedPromise) {\n      console.error('AdapterProxy: unload already in progress');\n      return Promise.reject();\n    }\n    this.unloadCompletedPromise = new Deferred();\n    this.sendMsg(Constants.UNLOAD_ADAPTER, {\n      adapterId: this.id,\n    });\n    return this.unloadCompletedPromise.promise;\n  }\n\n  /**\n   * Set the PIN for the given device.\n   *\n   * @param {String} deviceId ID of the device\n   * @param {String} pin PIN to set\n   *\n   * @returns a promise which resolves when the PIN has been set.\n   */\n  setPin(deviceId, pin) {\n    return new Promise((resolve, reject) => {\n      console.log('AdapterProxy: setPin:', pin, 'for:', deviceId);\n\n      const device = this.getDevice(deviceId);\n      if (!device) {\n        reject('Device not found');\n        return;\n      }\n\n      const deferredSet = new Deferred();\n\n      deferredSet.promise.then((device) => {\n        resolve(device);\n      }).catch(() => {\n        reject();\n      });\n\n      this.sendMsg(Constants.SET_PIN, {deviceId, pin}, deferredSet);\n    });\n  }\n\n  // The following methods are added to support using the\n  // MockAdapter as a plugin.\n\n  clearState() {\n    if (this.deferredMock) {\n      const err = 'clearState: deferredMock already in progress';\n      console.error(err);\n      return Promise.reject(err);\n    }\n    this.deferredMock = new Deferred();\n    this.sendMsg(Constants.CLEAR_MOCK_ADAPTER_STATE, {\n      adapterId: this.id,\n    });\n    return this.deferredMock.promise;\n  }\n\n  addDevice(deviceId, deviceDescription) {\n    if (this.deferredMock) {\n      const err = 'addDevice: deferredMock already in progress';\n      console.error(err);\n      return Promise.reject(err);\n    }\n\n    // For the MockDevice we create the device now, so that we can\n    // deliver the propertyChanged notifications that show up before\n    // the handleDeviceAdded notification comes in. The device we\n    // create now will be replaced when the handleDeviceAdded\n    // notification shows up.\n\n    this.devices[deviceId] = new DeviceProxy(this, deviceDescription);\n\n    this.deferredMock = new Deferred();\n    this.sendMsg(Constants.ADD_MOCK_DEVICE, {\n      deviceId: deviceId,\n      deviceDescr: deviceDescription,\n    });\n    return this.deferredMock.promise;\n  }\n\n  removeDevice(deviceId) {\n    if (this.deferredMock) {\n      const err = 'removeDevice: deferredMock already in progress';\n      console.error(err);\n      return Promise.reject(err);\n    }\n    this.deferredMock = new Deferred();\n\n    // We need the actual device object when we resolve the promise\n    // so we stash it here since it gets removed under our feet.\n    this.deferredMock.device = this.getDevice(deviceId);\n    this.sendMsg(Constants.REMOVE_MOCK_DEVICE, {\n      deviceId: deviceId,\n    });\n    return this.deferredMock.promise;\n  }\n\n  pairDevice(deviceId, deviceDescription) {\n    this.sendMsg(Constants.PAIR_MOCK_DEVICE, {\n      deviceId: deviceId,\n      deviceDescr: deviceDescription,\n    });\n  }\n\n  unpairDevice(deviceId) {\n    this.sendMsg(Constants.UNPAIR_MOCK_DEVICE, {\n      deviceId: deviceId,\n    });\n  }\n}\n\nmodule.exports = AdapterProxy;\n","/**\n * Proxy version of AddonManager used by plugins.\n *\n * @module AddonManagerProxy\n */\n/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\n'use strict';\n\nconst config = require('config');\nconst Constants = require('../constants');\nconst EventEmitter = require('events').EventEmitter;\n\nconst DEBUG = false;\n\nclass AddonManagerProxy extends EventEmitter {\n  constructor(pluginClient) {\n    super();\n\n    this.adapters = new Map();\n    this.pluginClient = pluginClient;\n\n    this.on(Constants.PROPERTY_CHANGED, (property) => {\n      DEBUG && console.log('AddonManagerProxy: Got',\n                           Constants.PROPERTY_CHANGED, 'notification for',\n                           property.name, 'value:', property.value);\n      this.sendPropertyChangedNotification(property);\n    });\n\n    this.on(Constants.ACTION_STATUS, (action) => {\n      DEBUG && console.log('AddonManagerProxy: Got',\n                           Constants.ACTION_STATUS, 'notification for',\n                           action.name, 'status:', action.status);\n      this.sendActionStatusNotification(action);\n    });\n\n    this.on(Constants.EVENT, (event) => {\n      DEBUG && console.log('AddonManagerProxy: Got',\n                           Constants.EVENT, 'notification for', event.name);\n      this.sendEventNotification(event);\n    });\n\n    this.on(Constants.CONNECTED, ({device, connected}) => {\n      DEBUG && console.log('AddonManagerProxy: Got',\n                           Constants.CONNECTED, 'notification for',\n                           device.name);\n      this.sendConnectedNotification(device, connected);\n    });\n  }\n\n  /**\n   * @method addAdapter\n   *\n   * Adds an adapter to the collection of adapters managed by AddonManager.\n   */\n  addAdapter(adapter) {\n    const adapterId = adapter.id;\n    DEBUG && console.log('AddonManagerProxy: addAdapter:', adapterId);\n\n    this.adapters.set(adapterId, adapter);\n    this.pluginClient.sendNotification(Constants.ADD_ADAPTER, {\n      adapterId: adapter.getId(),\n      name: adapter.getName(),\n      packageName: adapter.getPackageName(),\n    });\n  }\n\n  /**\n   * @method handleDeviceAdded\n   *\n   * Called when the indicated device has been added to an adapter.\n   */\n  handleDeviceAdded(device) {\n    DEBUG && console.log('AddonManagerProxy: handleDeviceAdded:', device.id);\n    const deviceDict = device.asDict();\n    deviceDict.adapterId = device.adapter.id;\n    this.pluginClient.sendNotification(\n      Constants.HANDLE_DEVICE_ADDED, deviceDict);\n  }\n\n  /**\n   * @method handleDeviceRemoved\n   * Called when the indicated device has been removed an adapter.\n   */\n  handleDeviceRemoved(device) {\n    DEBUG && console.log('AddonManagerProxy: handleDeviceRemoved:',\n                         device.id);\n    this.pluginClient.sendNotification(\n      Constants.HANDLE_DEVICE_REMOVED, {\n        adapterId: device.adapter.id,\n        id: device.id,\n      });\n  }\n\n  /**\n   * @method onMsg\n   * Called whenever a message is received from the gateway.\n   */\n  onMsg(msg) {\n    DEBUG && console.log('AddonManagerProxy: Rcvd:', msg);\n\n    // The first switch covers unload plugin.\n    switch (msg.messageType) {\n      case Constants.UNLOAD_PLUGIN:\n        this.unloadPlugin();\n        return;\n    }\n\n    // The second switch covers adapter messages. i.e. don't have a deviceId.\n    // or don't need a device object.\n\n    const adapterId = msg.data.adapterId;\n    const adapter = this.adapters.get(adapterId);\n    if (!adapter) {\n      console.error('AddonManagerProxy: Unrecognized adapter:', adapterId);\n      console.error('AddonManagerProxy: Ignoring msg:', msg);\n      return;\n    }\n\n    switch (msg.messageType) {\n\n      case Constants.START_PAIRING:\n        adapter.startPairing(msg.data.timeout);\n        return;\n\n      case Constants.CANCEL_PAIRING:\n        adapter.cancelPairing();\n        return;\n\n      case Constants.UNLOAD_ADAPTER:\n        adapter.unload().then(() => {\n          this.adapters.delete(adapterId);\n          this.pluginClient.sendNotification(Constants.ADAPTER_UNLOADED, {\n            adapterId: adapter.id,\n          });\n        });\n        return;\n\n      case Constants.CLEAR_MOCK_ADAPTER_STATE:\n        adapter.clearState().then(() => {\n          this.pluginClient.sendNotification(\n            Constants.MOCK_ADAPTER_STATE_CLEARED, {\n              adapterId: adapter.id,\n            });\n        });\n        return;\n\n      case Constants.ADD_MOCK_DEVICE:\n        adapter.addDevice(msg.data.deviceId, msg.data.deviceDescr)\n          .then((device) => {\n            this.pluginClient.sendNotification(\n              Constants.MOCK_DEVICE_ADDED_REMOVED, {\n                adapterId: adapter.id,\n                deviceId: device.id,\n              });\n          }).catch((err) => {\n            this.pluginClient.sendNotification(\n              Constants.MOCK_DEVICE_ADD_REMOVE_FAILED, {\n                adapterId: adapter.id,\n                error: err,\n              });\n          });\n        return;\n\n      case Constants.REMOVE_MOCK_DEVICE:\n        adapter.removeDevice(msg.data.deviceId)\n          .then((device) => {\n            this.pluginClient.sendNotification(\n              Constants.MOCK_DEVICE_ADDED_REMOVED, {\n                adapterId: adapter.id,\n                deviceId: device.id,\n              });\n          }).catch((err) => {\n            this.pluginClient.sendNotification(\n              Constants.MOCK_DEVICE_ADD_REMOVE_FAILED, {\n                adapterId: adapter.id,\n                error: err,\n              });\n          });\n        return;\n\n      case Constants.PAIR_MOCK_DEVICE:\n        adapter.pairDevice(msg.data.deviceId, msg.data.deviceDescr);\n        return;\n\n      case Constants.UNPAIR_MOCK_DEVICE:\n        adapter.unpairDevice(msg.data.deviceId);\n        return;\n\n    }\n\n    // All messages from here on are assumed to require a valid deviceId.\n\n    const deviceId = msg.data.deviceId;\n    const device = adapter.getDevice(deviceId);\n    if (!device) {\n      console.error('AddonManagerProxy: No such device:', deviceId);\n      console.error('AddonManagerProxy: Ignoring msg:', msg);\n      return;\n    }\n\n    switch (msg.messageType) {\n\n      case Constants.REMOVE_THING:\n        adapter.removeThing(device);\n        break;\n\n      case Constants.CANCEL_REMOVE_THING:\n        adapter.cancelRemoveThing(device);\n        break;\n\n      case Constants.SET_PROPERTY: {\n        const propertyName = msg.data.propertyName;\n        const propertyValue = msg.data.propertyValue;\n        const property = device.findProperty(propertyName);\n        if (property) {\n          property.setValue(propertyValue).then((_updatedValue) => {\n            if (property.fireAndForget) {\n              // This property doesn't send propertyChanged notifications,\n              // so we fake one.\n              this.sendPropertyChangedNotification(property);\n            } else {\n              // We should get a propertyChanged notification thru\n              // the normal channels, so don't sent another one here.\n              // We don't really need to do anything.\n            }\n          }).catch((err) => {\n            // Something bad happened. The gateway is still\n            // expecting a reply, so we report the error\n            // and just send whatever the current value is.\n            console.error('AddonManagerProxy: Failed to setProperty',\n                          propertyName, 'to', propertyValue,\n                          'for device:', deviceId);\n            console.error(err);\n            this.sendPropertyChangedNotification(property);\n          });\n        } else {\n          console.error('AddonManagerProxy: Unknown property:',\n                        propertyName);\n        }\n        break;\n      }\n      case Constants.REQUEST_ACTION: {\n        const actionName = msg.data.actionName;\n        const actionId = msg.data.actionId;\n        const input = msg.data.input;\n        device.requestAction(actionId, actionName, input)\n          .then(() => {\n            this.pluginClient.sendNotification(\n              Constants.REQUEST_ACTION_RESOLVED, {\n                actionName: actionName,\n                actionId: actionId,\n              });\n          }).catch((err) => {\n            console.error('AddonManagerProxy: Failed to request action',\n                          actionName, 'for device:', deviceId);\n            console.error(err);\n            this.pluginClient.sendNotification(\n              Constants.REQUEST_ACTION_REJECTED, {\n                actionName: actionName,\n                actionId: actionId,\n              });\n          });\n        break;\n      }\n      case Constants.REMOVE_ACTION: {\n        const actionName = msg.data.actionName;\n        const actionId = msg.data.actionId;\n        const messageId = msg.data.messageId;\n        device.removeAction(actionId, actionName)\n          .then(() => {\n            this.pluginClient.sendNotification(\n              Constants.REMOVE_ACTION_RESOLVED, {\n                actionName: actionName,\n                actionId: actionId,\n                messageId: messageId,\n              });\n          }).catch((err) => {\n            console.error('AddonManagerProxy: Failed to remove action',\n                          actionName, 'for device:', deviceId);\n            console.error(err);\n            this.pluginClient.sendNotification(\n              Constants.REMOVE_ACTION_REJECTED, {\n                actionName: actionName,\n                actionId: actionId,\n                messageId: messageId,\n              });\n          });\n        break;\n      }\n      case Constants.SET_PIN: {\n        const pin = msg.data.pin;\n        const messageId = msg.data.messageId;\n        adapter.setPin(deviceId, pin)\n          .then(() => {\n            const dev = adapter.getDevice(deviceId);\n            this.pluginClient.sendNotification(\n              Constants.SET_PIN_RESOLVED, {\n                device: dev.asDict(),\n                messageId: messageId,\n                adapterId: adapter.id,\n              });\n          }).catch((err) => {\n            console.error(\n              `AddonManagerProxy: Failed to set PIN for device ${deviceId}`);\n            console.error(err);\n\n            this.pluginClient.sendNotification(\n              Constants.SET_PIN_REJECTED, {\n                deviceId: deviceId,\n                messageId: messageId,\n              });\n          });\n        break;\n      }\n      case Constants.DEBUG_CMD:\n        device.debugCmd(msg.data.cmd, msg.data.params);\n        break;\n\n      default:\n        console.warn('AddonManagerProxy: unrecognized msg:', msg);\n        break;\n    }\n  }\n\n  /**\n   * @method sendPropertyChangedNotification\n   * Sends a propertyChanged notification to the gateway.\n   */\n  sendPropertyChangedNotification(property) {\n    this.pluginClient.sendNotification(Constants.PROPERTY_CHANGED, {\n      adapterId: property.device.adapter.id,\n      deviceId: property.device.id,\n      property: property.asDict(),\n    });\n  }\n\n  /**\n   * @method sendActionStatusNotification\n   * Sends an actionStatus notification to the gateway.\n   */\n  sendActionStatusNotification(action) {\n    this.pluginClient.sendNotification(Constants.ACTION_STATUS, {\n      adapterId: action.device.adapter.id,\n      deviceId: action.device.id,\n      action: action.asDict(),\n    });\n  }\n\n  /**\n   * @method sendEventNotification\n   * Sends an event notification to the gateway.\n   */\n  sendEventNotification(event) {\n    this.pluginClient.sendNotification(Constants.EVENT, {\n      adapterId: event.device.adapter.id,\n      deviceId: event.device.id,\n      event: event.asDict(),\n    });\n  }\n\n  /**\n   * @method sendConnectedNotification\n   * Sends a connected notification to the gateway.\n   */\n  sendConnectedNotification(device, connected) {\n    this.pluginClient.sendNotification(Constants.CONNECTED, {\n      adapterId: device.adapter.id,\n      deviceId: device.id,\n      connected,\n    });\n  }\n\n  /**\n   * @method unloadPlugin\n   *\n   * Unloads the plugin, and tells the server about it.\n   */\n  unloadPlugin() {\n    if (config.get('ipc.protocol') === 'inproc') {\n      // When we're testing, we run in the same process and we need\n      // to close the sockets before the adapter.unload promise is\n      // resolved. So we hook into the plugin unloadedRcvdPromise.\n\n      // NOTE: We need to put this require here rather than at the top\n      //       of the file because at the top of the file, otherwise we\n      //       have circular requires and the addonManager object won't\n      //       have been created yet.\n      const addonManager = require('../addon-manager');\n      // NOTE: The call to getPlugin will only succeed when doing\n      //       inproc IPC, since getPlugin reaches into server-side\n      //       data structures, and we're running on the client.\n      const plugin = addonManager.getPlugin(this.pluginClient.pluginId);\n      if (plugin && plugin.unloadedRcvdPromise) {\n        plugin.unloadedRcvdPromise.promise\n          .then((socketsClosedPromise) => {\n            this.pluginClient.unload();\n            socketsClosedPromise.resolve();\n          });\n      } else {\n        // Wait a small amount of time to allow the pluginUnloaded\n        // message to be processed by the server before closing.\n        setTimeout(() => {\n          this.pluginClient.unload();\n        }, 500);\n      }\n    } else {\n      // Wait a small amount of time to allow the pluginUnloaded\n      // message to be processed by the server before closing.\n      setTimeout(() => {\n        this.pluginClient.unload();\n      }, 500);\n    }\n    this.pluginClient.sendNotification(Constants.PLUGIN_UNLOADED, {});\n  }\n\n  sendError(message) {\n    this.pluginClient.sendNotification(Constants.PLUGIN_ERROR, {message});\n  }\n}\n\nmodule.exports = AddonManagerProxy;\n","/**\n * DeviceProxy - Gateway side representation of a device when using\n *               an adapter plugin.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\n'use strict';\n\nconst Actions = require('../models/actions');\nconst Constants = require('../constants');\nconst Event = require('../models/event');\nconst Events = require('../models/events');\nconst PropertyProxy = require('./property-proxy');\nconst {Device, Deferred} = require('gateway-addon');\n\nclass DeviceProxy extends Device {\n\n  constructor(adapter, deviceDict) {\n    super(adapter, deviceDict.id);\n\n    this.name = deviceDict.name;\n    this.type = deviceDict.type;\n    this['@context'] =\n      deviceDict['@context'] || 'https://iot.mozilla.org/schemas';\n    this['@type'] = deviceDict['@type'] || [];\n    this.description = deviceDict.description || '';\n    this.uiHref = deviceDict.uiHref || null;\n\n    if (deviceDict.hasOwnProperty('pin')) {\n      this.pinRequired = deviceDict.pin.required;\n      this.pinPattern = deviceDict.pin.pattern;\n    } else {\n      this.pinRequired = false;\n      this.pinPattern = null;\n    }\n\n    for (const propertyName in deviceDict.properties) {\n      const propertyDict = deviceDict.properties[propertyName];\n      const propertyProxy =\n        new PropertyProxy(this, propertyName, propertyDict);\n      this.properties.set(propertyName, propertyProxy);\n    }\n\n    // Copy over any extra device fields which might be useful for debugging.\n    this.deviceDict = {};\n    for (const field in deviceDict) {\n      if (['id', 'name', 'type', 'description', 'properties', 'actions',\n           'events', '@type', '@context'].includes(field)) {\n        continue;\n      }\n      this.deviceDict[field] = deviceDict[field];\n    }\n\n    if (deviceDict.actions) {\n      for (const actionName in deviceDict.actions) {\n        const dict = deviceDict.actions[actionName];\n        this.actions.set(actionName, dict);\n      }\n    }\n\n    if (deviceDict.events) {\n      for (const eventName in deviceDict.events) {\n        const dict = deviceDict.events[eventName];\n        this.events.set(eventName, dict);\n      }\n    }\n  }\n\n  asDict() {\n    return Object.assign({}, this.deviceDict, super.asDict());\n  }\n\n  debugCmd(cmd, params) {\n    this.adapter.sendMsg(\n      Constants.DEBUG_CMD, {\n        deviceId: this.id,\n        cmd: cmd,\n        params: params,\n      }\n    );\n  }\n\n  /**\n   * @method requestAction\n   */\n  requestAction(actionId, actionName, input) {\n    return new Promise((resolve, reject) => {\n      if (!this.actions.has(actionName)) {\n        reject(`Action \"${actionName}\" not found`);\n        return;\n      }\n\n      console.log('DeviceProxy: requestAction:', actionName,\n                  'for:', this.id);\n\n      const deferredSet = new Deferred();\n\n      deferredSet.promise.then(() => {\n        resolve();\n      }).catch(() => {\n        reject();\n      });\n\n      this.adapter.sendMsg(\n        Constants.REQUEST_ACTION, {\n          deviceId: this.id,\n          actionName,\n          actionId,\n          input,\n        }, deferredSet);\n    });\n  }\n\n  /**\n   * @method removeAction\n   */\n  removeAction(actionId, actionName) {\n    return new Promise((resolve, reject) => {\n      if (!this.actions.has(actionName)) {\n        reject(`Action \"${actionName}\" not found`);\n        return;\n      }\n\n      console.log('DeviceProxy: removeAction:', actionName,\n                  'for:', this.id);\n\n      const deferredSet = new Deferred();\n\n      deferredSet.promise.then(() => {\n        resolve();\n      }).catch(() => {\n        reject();\n      });\n\n      this.adapter.sendMsg(\n        Constants.REMOVE_ACTION, {\n          deviceId: this.id,\n          actionName,\n          actionId,\n        }, deferredSet);\n    });\n  }\n\n  actionNotify(action) {\n    const a = Actions.get(action.id);\n    if (a) {\n      a.update(action);\n    }\n  }\n\n  eventNotify(event) {\n    Events.add(new Event(event.name, event.data, this.id, event.timestamp));\n  }\n}\n\nmodule.exports = DeviceProxy;\n","'use strict';\n\nconst config = require('config');\nconst fs = require('fs');\nconst nanomsg = require('nanomsg');\n\nconst appInstance = require('../app-instance');\n\nconst DEBUG = false;\nconst DEBUG_MSG = false;\n\nconst boundAddrs = new Set();\nconst connectedAddrs = new Set();\nlet socketId = 0;\n\nclass IpcSocket {\n\n  constructor(name, socketType, ipcBaseAddr, onMsg) {\n    this.name = name;\n    this.socketType = socketType;\n    this.socket = nanomsg.socket(socketType);\n    this.ipcBaseAddr = ipcBaseAddr;\n    this.onMsg = onMsg;\n    socketId += 1;\n    this.socketId = socketId;\n\n    this.protocol = config.get('ipc.protocol');\n    switch (this.protocol) {\n      case 'ipc':\n        this.ipcFile = `/tmp/${ipcBaseAddr}`;\n        break;\n\n      case 'inproc':\n        this.ipcFile = `${appInstance.get()}-${\n          ipcBaseAddr}`;\n        break;\n\n      default: {\n        const err = `Unsupported IPC protocol: ${this.protocol}`;\n        console.error(err);\n        throw err;\n      }\n    }\n    this.ipcAddr = `${this.protocol}://${this.ipcFile}`;\n\n    this.logPrefix = `IpcSocket${(`${this.socketId}`).padStart(3)}: ${\n      this.name.padEnd(18)}:`;\n    DEBUG && this.log('  alloc', this.ipcAddr, socketType);\n\n    this.socket.on('data', this.onData.bind(this));\n    this.connected = false;\n    this.bound = false;\n  }\n\n  error() {\n    Array.prototype.unshift.call(arguments, this.logPrefix);\n    console.error.apply(null, arguments);\n  }\n\n  log() {\n    Array.prototype.unshift.call(arguments, this.logPrefix);\n    console.log.apply(null, arguments);\n  }\n\n  bind() {\n    DEBUG && this.log('   bind', this.ipcAddr);\n\n    if (this.bound) {\n      this.error('socket already bound:', this.ipcAddr);\n    }\n    if (this.connected) {\n      this.error('socket already connected:', this.ipcAddr);\n    }\n    this.bound = true;\n\n    if (this.socketType === 'pair') {\n      if (boundAddrs.has(this.ipcAddr)) {\n        this.error('address already bound:', this.ipcAddr);\n      }\n      boundAddrs.add(this.ipcAddr);\n    }\n\n    if (this.protocol === 'ipc') {\n      if (fs.existsSync(this.ipcFile)) {\n        fs.unlinkSync(this.ipcFile);\n      }\n    }\n    return this.socket.bind(this.ipcAddr);\n  }\n\n  connect() {\n    DEBUG && this.log('connect', this.ipcAddr);\n\n    if (this.bound) {\n      this.error('socket already bound:', this.ipcAddr);\n    }\n    if (this.connected) {\n      this.error('socket already connected:', this.ipcAddr);\n    }\n    this.connected = true;\n\n    if (this.socketType === 'pair') {\n      if (connectedAddrs.has(this.ipcAddr)) {\n        this.error('address already connected:', this.ipcAddr);\n      }\n      connectedAddrs.add(this.ipcAddr);\n    }\n\n    return this.socket.connect(this.ipcAddr);\n  }\n\n  close() {\n    DEBUG && this.log('  close', this.ipcAddr);\n    if (this.connected) {\n      this.connected = false;\n      if (this.socketType === 'pair') {\n        connectedAddrs.delete(this.ipcAddr);\n      }\n    } else if (this.bound) {\n      this.bound = false;\n      if (this.socketType === 'pair') {\n        boundAddrs.delete(this.ipcAddr);\n      }\n    } else {\n      this.error('socket not connected or bound:', this.ipcAddr);\n    }\n    this.socket.close();\n  }\n\n  /**\n   * @method onData\n   * @param {Buffer} buf\n   *\n   * Called anytime a new message has been received.\n   */\n  onData(buf) {\n    const bufStr = buf.toString();\n    let data;\n    try {\n      data = JSON.parse(bufStr);\n    } catch (err) {\n      this.error('Error parsing message as JSON');\n      this.error(`Rcvd: \"${bufStr}\"`);\n      this.error(err);\n      return;\n    }\n    DEBUG_MSG && this.log(this.name, 'Rcvd:', data);\n    this.onMsg(data);\n  }\n\n  /**\n   * @method sendJson\n   * @param {dict} obj\n   *\n   * Async function which will convert the passed object\n   * into json, send it and not wait for any type of reply.\n   */\n  sendJson(obj) {\n    const jsonObj = JSON.stringify(obj);\n    DEBUG_MSG && this.log(this.name, 'Sending:', jsonObj);\n    this.socket.send(jsonObj);\n  }\n}\n\nmodule.exports = IpcSocket;\n","/**\n * @module PluginClient\n *\n * Takes care of connecting to the gateway for an adapter plugin\n */\n/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\n'use strict';\n\nconst AddonManagerProxy = require('./addon-manager-proxy');\nconst Constants = require('../constants');\nconst Deferred = require('../deferred');\nconst EventEmitter = require('events');\nconst IpcSocket = require('./ipc');\n\nclass PluginClient extends EventEmitter {\n\n  constructor(pluginId, {verbose} = {}) {\n    super();\n    this.pluginId = pluginId;\n    this.verbose = verbose;\n    this.deferredReply = null;\n  }\n\n  onManagerMsg(msg) {\n    this.verbose &&\n      console.log('PluginClient: rcvd ManagerMsg:', msg);\n\n    if (!this.deferredReply) {\n      console.error('No deferredReply setup');\n      return;\n    }\n\n    if (msg.messageType === Constants.REGISTER_PLUGIN_REPLY) {\n      this.addonManager = new AddonManagerProxy(this);\n\n      // Now that we're registered with the server, open the plugin\n      // specific IPC channel with the server.\n      this.pluginIpcBaseAddr = msg.data.ipcBaseAddr;\n      this.pluginIpcSocket =\n        new IpcSocket('PluginClient', 'pair',\n                      this.pluginIpcBaseAddr,\n                      this.addonManager.onMsg.bind(this.addonManager));\n      this.pluginIpcSocket.connect(this.pluginIpcAddr);\n      this.verbose &&\n        console.log('PluginClient: registered with PluginServer:',\n                    this.pluginIpcSocket.ipcAddr);\n\n      const deferredReply = this.deferredReply;\n      this.deferredReply = null;\n      deferredReply.resolve(this.addonManager);\n    } else {\n      console.error('Unexpected registration reply for gateway');\n      console.error(msg);\n    }\n  }\n\n  register() {\n    if (this.deferredReply) {\n      console.error('Already waiting for registration reply');\n      return;\n    }\n    this.deferredReply = new Deferred();\n\n    this.managerIpcSocket =\n      new IpcSocket('PluginClientServer', 'req',\n                    'gateway.addonManager',\n                    this.onManagerMsg.bind(this));\n    this.managerIpcSocket.connect();\n\n    // Register ourselves with the server\n    this.verbose &&\n      console.log('Connected to server:', this.managerIpcSocket.ipcAddr,\n                  'registering...');\n\n    this.managerIpcSocket.sendJson({\n      messageType: Constants.REGISTER_PLUGIN,\n      data: {\n        pluginId: this.pluginId,\n      },\n    });\n\n    return this.deferredReply.promise;\n  }\n\n  sendNotification(methodType, data) {\n    data.pluginId = this.pluginId;\n    this.pluginIpcSocket.sendJson({\n      messageType: methodType,\n      data: data,\n    });\n  }\n\n  unload() {\n    this.pluginIpcSocket.close();\n    this.managerIpcSocket.close();\n    this.emit('unloaded', {});\n  }\n}\n\nmodule.exports = PluginClient;\n","/**\n * @module PluginServer\n *\n * Takes care of the gateway side of adapter plugins. There is\n * only a single instance of the PluginServer for the entire gateway.\n * There will be an AdapterProxy instance for each adapter plugin.\n */\n/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\n'use strict';\n\nconst Constants = require('../constants');\nconst EventEmitter = require('events');\nconst IpcSocket = require('./ipc');\nconst Plugin = require('./plugin');\n\nclass PluginServer extends EventEmitter {\n  constructor(addonManager, {verbose} = {}) {\n    super();\n    this.manager = addonManager;\n\n    this.verbose = verbose;\n    this.plugins = new Map();\n\n    this.ipcSocket = new IpcSocket('PluginServer', 'rep',\n                                   'gateway.addonManager',\n                                   this.onMsg.bind(this));\n    this.ipcSocket.bind();\n    this.verbose &&\n      console.log('Server bound to', this.ipcSocket.ipcAddr);\n  }\n\n  /**\n   * @method addAdapter\n   *\n   * Tells the adapter manager about new adapters added via a plugin.\n   */\n  addAdapter(adapter) {\n    this.manager.addAdapter(adapter);\n  }\n\n  /**\n   * @method onMsg\n   *\n   * Called when the plugin server receives an adapter manager IPC message\n   * from a plugin. This particular IPC channel is only used to register\n   * plugins. Each plugin will get its own IPC channel once its registered.\n   */\n  onMsg(msg) {\n    this.verbose &&\n      console.log('PluginServer: Rcvd:', msg);\n\n    switch (msg.messageType) {\n      case Constants.REGISTER_PLUGIN: {\n        const plugin = this.registerPlugin(msg.data.pluginId);\n        this.ipcSocket.sendJson({\n          messageType: Constants.REGISTER_PLUGIN_REPLY,\n          data: {\n            pluginId: msg.data.pluginId,\n            ipcBaseAddr: plugin.ipcBaseAddr,\n          },\n        });\n        break;\n      }\n    }\n  }\n\n  /**\n   * @method getPlugin\n   *\n   * Returns a previously loaded plugin instance.\n   */\n  getPlugin(pluginId) {\n    return this.plugins.get(pluginId);\n  }\n\n  /**\n   * @method loadPlugin\n   *\n   * Loads a plugin by launching a separate process.\n   */\n  loadPlugin(pluginPath, manifest) {\n    const plugin = this.registerPlugin(manifest.name);\n    plugin.exec = manifest.moziot.exec;\n    plugin.execPath = pluginPath;\n    plugin.start();\n  }\n\n  /**\n   * @method registerPlugin\n   *\n   * Called when the plugin server receives a register plugin message\n   * via IPC.\n   */\n  registerPlugin(pluginId) {\n    let plugin = this.plugins.get(pluginId);\n    if (plugin) {\n      // This is a plugin that we already know about.\n    } else {\n      // We haven't seen this plugin before.\n      plugin = new Plugin(pluginId, this);\n      this.plugins.set(pluginId, plugin);\n    }\n    return plugin;\n  }\n\n  /**\n   * @method unregisterPlugin\n   *\n   * Called when the plugin sends a plugin-unloaded message.\n   */\n  unregisterPlugin(pluginId) {\n    this.plugins.delete(pluginId);\n  }\n\n  shutdown() {\n    this.ipcSocket.close();\n  }\n}\n\nmodule.exports = PluginServer;\n","/**\n * @module Plugin\n *\n * Object created for each plugin that the gateway talks to.\n */\n/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\n'use strict';\n\nconst AdapterProxy = require('./adapter-proxy');\nconst config = require('config');\nconst Constants = require('../constants');\nconst Deferred = require('../deferred');\nconst DeviceProxy = require('./device-proxy');\nconst format = require('string-format');\nconst IpcSocket = require('./ipc');\nconst readline = require('readline');\nconst spawn = require('child_process').spawn;\nconst path = require('path');\nconst UserProfile = require('../user-profile');\n\nconst DEBUG = false;\n\nclass Plugin {\n\n  constructor(pluginId, pluginServer) {\n    this.pluginId = pluginId;\n    this.pluginServer = pluginServer;\n    this.logPrefix = pluginId.replace('-adapter', '');\n\n    this.adapters = new Map();\n    this.ipcBaseAddr = `gateway.plugin.${this.pluginId}`;\n\n    this.ipcSocket = new IpcSocket('AdapterProxy', 'pair',\n                                   this.ipcBaseAddr,\n                                   this.onMsg.bind(this));\n    this.ipcSocket.bind();\n    this.exec = '';\n    this.execPath = '.';\n\n    // Make this a nested object such that if the Plugin object is reused,\n    // i.e. the plugin is disabled and quickly re-enabled, the gateway process\n    // can maintain a proper reference to the process object.\n    this.process = {p: null};\n\n    this.restart = true;\n    this.unloadCompletedPromise = null;\n    this.unloadedRcvdPromise = null;\n\n    this.nextId = 0;\n    this.requestActionPromises = new Map();\n    this.removeActionPromises = new Map();\n    this.setPinPromises = new Map();\n  }\n\n  asDict() {\n    let pid = 'not running';\n    if (this.process.p) {\n      pid = this.process.p.pid;\n    }\n    return {\n      pluginId: this.pluginId,\n      ipcBaseAddr: this.ipcBaseAddr,\n      adapters: Array.from(this.adapters.values()).map((adapter) => {\n        return adapter.asDict();\n      }),\n      exec: this.exec,\n      pid: pid,\n    };\n  }\n\n  onMsg(msg) {\n    DEBUG && console.log('Plugin: Rcvd Msg', msg);\n\n    // The first switch manages action method resolved or rejected messages.\n    switch (msg.messageType) {\n      case Constants.REQUEST_ACTION_RESOLVED: {\n        const actionId = msg.data.actionId;\n        const deferred = this.requestActionPromises.get(actionId);\n        if (typeof actionId === 'undefined' ||\n            typeof deferred === 'undefined') {\n          console.error('Plugin:', this.pluginId,\n                        'Unrecognized action id:', actionId,\n                        'Ignoring msg:', msg);\n          return;\n        }\n        deferred.resolve();\n        this.requestActionPromises.delete(actionId);\n        return;\n      }\n      case Constants.REQUEST_ACTION_REJECTED: {\n        const actionId = msg.data.actionId;\n        const deferred = this.requestActionPromises.get(actionId);\n        if (typeof actionId === 'undefined' ||\n            typeof deferred === 'undefined') {\n          console.error('Plugin:', this.pluginId,\n                        'Unrecognized action id:', actionId,\n                        'Ignoring msg:', msg);\n          return;\n        }\n        deferred.reject();\n        this.requestActionPromises.delete(actionId);\n        return;\n      }\n      case Constants.REMOVE_ACTION_RESOLVED: {\n        const messageId = msg.data.messageId;\n        const deferred = this.removeActionPromises.get(messageId);\n        if (typeof messageId === 'undefined' ||\n            typeof deferred === 'undefined') {\n          console.error('Plugin:', this.pluginId,\n                        'Unrecognized message id:', messageId,\n                        'Ignoring msg:', msg);\n          return;\n        }\n        deferred.resolve();\n        this.removeActionPromises.delete(messageId);\n        return;\n      }\n      case Constants.REMOVE_ACTION_REJECTED: {\n        const messageId = msg.data.messageId;\n        const deferred = this.removeActionPromises.get(messageId);\n        if (typeof messageId === 'undefined' ||\n            typeof deferred === 'undefined') {\n          console.error('Plugin:', this.pluginId,\n                        'Unrecognized message id:', messageId,\n                        'Ignoring msg:', msg);\n          return;\n        }\n        deferred.reject();\n        this.removeActionPromises.delete(messageId);\n        return;\n      }\n      case Constants.SET_PIN_RESOLVED: {\n        const messageId = msg.data.messageId;\n        const deferred = this.setPinPromises.get(messageId);\n        if (typeof messageId === 'undefined' ||\n            typeof deferred === 'undefined') {\n          console.error('Plugin:', this.pluginId,\n                        'Unrecognized message id:', messageId,\n                        'Ignoring msg:', msg);\n          return;\n        }\n        const adapter = this.adapters.get(msg.data.adapterId);\n        const deviceId = msg.data.device.id;\n        const device = new DeviceProxy(adapter, msg.data.device);\n        adapter.devices[deviceId] = device;\n        adapter.manager.devices[deviceId] = device;\n        deferred.resolve(msg.data.device);\n        this.setPinPromises.delete(messageId);\n        return;\n      }\n      case Constants.SET_PIN_REJECTED: {\n        const messageId = msg.data.messageId;\n        const deferred = this.setPinPromises.get(messageId);\n        if (typeof messageId === 'undefined' ||\n            typeof deferred === 'undefined') {\n          console.error('Plugin:', this.pluginId,\n                        'Unrecognized message id:', messageId,\n                        'Ignoring msg:', msg);\n          return;\n        }\n        deferred.reject();\n        this.setPinPromises.delete(messageId);\n        return;\n      }\n    }\n\n    const adapterId = msg.data.adapterId;\n    let adapter;\n\n    // The second switch manages plugin level messages.\n    switch (msg.messageType) {\n      case Constants.ADD_ADAPTER:\n        adapter = new AdapterProxy(this.pluginServer.manager,\n                                   adapterId,\n                                   msg.data.name,\n                                   msg.data.packageName,\n                                   this);\n        this.adapters.set(adapterId, adapter);\n        this.pluginServer.addAdapter(adapter);\n        return;\n\n      case Constants.PLUGIN_UNLOADED:\n        this.shutdown();\n        this.pluginServer.unregisterPlugin(msg.data.pluginId);\n        if (this.unloadedRcvdPromise) {\n          const socketsClosedPromise = new Deferred();\n          if (config.get('ipc.protocol') === 'inproc') {\n            // In test mode we want to wait until the sockets are actually\n            // closed before we resolve the unloadCompletedPromise.\n            this.unloadedRcvdPromise.resolve(socketsClosedPromise);\n            this.unloadedRcvdPromise = null;\n          } else {\n            // For non-test mode, the plugin is out-of-process so there is no\n            // way for us to know when then sockets are closed. We won't try\n            // try to restart the plugin until it exits, so there isn't any\n            // problem with resolving the unloadCompletedPromise right away.\n            socketsClosedPromise.resolve();\n          }\n          socketsClosedPromise.promise.then(() => {\n            if (this.unloadCompletedPromise) {\n              this.unloadCompletedPromise.resolve();\n              this.unloadCompletedPromise = null;\n            }\n          });\n        }\n        return;\n\n      case Constants.PLUGIN_ERROR:\n        this.pluginServer.emit('log', {\n          severity: Constants.LogSeverity.ERROR,\n          message: msg.data.message,\n        });\n        return;\n    }\n\n    // The next switch deals with adapter level messages\n\n    adapter = this.adapters.get(adapterId);\n    if (!adapter) {\n      console.error('Plugin:', this.pluginId,\n                    'Unrecognized adapter:', adapterId,\n                    'Ignoring msg:', msg);\n      return;\n    }\n\n    let device;\n    let property;\n    let deferredMock;\n\n    switch (msg.messageType) {\n\n      case Constants.ADAPTER_UNLOADED:\n        this.adapters.delete(adapterId);\n        if (this.adapters.size == 0) {\n          // We've unloaded the last adapter for the plugin, now unload\n          // the plugin.\n\n          // We may need to reevaluate this, and only auto-unload\n          // the plugin for the MockAdapter. For plugins which\n          // support hot-swappable dongles (like zwave/zigbee) it makes\n          // sense to have a plugin loaded with no adapters present.\n          this.unload();\n          this.unloadCompletedPromise = adapter.unloadCompletedPromise;\n          adapter.unloadCompletedPromise = null;\n        } else if (adapter.unloadCompletedPromise) {\n          adapter.unloadCompletedPromise.resolve();\n          adapter.unloadCompletedPromise = null;\n        }\n        break;\n\n      case Constants.HANDLE_DEVICE_ADDED:\n        device = new DeviceProxy(adapter, msg.data);\n        adapter.handleDeviceAdded(device);\n        break;\n\n      case Constants.HANDLE_DEVICE_REMOVED:\n        device = adapter.getDevice(msg.data.id);\n        if (device) {\n          adapter.handleDeviceRemoved(device);\n        }\n        break;\n\n      case Constants.PROPERTY_CHANGED:\n        device = adapter.getDevice(msg.data.deviceId);\n        if (device) {\n          property = device.findProperty(msg.data.property.name);\n          if (property) {\n            property.doPropertyChanged(msg.data.property);\n            if (property.isVisible()) {\n              device.notifyPropertyChanged(property);\n            }\n          }\n        }\n        break;\n\n      case Constants.ACTION_STATUS:\n        device = adapter.getDevice(msg.data.deviceId);\n        if (device) {\n          device.actionNotify(msg.data.action);\n        }\n        break;\n\n      case Constants.EVENT:\n        device = adapter.getDevice(msg.data.deviceId);\n        if (device) {\n          device.eventNotify(msg.data.event);\n        }\n        break;\n\n      case Constants.CONNECTED:\n        device = adapter.getDevice(msg.data.deviceId);\n        if (device) {\n          device.connectedNotify(msg.data.connected);\n        }\n        break;\n\n      case Constants.MOCK_ADAPTER_STATE_CLEARED:\n        deferredMock = adapter.deferredMock;\n        if (!deferredMock) {\n          console.error('mockAdapterStateCleared: No deferredMock');\n        } else {\n          adapter.deferredMock = null;\n          deferredMock.resolve();\n        }\n        break;\n\n      case Constants.MOCK_DEVICE_ADDED_REMOVED:\n        deferredMock = adapter.deferredMock;\n        if (!deferredMock) {\n          console.error('mockDeviceAddedRemoved: No deferredMock');\n        } else {\n          device = deferredMock.device;\n          adapter.deferredMock = null;\n          deferredMock.device = null;\n          deferredMock.resolve(device);\n        }\n        break;\n\n      case Constants.MOCK_DEVICE_ADD_REMOVE_FAILED:\n        deferredMock = adapter.deferredMock;\n        if (!deferredMock) {\n          console.error('Plugin:', this.pluginId,\n                        'Adapter:', adapter.getId(),\n                        'No deferredMock');\n        } else {\n          adapter.deferredMock = null;\n          deferredMock.reject(msg.data.error);\n        }\n        break;\n\n      default:\n        console.error('Plugin: unrecognized msg:', msg);\n        break;\n    }\n  }\n\n  /**\n   * Generate an ID for a message.\n   *\n   * @returns {integer} An id.\n   */\n  generateMsgId() {\n    return ++this.nextId;\n  }\n\n  sendMsg(methodType, data, deferred) {\n    data.pluginId = this.pluginId;\n\n    // Methods which could fail should await result.\n    if (typeof deferred !== 'undefined') {\n      switch (methodType) {\n        case Constants.REQUEST_ACTION: {\n          this.requestActionPromises.set(data.actionId, deferred);\n          break;\n        }\n        case Constants.REMOVE_ACTION: {\n          // removeAction needs ID which is per message, because it\n          // can be called while waiting rejected or resolved.\n          data.messageId = this.generateMsgId();\n          this.removeActionPromises.set(data.messageId, deferred);\n          break;\n        }\n        case Constants.SET_PIN: {\n          // removeAction needs ID which is per message, because it\n          // can be called while waiting rejected or resolved.\n          data.messageId = this.generateMsgId();\n          this.setPinPromises.set(data.messageId, deferred);\n          break;\n        }\n        default:\n          break;\n      }\n    }\n\n    const msg = {\n      messageType: methodType,\n      data: data,\n    };\n    DEBUG && console.log('Plugin: sendMsg:', msg);\n\n    return this.ipcSocket.sendJson(msg);\n  }\n\n  /**\n   * Does cleanup required to allow the test suite to complete cleanly.\n   */\n  shutdown() {\n    this.requestActionPromises.forEach((promise, key) => {\n      promise.reject();\n      this.requestActionPromises.delete(key);\n    });\n    this.removeActionPromises.forEach((promise, key) => {\n      promise.reject();\n      this.removeActionPromises.delete(key);\n    });\n    this.setPinPromises.forEach((promise, key) => {\n      promise.reject();\n      this.setPinPromises.delete(key);\n    });\n    this.ipcSocket.close();\n  }\n\n  start() {\n    const execArgs = {\n      nodeLoader: `node ${path.join(UserProfile.gatewayDir,\n                                    'src',\n                                    'addon-loader.js')}`,\n      name: this.pluginId,\n      path: this.execPath,\n    };\n    const execCmd = format(this.exec, execArgs);\n\n    DEBUG && console.log('  Launching:', execCmd);\n\n    // If we need embedded spaces, then consider changing to use the npm\n    // module called splitargs\n    this.restart = true;\n    const args = execCmd.split(' ');\n    this.process.p = spawn(\n      args[0],\n      args.slice(1),\n      {\n        env: Object.assign(process.env,\n                           {\n                             MOZIOT_HOME: UserProfile.baseDir,\n                             NODE_PATH: path.join(UserProfile.gatewayDir,\n                                                  'node_modules'),\n                           }),\n      }\n    );\n\n    this.process.p.on('error', (err) => {\n      // We failed to spawn the process. This most likely means that the\n      // exec string is malformed somehow. Report the error but don't try\n      // restarting.\n      this.restart = false;\n      console.error('Failed to start plugin', this.pluginId);\n      console.error('Command:', this.exec);\n      console.error(err);\n    });\n\n    this.stdoutReadline = readline.createInterface({\n      input: this.process.p.stdout,\n    });\n    this.stdoutReadline.on('line', (line) => {\n      console.log(`${this.logPrefix}: ${line}`);\n    });\n\n    this.stderrReadline = readline.createInterface({\n      input: this.process.p.stderr,\n    });\n    this.stderrReadline.on('line', (line) => {\n      console.error(`${this.logPrefix}: ${line}`);\n    });\n\n    this.process.p.on('exit', (code) => {\n      if (this.restart) {\n        if (code == Constants.DONT_RESTART_EXIT_CODE) {\n          console.log('Plugin:', this.pluginId, 'died, code =', code,\n                      'NOT restarting...');\n          this.restart = false;\n          this.process.p = null;\n        } else {\n          console.log('Plugin:', this.pluginId, 'died, code =', code,\n                      'restarting...');\n          this.start();\n        }\n      } else {\n        this.process.p = null;\n      }\n    });\n  }\n\n  unload() {\n    this.restart = false;\n    this.unloadedRcvdPromise = new Deferred();\n    this.sendMsg(Constants.UNLOAD_PLUGIN, {});\n  }\n}\n\nmodule.exports = Plugin;\n","/**\n * PropertyProxy - Gateway side representation of a property\n *                 when using an adapter plugin.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Constants = require('../constants');\nconst Deferred = require('../deferred');\nconst {Property} = require('gateway-addon');\n\nclass PropertyProxy extends Property {\n  constructor(device, propertyName, propertyDict) {\n    super(device, propertyName, propertyDict);\n\n    this.value = propertyDict.value;\n\n    this.propertyChangedPromises = [];\n    this.propertyDict = Object.assign({}, propertyDict);\n  }\n\n  asDict() {\n    return Object.assign({}, this.propertyDict, super.asDict());\n  }\n\n  /**\n   * @method onPropertyChanged\n   * @returns a promise which is resoved when the next\n   * propertyChanged notification is received.\n   */\n  onPropertyChanged() {\n    const deferredChange = new Deferred();\n    this.propertyChangedPromises.push(deferredChange);\n    return deferredChange.promise;\n  }\n\n  /**\n   * @method doPropertyChanged\n   * Called whenever a property changed notification is received\n   * from the adapter.\n   */\n  doPropertyChanged(propertyDict) {\n    this.propertyDict = Object.assign({}, propertyDict);\n    this.setCachedValue(propertyDict.value);\n    if (propertyDict.hasOwnProperty('minimum')) {\n      this.minimum = propertyDict.minimum;\n    }\n    if (propertyDict.hasOwnProperty('maximum')) {\n      this.maximum = propertyDict.maximum;\n    }\n    if (propertyDict.hasOwnProperty('multipleOf')) {\n      this.multipleOf = propertyDict.multipleOf;\n    }\n    if (propertyDict.hasOwnProperty('enum')) {\n      this.enum = propertyDict.enum;\n    }\n    while (this.propertyChangedPromises.length > 0) {\n      const deferredChange = this.propertyChangedPromises.pop();\n      deferredChange.resolve(propertyDict.value);\n    }\n  }\n\n  /**\n   * @returns a promise which resolves to the updated value.\n   *\n   * @note it is possible that the updated value doesn't match\n   * the value passed in.\n   */\n  setValue(value) {\n    return new Promise((resolve, reject) => {\n      this.device.adapter.sendMsg(\n        Constants.SET_PROPERTY, {\n          deviceId: this.device.id,\n          propertyName: this.name,\n          propertyValue: value,\n        });\n\n      // TODO: Add a timeout\n\n      this.onPropertyChanged().then((updatedValue) => {\n        resolve(updatedValue);\n      }).catch((error) => {\n        console.error('PropertyProxy: Failed to setProperty',\n                      this.name, 'to', value,\n                      'for device:', this.device.id);\n        console.error(error);\n        reject(error);\n      });\n    });\n  }\n}\n\nmodule.exports = PropertyProxy;\n","/**\n * Push Service.\n *\n * Manage the Push Service for notifications\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nconst WebPush = require('web-push');\nconst Settings = require('./models/settings');\nconst Database = require('./db');\n\nconst PushService = {\n\n  enabled: false,\n  /**\n   * Initialize the Push Service, generating and storing a VAPID keypair\n   * if necessary.\n   */\n  init: async (tunnelDomain) => {\n    let vapid = await Settings.get('push.vapid');\n    if (!vapid) {\n      vapid = WebPush.generateVAPIDKeys();\n      await Settings.set('push.vapid', vapid);\n    }\n    const {publicKey, privateKey} = vapid;\n\n    WebPush.setVapidDetails(tunnelDomain, publicKey, privateKey);\n\n    this.enabled = true;\n  },\n\n  getVAPIDKeys: async () => {\n    try {\n      const vapid = await Settings.get('push.vapid');\n      return vapid;\n    } catch (err) {\n      // do nothing\n      console.error('vapid still not generated');\n    }\n  },\n\n  createPushSubscription: async (subscription) => {\n    return await Database.createPushSubscription(subscription);\n  },\n\n  broadcastNotification: async (message) => {\n    if (!this.enabled) {\n      return;\n    }\n    const subscriptions = await Database.getPushSubscriptions();\n    for (const subscription of subscriptions) {\n      WebPush.sendNotification(subscription, message).catch((err) => {\n        console.warn('Push API error', err);\n        Database.deletePushSubscription(subscription.id);\n      });\n    }\n  },\n};\n\nmodule.exports = PushService;\n","/**\n * Router.\n *\n * Configure web app routes.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst compression = require('compression');\nconst express = require('express');\nconst nocache = require('nocache')();\nconst Constants = require('./constants');\nconst jwtMiddleware = require('./jwt-middleware');\nconst auth = jwtMiddleware.middleware();\nconst UserProfile = require('./user-profile');\n\n/**\n * Router.\n */\nconst Router = {\n  /**\n   * Configure web app routes.\n   */\n  configure: function(app, options) {\n    const API_PREFIX = '/api'; // A pseudo path to use for API requests\n    const APP_PREFIX = '/app'; // A pseudo path to use for front end requests\n\n    // Compress all responses larger than 1kb\n    app.use(compression());\n\n    // Enable HSTS\n    app.use((request, response, next) => {\n      if (request.protocol === 'https') {\n        response.set('Strict-Transport-Security',\n                     'max-age=31536000; includeSubDomains');\n      }\n\n      next();\n    });\n\n    // First look for a static file\n    const staticHandler = express.static(Constants.BUILD_STATIC_PATH);\n    app.use('/uploads', express.static(UserProfile.uploadsDir));\n    app.use((request, response, next) => {\n      if (request.path === '/' && request.accepts('html')) {\n        // We need this to hit RootController.\n        next();\n      } else {\n        staticHandler(request, response, next);\n      }\n    });\n\n    // Content negotiation middleware\n    app.use(function(request, response, next) {\n      // Inform the browser that content negotiation is taking place\n      response.setHeader('Vary', 'Accept');\n\n      // Enable CORS for all requests\n      response.setHeader('Access-Control-Allow-Origin', '*');\n      response.setHeader(\n        'Access-Control-Allow-Headers',\n        'Origin, X-Requested-With, Content-Type, Accept, Authorization');\n      response.setHeader('Access-Control-Allow-Methods',\n                         'GET,HEAD,PUT,PATCH,POST,DELETE');\n\n      // If request won't accept HTML but will accept JSON,\n      // or is a WebSocket request, or is multipart/form-data\n      // treat it as an API request\n      if (!request.accepts('html') && request.accepts('json') ||\n          request.get('Upgrade') === 'websocket' ||\n          request.is('multipart/form-data') ||\n          request.path.startsWith(Constants.LOGS_PATH)) {\n        request.url = API_PREFIX + request.url;\n        next();\n      // Otherwise treat it as an app request\n      } else {\n        request.url = APP_PREFIX + request.url;\n        next();\n      }\n    });\n\n    // Let OAuth handle its own rendering\n    app.use(APP_PREFIX + Constants.OAUTH_PATH, nocache,\n            require('./controllers/oauth_controller').default);\n\n    // Web app routes - send index.html and fall back to client side URL router\n    app.use(`${APP_PREFIX}/*`, require('./controllers/root_controller'));\n\n    // Unauthenticated API routes\n    app.use(API_PREFIX + Constants.LOGIN_PATH, nocache,\n            require('./controllers/login_controller'));\n    app.use(API_PREFIX + Constants.SETTINGS_PATH, nocache,\n            require('./controllers/settings_controller'));\n    app.use(API_PREFIX + Constants.USERS_PATH, nocache,\n            require('./controllers/users_controller'));\n    app.use(API_PREFIX + Constants.PING_PATH, nocache,\n            require('./controllers/ping_controller'));\n    if (options.debug) {\n      app.use(API_PREFIX + Constants.DEBUG_PATH, nocache,\n              require('./controllers/debug_controller'));\n    }\n\n    // Authenticated API routes\n    app.use(API_PREFIX + Constants.THINGS_PATH, nocache, auth,\n            require('./controllers/things_controller'));\n    app.use(API_PREFIX + Constants.NEW_THINGS_PATH, nocache, auth,\n            require('./controllers/new_things_controller'));\n    app.use(API_PREFIX + Constants.ADAPTERS_PATH, nocache, auth,\n            require('./controllers/adapters_controller'));\n    app.use(API_PREFIX + Constants.ACTIONS_PATH, nocache, auth,\n            require('./controllers/actions_controller'));\n    app.use(API_PREFIX + Constants.EVENTS_PATH, nocache, auth,\n            require('./controllers/events_controller'));\n    app.use(API_PREFIX + Constants.LOG_OUT_PATH, nocache, auth,\n            require('./controllers/log_out_controller'));\n    app.use(API_PREFIX + Constants.UPLOADS_PATH, nocache, auth,\n            require('./controllers/uploads_controller'));\n    app.use(API_PREFIX + Constants.COMMANDS_PATH, nocache, auth,\n            require('./controllers/commands_controller'));\n    app.use(API_PREFIX + Constants.UPDATES_PATH, nocache, auth,\n            require('./controllers/updates_controller'));\n    app.use(API_PREFIX + Constants.ADDONS_PATH, nocache, auth,\n            require('./controllers/addons_controller'));\n    app.use(API_PREFIX + Constants.RULES_PATH, nocache, auth,\n            require('./rules-engine/index.js'));\n    app.use(API_PREFIX + Constants.LOGS_PATH, nocache, auth,\n            require('./controllers/logs_controller'));\n    app.use(API_PREFIX + Constants.PUSH_PATH, nocache, auth,\n            require('./controllers/push_controller'));\n\n    app.use(API_PREFIX + Constants.OAUTH_PATH, nocache,\n            require('./controllers/oauth_controller').default);\n    app.use(API_PREFIX + Constants.OAUTHCLIENTS_PATH, nocache, auth,\n            require('./controllers/oauthclients_controller').default);\n  },\n};\n\nmodule.exports = Router;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\n/**\n * A simple helper class for sending JSON-formatted errors to clients\n */\nclass APIError extends Error {\n  constructor(message, originalError) {\n    super(message);\n    if (originalError) {\n      this.message += `: ${originalError.message}`;\n    }\n    console.error(`new API Error: ${this.message}`);\n  }\n\n  toString() {\n    return JSON.stringify({error: true, message: this.message});\n  }\n}\n\nmodule.exports = APIError;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst db = require('../db.js');\n\nfunction Database() {\n  if (!db.db) {\n    db.open();\n  }\n  this.open();\n}\n\n/**\n * Open the database\n */\nDatabase.prototype.open = function() {\n  const rulesTableSQL = `CREATE TABLE IF NOT EXISTS rules (\n    id INTEGER PRIMARY KEY,\n    description TEXT\n  );`;\n  return db.run(rulesTableSQL, []);\n};\n\n/**\n * Get all rules\n * @return {Promise<Map<number, RuleDescription>>} resolves to a map of rule id\n * to rule\n */\nDatabase.prototype.getRules = function() {\n  return new Promise((resolve, reject) => {\n    db.db.all(\n      'SELECT id, description FROM rules',\n      [],\n      function(err, rows) {\n        if (err) {\n          reject(err);\n          return;\n        }\n        const rules = {};\n        for (const row of rows) {\n          const desc = JSON.parse(row.description);\n          rules[row.id] = desc;\n        }\n        resolve(rules);\n      }\n    );\n  });\n};\n\n/**\n * Create a new rule\n * @param {RuleDescription} desc\n * @return {Promise<number>} resolves to rule id\n */\nDatabase.prototype.createRule = function(desc) {\n  return db.run(\n    'INSERT INTO rules (description) VALUES (?)',\n    [JSON.stringify(desc)]\n  ).then((res) => {\n    return parseInt(res.lastID);\n  });\n};\n\n/**\n * Update an existing rule\n * @param {number} id\n * @param {RuleDescription} desc\n * @return {Promise}\n */\nDatabase.prototype.updateRule = function(id, desc) {\n  return db.run(\n    'UPDATE rules SET description = ? WHERE id = ?',\n    [JSON.stringify(desc), id]\n  );\n};\n\n/**\n * Delete an existing rule\n * @param {number} id\n * @return {Promise}\n */\nDatabase.prototype.deleteRule = function(id) {\n  return db.run('DELETE FROM rules WHERE id = ?', [id]);\n};\n\nmodule.exports = new Database();\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst Database = require('./Database');\nconst Rule = require('./Rule');\n\n/**\n * An engine for running and managing list of rules\n */\nclass Engine {\n  /**\n   * Get a list of all current rules\n   * @return {Promise<Array<Rule>>} rules\n   */\n  getRules() {\n    let rulesPromise = Promise.resolve(this.rules);\n\n    if (!this.rules) {\n      rulesPromise = Database.getRules().then(async (ruleDescs) => {\n        this.rules = {};\n        for (const ruleId in ruleDescs) {\n          ruleDescs[ruleId].id = parseInt(ruleId);\n          this.rules[ruleId] = Rule.fromDescription(ruleDescs[ruleId]);\n          await this.rules[ruleId].start();\n        }\n        return this.rules;\n      });\n    }\n\n    return rulesPromise.then((rules) => {\n      return Object.keys(rules).map((ruleId) => {\n        return rules[ruleId];\n      });\n    });\n  }\n\n  /**\n   * Get a rule by id\n   * @param {number} id\n   * @return {Promise<Rule>}\n   */\n  getRule(id) {\n    const rule = this.rules[id];\n    if (!rule) {\n      return Promise.reject(new Error(`Rule ${id} does not exist`));\n    }\n    return Promise.resolve(rule);\n  }\n\n  /**\n   * Add a new rule to the engine's list\n   * @param {Rule} rule\n   * @return {Promise<number>} rule id\n   */\n  async addRule(rule) {\n    const id = await Database.createRule(rule.toDescription());\n    rule.id = id;\n    this.rules[id] = rule;\n    await rule.start();\n    return id;\n  }\n\n  /**\n   * Update an existing rule\n   * @param {number} rule id\n   * @param {Rule} rule\n   * @return {Promise}\n   */\n  async updateRule(ruleId, rule) {\n    if (!this.rules[ruleId]) {\n      return Promise.reject(new Error(`Rule ${ruleId} does not exist`));\n    }\n    rule.id = ruleId;\n    await Database.updateRule(ruleId, rule.toDescription());\n\n    this.rules[ruleId].stop();\n    this.rules[ruleId] = rule;\n    await rule.start();\n  }\n\n  /**\n   * Delete an existing rule\n   * @param {number} rule id\n   * @return {Promise}\n   */\n  deleteRule(ruleId) {\n    if (!this.rules[ruleId]) {\n      return Promise.reject(\n        new Error(`Rule ${ruleId} already does not exist`));\n    }\n    return Database.deleteRule(ruleId).then(() => {\n      this.rules[ruleId].stop();\n      delete this.rules[ruleId];\n    });\n  }\n}\n\nmodule.exports = Engine;\n","/**\n * List of event types\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\nmodule.exports = {\n  // Sent by a trigger to a rule to notify effects\n  STATE_CHANGED: 'state-changed',\n  // Sent by a property to a trigger to potentially change state\n  VALUE_CHANGED: 'value-changed',\n};\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst assert = require('assert');\nconst fetch = require('node-fetch');\nconst https = require('https');\nconst Settings = require('../models/settings');\nconst EventEmitter = require('events').EventEmitter;\nconst Events = require('./Events');\nconst ThingConnection = require('./ThingConnection');\n\n/**\n * Utility to support operations on Thing's properties\n */\nclass Property extends EventEmitter {\n  /**\n   * Create a Property from a descriptor returned by the WoT API\n   * @param {PropertyDescription} desc\n   */\n  constructor(desc) {\n    super();\n\n    this.originator = new Error().stack;\n\n    assert(desc.type);\n    assert(desc.href);\n\n    this.type = desc.type;\n    this.href = desc.href;\n    if (desc.unit) {\n      this.unit = desc.unit;\n    }\n    if (desc.description) {\n      this.description = desc.description;\n    }\n    const parts = this.href.split('/');\n    this.name = parts[parts.length - 1];\n\n    this.onMessage = this.onMessage.bind(this);\n    const thingHref = this.href.split('/properties')[0];\n    this.thingConn = new ThingConnection(thingHref, this.onMessage);\n  }\n\n  /**\n   * @return {PropertyDescription}\n   */\n  toDescription() {\n    const desc = {\n      type: this.type,\n      href: this.href,\n      name: this.name,\n    };\n    if (this.unit) {\n      desc.unit = this.unit;\n    }\n    if (this.description) {\n      desc.description = this.description;\n    }\n    return desc;\n  }\n\n  /**\n   * @return {String} full property href\n   */\n  async getHref() {\n    const href = await Settings.get('RulesEngine.gateway') + this.href;\n    return href;\n  }\n\n  /**\n   * @return {Promise<Object>} headers for JWT bearer auth\n   */\n  async headerAuth() {\n    const jwt = await Settings.get('RulesEngine.jwt');\n    if (jwt) {\n      return {\n        Authorization: `Bearer ${jwt}`,\n      };\n    } else {\n      return {};\n    }\n  }\n\n  /**\n   * @return {Promise} resolves to property's value\n   */\n  async get() {\n    const href = await this.getHref();\n    let agent = null;\n    if (href.startsWith('https')) {\n      agent = new https.Agent({rejectUnauthorized: false});\n    }\n\n    const res = await fetch(href, {\n      headers: Object.assign({\n        Accept: 'application/json',\n      }, await this.headerAuth()),\n      agent,\n    });\n    const data = await res.json();\n\n    return data[this.name];\n  }\n\n  /**\n   * @param {any} value\n   * @return {Promise} resolves if property is set to value\n   */\n  async set(value) {\n    const href = await this.getHref();\n    let agent = null;\n    if (href.startsWith('https')) {\n      agent = new https.Agent({rejectUnauthorized: false});\n    }\n\n    const data = {};\n    data[this.name] = value;\n    return fetch(href, {\n      method: 'PUT',\n      headers: Object.assign({\n        Accept: 'application/json',\n        'Content-Type': 'application/json',\n      }, await this.headerAuth()),\n      body: JSON.stringify(data),\n      cors: true,\n      agent,\n    });\n  }\n\n  async start() {\n    await this.thingConn.start();\n  }\n\n  onMessage(msg) {\n    if (msg.messageType === 'propertyStatus') {\n      if (msg.data.hasOwnProperty(this.name)) {\n        this.emit(Events.VALUE_CHANGED, msg.data[this.name]);\n      }\n    }\n  }\n\n  stop() {\n    this.thingConn.stop();\n  }\n}\n\nmodule.exports = Property;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\nconst effects = require('./effects');\nconst triggers = require('./triggers');\nconst Events = require('./Events');\n\nclass Rule {\n  /**\n   * @param {boolean} enabled\n   * @param {Trigger} trigger\n   * @param {Effect} effect\n   */\n  constructor(enabled, trigger, effect) {\n    this.enabled = enabled;\n    this.trigger = trigger;\n    this.effect = effect;\n\n    this.onTriggerStateChanged = this.onTriggerStateChanged.bind(this);\n  }\n\n  /**\n   * Begin executing the rule\n   */\n  async start() {\n    this.trigger.on(Events.STATE_CHANGED, this.onTriggerStateChanged);\n    await this.trigger.start();\n  }\n\n  /**\n   * On a state changed event, pass the state forwawrd to the rule's effect\n   * @param {State} state\n   */\n  onTriggerStateChanged(state) {\n    if (!this.enabled) {\n      return;\n    }\n    this.effect.setState(state);\n  }\n\n  /**\n   * @return {RuleDescription}\n   */\n  toDescription() {\n    const desc = {\n      enabled: this.enabled,\n      trigger: this.trigger.toDescription(),\n      effect: this.effect.toDescription(),\n    };\n    if (this.hasOwnProperty('id')) {\n      desc.id = this.id;\n    }\n    if (this.hasOwnProperty('name')) {\n      desc.name = this.name;\n    }\n    return desc;\n  }\n\n  /**\n   * Stop executing the rule\n   */\n  stop() {\n    this.trigger.removeListener(Events.STATE_CHANGED,\n                                this.onTriggerStateChanged);\n    this.trigger.stop();\n  }\n}\n\n/**\n * Create a rule from a serialized description\n * @param {RuleDescription} desc\n * @return {Rule}\n */\nRule.fromDescription = function(desc) {\n  const trigger = triggers.fromDescription(desc.trigger);\n  const effect = effects.fromDescription(desc.effect);\n  const rule = new Rule(desc.enabled, trigger, effect);\n  if (desc.hasOwnProperty('id')) {\n    rule.id = desc.id;\n  }\n  if (desc.hasOwnProperty('name')) {\n    rule.name = desc.name;\n  }\n  return rule;\n};\n\nmodule.exports = Rule;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst e2p = require('event-to-promise');\nconst Settings = require('../models/settings');\nconst WebSocket = require('ws');\n\n/**\n * Manages WebSocket connection to a Thing\n */\nclass ThingConnection {\n  /**\n   * @param {String|URL} href - Link to Thing endpoint\n   * @param {Function<Object>} messageHandler - called with messages from WS\n   */\n  constructor(href, messageHandler) {\n    this.href = href;\n    this.messageHandler = messageHandler;\n    this.onMessage = this.onMessage.bind(this);\n    this.ws = null;\n  }\n\n  /**\n   * Connect to the Thing's websocket\n   * @return {Promise}\n   */\n  async start() {\n    const jwt = await Settings.get('RulesEngine.jwt');\n    const gateway = await Settings.get('RulesEngine.gateway');\n    const wsHref = `${gateway.replace(/^http/, 'ws') + this.href}?jwt=${jwt}`;\n\n    this.ws = new WebSocket(wsHref, {rejectUnauthorized: false});\n    this.ws.on('message', this.onMessage);\n    await e2p(this.ws, 'open');\n\n    // Allow the app to handle the websocket open\n    await new Promise((res) => {\n      setTimeout(res, 100);\n    });\n  }\n\n  /**\n   * Send a string over the websocket to the Thing\n   * @param {String} msg\n   * @return {Promise}\n   */\n  async send(msg) {\n    await new Promise((resolve) => {\n      this.ws.send(msg, function() {\n        resolve();\n      });\n    });\n  }\n\n  /**\n   * Disconnect the websocket\n   */\n  stop() {\n    if (this.ws) {\n      this.ws.removeListener('message', this.onMessage);\n      if (this.ws.readyState === WebSocket.OPEN) {\n        this.ws.close();\n      }\n    } else {\n      console.warn(`${this.constructor.name}.stop was not started`);\n    }\n  }\n\n  onMessage(text) {\n    const msg = JSON.parse(text);\n    this.messageHandler(msg);\n  }\n}\n\nmodule.exports = ThingConnection;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst assert = require('assert');\nconst fetch = require('node-fetch');\nconst https = require('https');\nconst Effect = require('./Effect');\nconst Settings = require('../../models/settings');\n\n/**\n * An Effect which creates an action\n */\nclass ActionEffect extends Effect {\n  /**\n   * @param {EffectDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n\n    assert(desc.thing);\n    assert(desc.action);\n\n    this.thing = desc.thing;\n    this.action = desc.action;\n    this.parameters = desc.parameters || {};\n  }\n\n  /**\n   * @return {EffectDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {\n        thing: this.thing,\n        action: this.action,\n        parameters: this.parameters,\n      }\n    );\n  }\n\n  /**\n   * @param {State} state\n   */\n  setState(state) {\n    if (!state.on) {\n      return;\n    }\n\n    this.createAction();\n  }\n\n  async createAction() {\n    const descr = {\n      [this.action]: {\n        input: this.parameters,\n      },\n    };\n\n    const href = `${await Settings.get('RulesEngine.gateway') + this.thing.href\n    }/actions`;\n    const jwt = await Settings.get('RulesEngine.jwt');\n    let agent = null;\n    if (href.startsWith('https')) {\n      agent = new https.Agent({rejectUnauthorized: false});\n    }\n\n    const res = await fetch(href, {\n      method: 'POST',\n      headers: {\n        Accept: 'application/json',\n        Authorization: `Bearer ${jwt}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(descr),\n      agent,\n    });\n    if (!res.ok) {\n      console.warn('Unable to dispatch action', res);\n    }\n  }\n}\n\nmodule.exports = ActionEffect;\n\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\n/**\n * Effect - The outcome of a Rule once triggered\n */\nclass Effect {\n  /**\n   * Create an Effect based on a wire-format description with a property\n   * @param {EffectDescription} desc\n   */\n  constructor(desc) {\n    this.type = this.constructor.name;\n    this.label = desc.label;\n  }\n\n  /**\n   * @return {EffectDescription}\n   */\n  toDescription() {\n    return {\n      type: this.type,\n      label: this.label,\n    };\n  }\n\n  /**\n   * Set the state of Effect based on a trigger\n   * @param {State} _state\n   */\n  setState(_state) {\n    throw new Error('Unimplemented');\n  }\n}\n\nmodule.exports = Effect;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst Effect = require('./Effect');\n\n/**\n * MultiEffect - The outcome of a Rule involving multiple effects\n */\nclass MultiEffect extends Effect {\n  /**\n   * @param {MultiEffectDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n    const fromDescription = require('./index').fromDescription;\n\n    this.effects = desc.effects.map(function(effect) {\n      return fromDescription(effect);\n    });\n  }\n\n  /**\n   * @return {EffectDescription}\n   */\n  toDescription() {\n    return Object.assign(super.toDescription(), {\n      effects: this.effects.map((effect) => effect.toDescription()),\n    });\n  }\n\n  /**\n   * @param {State} state\n   */\n  setState(state) {\n    for (const effect of this.effects) {\n      effect.setState(state);\n    }\n  }\n}\n\nmodule.exports = MultiEffect;\n\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst assert = require('assert');\nconst Effect = require('./Effect');\nconst PushService = require('../../push-service');\n\n/**\n * An Effect which creates a notification\n */\nclass NotificationEffect extends Effect {\n  /**\n   * @param {EffectDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n\n    assert(desc.hasOwnProperty('message'));\n\n    this.message = desc.message;\n  }\n\n  /**\n   * @return {EffectDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {\n        message: this.message,\n      }\n    );\n  }\n\n  /**\n   * @param {State} state\n   */\n  setState(state) {\n    if (!state.on) {\n      return;\n    }\n\n    PushService.broadcastNotification(this.message);\n  }\n}\n\nmodule.exports = NotificationEffect;\n\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst Property = require('../Property');\nconst Effect = require('./Effect');\n\n/**\n * PropertyEffect - The outcome of a Rule involving a property\n */\nclass PropertyEffect extends Effect {\n  /**\n   * Create an Effect based on a wire-format description with a property\n   * @param {PropertyEffectDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n    this.property = new Property(desc.property);\n  }\n\n  /**\n   * @return {EffectDescription}\n   */\n  toDescription() {\n    return Object.assign(super.toDescription(), {\n      property: this.property.toDescription(),\n    });\n  }\n}\n\nmodule.exports = PropertyEffect;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst assert = require('assert');\nconst PropertyEffect = require('./PropertyEffect');\n\n/**\n * An Effect which temporarily sets the target property to\n * a value before restoring its original value\n */\nclass PulseEffect extends PropertyEffect {\n  /**\n   * @param {EffectDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n    this.value = desc.value;\n    assert(typeof this.value === this.property.type,\n           'setpoint and property must be same type');\n    this.on = false;\n    this.oldValue = null;\n  }\n\n  /**\n   * @return {EffectDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {value: this.value}\n    );\n  }\n\n  /**\n   * @param {State} state\n   */\n  setState(state) {\n    if (state.on) {\n      // If we're already active, just perform the effect again\n      if (this.on) {\n        return this.property.set(this.value);\n      }\n      // Activate the effect and save our current state to revert to upon\n      // deactivation\n      this.property.get().then((value) => {\n        if (value !== this.value) {\n          this.oldValue = value;\n        } else {\n          this.oldValue = null;\n        }\n        this.on = true;\n        return this.property.set(this.value);\n      });\n    } else if (this.on) {\n      // Revert to our original value if we pulsed to a new value\n      this.on = false;\n      if (this.oldValue !== null) {\n        return this.property.set(this.oldValue);\n      }\n    }\n  }\n}\n\nmodule.exports = PulseEffect;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst assert = require('assert');\nconst PropertyEffect = require('./PropertyEffect');\n\n/**\n * An Effect which permanently sets the target property to\n * a value when triggered\n */\nclass SetEffect extends PropertyEffect {\n  /**\n   * @param {EffectDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n    this.value = desc.value;\n    assert(typeof this.value === this.property.type,\n           'setpoint and property must be same type');\n    this.on = false;\n  }\n\n  /**\n   * @return {EffectDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {value: this.value}\n    );\n  }\n\n  /**\n   * @return {State}\n   */\n  setState(state) {\n    if (!this.on && state.on) {\n      this.on = true;\n      return this.property.set(this.value);\n    }\n    if (this.on && !state.on) {\n      this.on = false;\n      return Promise.resolve();\n    }\n  }\n}\n\nmodule.exports = SetEffect;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst effects = {\n  Effect: require('./Effect'),\n  ActionEffect: require('./ActionEffect'),\n  MultiEffect: require('./MultiEffect'),\n  NotificationEffect: require('./NotificationEffect'),\n  SetEffect: require('./SetEffect'),\n  PulseEffect: require('./PulseEffect'),\n};\n\n/**\n * Produce an effect from a serialized effect description. Throws if `desc` is\n * invalid\n * @param {EffectDescription} desc\n * @return {Effect}\n */\nfunction fromDescription(desc) {\n  const EffectClass = effects[desc.type];\n  if (!EffectClass) {\n    throw new Error(`Unsupported or invalid effect type:${desc.type}`);\n  }\n  return new EffectClass(desc);\n}\n\nmodule.exports = {\n  effects: effects,\n  fromDescription: fromDescription,\n};\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst PromiseRouter = require('express-promise-router');\nconst Settings = require('../models/settings');\n\nconst APIError = require('./APIError');\nconst Database = require('./Database');\nconst Engine = require('./Engine');\nconst JSONWebToken = require('../models/jsonwebtoken');\nconst Rule = require('./Rule');\n\nconst index = PromiseRouter();\nconst engine = new Engine();\n\n/**\n * Express middleware for extracting rules from the bodies of requests\n * @param {express.Request} req\n * @param {express.Response} res\n * @param {Function} next\n */\nfunction parseRuleFromBody(req, res, next) {\n  if (!req.body.trigger) {\n    res.status(400).send(new APIError('No trigger provided').toString());\n    return;\n  }\n  if (!req.body.effect) {\n    res.status(400).send(new APIError('No effect provided').toString());\n    return;\n  }\n\n  let rule = null;\n  try {\n    rule = Rule.fromDescription(req.body);\n  } catch (e) {\n    res.status(400).send(new APIError('Invalid rule', e).toString());\n    return;\n  }\n  req.rule = rule;\n  next();\n}\n\nindex.get('/', async function(req, res) {\n  const rules = await engine.getRules();\n  res.send(rules.map((rule) => {\n    return rule.toDescription();\n  }));\n});\n\n\nindex.get('/:id', async function(req, res) {\n  try {\n    const id = parseInt(req.params.id);\n    const rule = await engine.getRule(id);\n    res.send(rule.toDescription());\n  } catch (e) {\n    res.status(404).send(\n      new APIError('Engine failed to get rule', e).toString());\n  }\n});\n\nindex.post('/', parseRuleFromBody, async function(req, res) {\n  const ruleId = await engine.addRule(req.rule);\n  res.send({id: ruleId});\n});\n\nindex.put('/:id', parseRuleFromBody, async function(req, res) {\n  try {\n    await engine.updateRule(parseInt(req.params.id), req.rule);\n    res.send({});\n  } catch (e) {\n    res.status(404).send(\n      new APIError('Engine failed to update rule', e).toString());\n  }\n});\n\nindex.delete('/:id', async function(req, res) {\n  try {\n    await engine.deleteRule(req.params.id);\n    res.send({});\n  } catch (e) {\n    res.status(404).send(\n      new APIError('Engine failed to delete rule', e).toString());\n  }\n});\n\nindex.configure = async function(gatewayHref) {\n  await Settings.set('RulesEngine.gateway', gatewayHref);\n  await Settings.set('RulesEngine.jwt', await JSONWebToken.issueToken(-1));\n\n  await Database.open();\n  await engine.getRules();\n};\n\nmodule.exports = index;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst assert = require('assert');\nconst Events = require('../Events');\nconst PropertyTrigger = require('./PropertyTrigger');\n\n/**\n * A Trigger which activates when a boolean property is\n * equal to a given value, `onValue`\n */\nclass BooleanTrigger extends PropertyTrigger {\n  /**\n   * @param {TriggerDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n    assert(this.property.type === 'boolean');\n    assert(typeof desc.onValue === 'boolean');\n    this.onValue = desc.onValue;\n  }\n\n  /**\n   * @return {TriggerDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {onValue: this.onValue}\n    );\n  }\n\n  /**\n   * @param {boolean} propValue\n   * @return {State}\n   */\n  onValueChanged(propValue) {\n    if (propValue === this.onValue) {\n      this.emit(Events.STATE_CHANGED, {on: true, value: propValue});\n    } else {\n      this.emit(Events.STATE_CHANGED, {on: false, value: propValue});\n    }\n  }\n}\n\nmodule.exports = BooleanTrigger;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst Events = require('../Events');\nconst PropertyTrigger = require('./PropertyTrigger');\n\n/**\n * A trigger which activates when a property is equal to a given value\n */\nclass EqualityTrigger extends PropertyTrigger {\n  /**\n   * @param {TriggerDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n\n    this.value = desc.value;\n  }\n\n  /**\n   * @return {TriggerDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {\n        value: this.value,\n      }\n    );\n  }\n\n  /**\n   * @param {number} propValue\n   * @return {State}\n   */\n  onValueChanged(propValue) {\n    const on = propValue === this.value;\n\n    this.emit(Events.STATE_CHANGED, {on: on, value: propValue});\n  }\n}\n\nmodule.exports = EqualityTrigger;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst Constants = require('../../constants.js');\nconst Events = require('../Events');\nconst ThingConnection = require('../ThingConnection');\nconst Trigger = require('./Trigger');\n\n/**\n * A trigger activated when an event occurs\n */\nclass EventTrigger extends Trigger {\n  constructor(desc) {\n    super(desc);\n    this.thing = desc.thing;\n    this.event = desc.event;\n    this.timeout = null;\n    this.subscribed = false;\n    this.onMessage = this.onMessage.bind(this);\n    this.thingConn = new ThingConnection(desc.thing.href, this.onMessage);\n  }\n\n  /**\n   * @return {TriggerDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {\n        thing: this.thing,\n        event: this.event,\n      }\n    );\n  }\n\n  async start() {\n    await this.thingConn.start();\n    await this.subscribe();\n  }\n\n  async subscribe() {\n    await this.thingConn.send(JSON.stringify({\n      messageType: Constants.ADD_EVENT_SUBSCRIPTION,\n      data: {\n        [this.event]: {},\n      },\n    }));\n  }\n\n  onMessage(msg) {\n    if (msg.messageType === Constants.CONNECTED && !this.subscribed) {\n      if (msg.data) {\n        this.subscribe();\n      }\n    }\n\n    if (msg.messageType !== Constants.EVENT) {\n      return;\n    }\n    if (!msg.data.hasOwnProperty(this.event)) {\n      return;\n    }\n\n    this.subscribed = true;\n\n    this.emit(Events.STATE_CHANGED, {on: true, value: Date.now()});\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n    }\n    this.timeout = setTimeout(() => {\n      this.emit(Events.STATE_CHANGED, {on: false, value: Date.now()});\n      this.timeout = null;\n    }, 500);\n  }\n\n  stop() {\n    clearTimeout(this.timeout);\n    this.thingConn.stop();\n  }\n}\n\nmodule.exports = EventTrigger;\n\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst assert = require('assert');\nconst Events = require('../Events');\nconst PropertyTrigger = require('./PropertyTrigger');\n\nconst LevelTriggerTypes = {\n  LESS: 'LESS',\n  EQUAL: 'EQUAL',\n  GREATER: 'GREATER',\n};\n\n/**\n * A trigger which activates when a numerical property is less or greater than\n * a given level\n */\nclass LevelTrigger extends PropertyTrigger {\n  /**\n   * @param {TriggerDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n    assert(this.property.type === 'number' || this.property.type === 'integer');\n    assert(typeof desc.value === 'number');\n    assert(LevelTriggerTypes[desc.levelType]);\n    if (desc.levelType === 'EQUAL') {\n      assert(this.property.type === 'integer');\n    }\n\n    this.value = desc.value;\n    this.levelType = desc.levelType;\n  }\n\n  /**\n   * @return {TriggerDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {\n        value: this.value,\n        levelType: this.levelType,\n      }\n    );\n  }\n\n  /**\n   * @param {number} propValue\n   * @return {State}\n   */\n  onValueChanged(propValue) {\n    let on = false;\n\n    switch (this.levelType) {\n      case LevelTriggerTypes.LESS:\n        if (propValue < this.value) {\n          on = true;\n        }\n        break;\n      case LevelTriggerTypes.EQUAL:\n        if (propValue === this.value) {\n          on = true;\n        }\n        break;\n      case LevelTriggerTypes.GREATER:\n        if (propValue > this.value) {\n          on = true;\n        }\n        break;\n    }\n\n    this.emit(Events.STATE_CHANGED, {on: on, value: propValue});\n  }\n}\n\nLevelTrigger.types = LevelTriggerTypes;\n\nmodule.exports = LevelTrigger;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst assert = require('assert');\nconst Events = require('../Events');\nconst Trigger = require('./Trigger');\n\nconst ops = {\n  AND: 'AND',\n  OR: 'OR',\n};\n\n/**\n * A Trigger which activates only when a set of triggers are activated\n */\nclass MultiTrigger extends Trigger {\n  /**\n   * @param {TriggerDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n    assert(desc.op in ops);\n    this.op = desc.op;\n    const fromDescription = require('./index').fromDescription;\n\n    this.triggers = desc.triggers.map((trigger) => {\n      return fromDescription(trigger);\n    });\n\n    this.states = new Array(this.triggers.length);\n    this.state = false;\n  }\n\n  /**\n   * @return {TriggerDescription}\n   */\n  toDescription() {\n    return Object.assign(super.toDescription(), {\n      op: this.op,\n      triggers: this.triggers.map((trigger) => trigger.toDescription()),\n    });\n  }\n\n  async start() {\n    const starts = this.triggers.map((trigger, triggerIndex) => {\n      trigger.on(Events.STATE_CHANGED,\n                 this.onStateChanged.bind(this, triggerIndex));\n      return trigger.start();\n    });\n    await Promise.all(starts);\n  }\n\n  stop() {\n    this.triggers.forEach((trigger) => {\n      trigger.removeAllListeners(Events.STATE_CHANGED);\n      trigger.stop();\n    });\n  }\n\n  onStateChanged(triggerIndex, state) {\n    this.states[triggerIndex] = state.on;\n\n    let value = this.states[0];\n    for (let i = 1; i < this.states.length; i++) {\n      if (this.op === ops.AND) {\n        value = value && this.states[i];\n      } else if (this.op === ops.OR) {\n        value = value || this.states[i];\n      }\n    }\n    if (value !== this.state) {\n      this.state = value;\n      this.emit(Events.STATE_CHANGED, {on: this.state});\n    }\n  }\n}\n\nmodule.exports = MultiTrigger;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst Events = require('../Events');\nconst Trigger = require('./Trigger');\nconst Property = require('../Property');\n\n/**\n * An abstract class for triggers whose input is a single property\n */\nclass PropertyTrigger extends Trigger {\n  constructor(desc) {\n    super(desc);\n    this.property = new Property(desc.property);\n    this.onValueChanged = this.onValueChanged.bind(this);\n  }\n\n  /**\n   * @return {TriggerDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {property: this.property.toDescription()}\n    );\n  }\n\n  async start() {\n    this.property.on(Events.VALUE_CHANGED, this.onValueChanged);\n    await this.property.start();\n  }\n\n  onValueChanged(_value) {\n  }\n\n  stop() {\n    this.property.removeListener(Events.VALUE_CHANGED, this.onValueChanged);\n    this.property.stop();\n  }\n}\n\nmodule.exports = PropertyTrigger;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst Events = require('../Events');\nconst Trigger = require('./Trigger');\n\n/**\n * An abstract class for triggers whose input is a single property\n */\nclass TimeTrigger extends Trigger {\n  constructor(desc) {\n    super(desc);\n    this.time = desc.time;\n    this.sendOn = this.sendOn.bind(this);\n    this.sendOff = this.sendOff.bind(this);\n  }\n\n  /**\n   * @return {TriggerDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {time: this.time}\n    );\n  }\n\n  async start() {\n    this.scheduleNext();\n  }\n\n  scheduleNext() {\n    const parts = this.time.split(':');\n    const hours = parseInt(parts[0], 10);\n    const minutes = parseInt(parts[1], 10);\n\n    // Time is specified in UTC\n    const nextTime = new Date();\n    nextTime.setUTCHours(hours, minutes, 0, 0);\n\n    if (nextTime.getTime() < Date.now()) {\n      // NB: this will wrap properly into the next month/year\n      nextTime.setDate(nextTime.getDate() + 1);\n    }\n\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n    }\n    this.timeout = setTimeout(this.sendOn,\n                              nextTime.getTime() - Date.now());\n  }\n\n  sendOn() {\n    this.emit(Events.STATE_CHANGED, {on: true, value: Date.now()});\n    this.timeout = setTimeout(this.sendOff, 60 * 1000);\n  }\n\n  sendOff() {\n    this.emit(Events.STATE_CHANGED, {on: false, value: Date.now()});\n    this.scheduleNext();\n  }\n\n  stop() {\n    clearTimeout(this.timeout);\n    this.timeout = null;\n  }\n}\n\nmodule.exports = TimeTrigger;\n\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\nconst EventEmitter = require('events').EventEmitter;\n\n/**\n * The trigger component of a Rule which monitors some state and passes on\n * whether to be active to the Rule's effect\n */\nclass Trigger extends EventEmitter {\n  /**\n   * Create a Trigger based on a wire-format description with a property\n   * @param {TriggerDescription} desc\n   */\n  constructor(desc) {\n    super();\n    this.type = this.constructor.name;\n    this.label = desc.label;\n  }\n\n  /**\n   * @return {TriggerDescription}\n   */\n  toDescription() {\n    return {\n      type: this.type,\n      label: this.label,\n    };\n  }\n}\n\nmodule.exports = Trigger;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.*\n */\n\nconst triggers = {\n  BooleanTrigger: require('./BooleanTrigger'),\n  EqualityTrigger: require('./EqualityTrigger'),\n  EventTrigger: require('./EventTrigger'),\n  LevelTrigger: require('./LevelTrigger'),\n  MultiTrigger: require('./MultiTrigger'),\n  PropertyTrigger: require('./PropertyTrigger'),\n  TimeTrigger: require('./TimeTrigger'),\n  Trigger: require('./Trigger'),\n};\n\n/**\n * Produce an trigger from a serialized trigger description. Throws if `desc`\n * is invalid\n * @param {TriggerDescription} desc\n * @return {Trigger}\n */\nfunction fromDescription(desc) {\n  const TriggerClass = triggers[desc.type];\n  if (!TriggerClass) {\n    throw new Error(`Unsupported or invalid trigger type:${desc.type}`);\n  }\n  return new TriggerClass(desc);\n}\n\nmodule.exports = {\n  triggers: triggers,\n  fromDescription: fromDescription,\n};\n","/**\n * MozIoT Gateway Tunnelservice.\n *\n * Manages the tunnel service.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nconst fs = require('fs');\nconst config = require('config');\nconst path = require('path');\nconst fetch = require('node-fetch');\nconst spawnSync = require('child_process').spawn;\nconst Settings = require('./models/settings');\nconst UserProfile = require('./user-profile');\nconst PushService = require('./push-service');\n\nconst DEBUG = false || (process.env.NODE_ENV === 'test');\n\nconst TunnelService = {\n\n  pagekiteProcess: null,\n  tunneltoken: null,\n  switchToHttps: null,\n\n  /*\n   * Router middleware to check if we have a ssl tunnel set.\n   *\n   * @param {Object} request Express request object.\n   * @param {Object} response Express response object.\n   * @param {Object} next Next middleware.\n   */\n  isTunnelSet: async function(request, response, next) {\n    // If ssl tunnel is disabled, continue\n    if (!config.get('ssltunnel.enabled')) {\n      return next();\n    } else {\n      let notunnel = await Settings.get('notunnel');\n      if (typeof notunnel !== 'boolean') {\n        notunnel = false;\n      }\n\n      // then we check if we have certificates installed\n      if ((fs.existsSync(path.join(UserProfile.sslDir,\n                                   'certificate.pem')) &&\n           fs.existsSync(path.join(UserProfile.sslDir,\n                                   'privatekey.pem'))) ||\n          notunnel) {\n        // if certs are installed,\n        // then we don't need to do anything and return\n        return next();\n      }\n\n      // if there are no certs installed,\n      // we display the cert setup page to the user\n      response.render('tunnel_setup',\n                      {domain: config.get('ssltunnel.domain')});\n    }\n  },\n\n  // method that starts the client if the box has a registered tunnel\n  start: function(response, urlredirect) {\n    Settings.get('tunneltoken').then((result) => {\n      if (typeof result === 'object') {\n        let responseSent = false;\n        this.tunneltoken = result;\n        const endpoint = `${result.name}.${\n          config.get('ssltunnel.domain')}`;\n        this.pagekiteProcess =\n            spawnSync(config.get('ssltunnel.pagekite_cmd'),\n                      ['--clean', `--frontend=${endpoint}:${\n                        config.get('ssltunnel.port')}`,\n                       `--service_on=https:${endpoint\n                       }:localhost:${\n                         config.get('ports.https')}:${\n                         this.tunneltoken.token}`],\n                      {shell: true});\n\n        // TODO: we should replace the hardcoded secret by the token\n        // after change the server\n        this.pagekiteProcess.stdout.on('data', (data) => {\n          if (DEBUG) {\n            console.log(`[pagekite] stdout: ${data}`);\n          }\n          if (response) {\n            if (responseSent) {\n              return;\n            }\n\n            if (data.indexOf('err=Error in connect') > -1) {\n              responseSent = true;\n              response.status(400).end();\n            } else if (data.indexOf('connect=') > -1) {\n              responseSent = true;\n              response.send(urlredirect);\n            }\n          }\n        });\n        this.pagekiteProcess.stderr.on('data', (data) => {\n          console.log(`[pagekite] stderr: ${data}`);\n        });\n        this.pagekiteProcess.on('close', (code) => {\n          console.log(`[pagekite] process exited with code ${code}`);\n        });\n\n        // Ping the registration server every hour.\n        const delay = 60 * 60 * 1000;\n        setInterval(() => this.pingRegistrationServer(), delay);\n\n        // Enable push service\n        PushService.init(`https://${endpoint}`);\n      } else {\n        console.error('tunneltoken not set');\n        if (response) {\n          response.status(400).end();\n        }\n      }\n    }).catch(function(e) {\n      console.error('Failed to get tunneltoken setting');\n      console.error(e);\n\n      if (response) {\n        response.status(400).send(e);\n      }\n    });\n  },\n\n  // method to stop pagekite process\n  stop: function() {\n    if (this.pagekiteProcess) {\n      this.pagekiteProcess.kill('SIGHUP');\n    }\n  },\n\n  // method to check if the box has certificates\n  hasCertificates: function() {\n    return fs.existsSync(path.join(UserProfile.sslDir, 'certificate.pem')) &&\n      fs.existsSync(path.join(UserProfile.sslDir, 'privatekey.pem'));\n  },\n\n  // method to check if the box has a registered tunnel\n  hasTunnelToken: async function() {\n    const tunneltoken = await Settings.get('tunneltoken');\n    return typeof tunneltoken === 'object';\n  },\n\n  // method to check if user skipped the ssl tunnel setup\n  userSkipped: async function() {\n    const notunnel = await Settings.get('notunnel');\n    if (typeof notunnel === 'boolean' && notunnel) {\n      return true;\n    }\n\n    return false;\n  },\n\n  // method to ping the registration server to track active domains\n  pingRegistrationServer: function() {\n    fetch(`${config.get('ssltunnel.registration_endpoint')\n    }/ping?token=${this.tunneltoken.token}`)\n      .catch((e) => {\n        console.log('Failed to ping registration server:', e);\n      });\n  },\n};\n\nmodule.exports = TunnelService;\n","/**\n * Things Gateway user profile.\n *\n * The user profile lives outside of the source tree to allow for things like\n * data persistence with Docker, as well as the ability to easily switch\n * profiles, if desired.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst config = require('config');\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\nconst mkdirp = require('mkdirp');\nconst ncp = require('ncp');\nconst rimraf = require('rimraf');\nconst db = require('./db');\nconst Settings = require('./models/settings');\nconst Users = require('./models/users');\n\nconst Profile = {\n  init: function() {\n    this.baseDir = config.get('profileDir');\n    this.configDir = path.join(this.baseDir, 'config');\n    this.sslDir = path.join(this.baseDir, 'ssl');\n    this.uploadsDir = path.join(this.baseDir, 'uploads');\n    this.logDir = path.join(this.baseDir, 'log');\n    this.gatewayDir = path.join(__dirname, '..');\n\n    if (process.env.NODE_ENV === 'test') {\n      this.addonsDir = path.join(this.gatewayDir, 'src', 'addons-test');\n    } else {\n      this.addonsDir = path.join(this.baseDir, 'addons');\n    }\n  },\n\n  /**\n   * Manually copy, then unlink, to prevent issues with cross-device renames.\n   */\n  renameFile: function(src, dst) {\n    fs.copyFileSync(src, dst);\n    fs.unlinkSync(src);\n  },\n\n  /**\n   * Manually copy, then remove, to prevent issues with cross-device renames.\n   */\n  renameDir: function(src, dst) {\n    return new Promise((resolve, reject) => {\n      ncp(src, dst, (e) => {\n        if (e) {\n          reject(e);\n          return;\n        }\n\n        rimraf(src, (err) => {\n          if (err) {\n            reject(err);\n            return;\n          }\n\n          resolve();\n        });\n      });\n    });\n  },\n\n  /**\n   * Migrate from old locations to new ones\n   * @return {Promise} resolved when migration is complete\n   */\n  migrate: function() {\n    const pending = [];\n    // Create all required profile directories.\n    if (!fs.existsSync(this.configDir)) {\n      mkdirp.sync(this.configDir);\n    }\n    if (!fs.existsSync(this.sslDir)) {\n      mkdirp.sync(this.sslDir);\n    }\n    if (!fs.existsSync(this.uploadsDir)) {\n      mkdirp.sync(this.uploadsDir);\n    }\n    if (!fs.existsSync(this.logDir)) {\n      mkdirp.sync(this.logDir);\n    }\n    if (!fs.existsSync(this.addonsDir)) {\n      mkdirp.sync(this.addonsDir);\n    }\n\n    // Relocate the database, if necessary, before opening it.\n    const dbPath = path.join(this.configDir, 'db.sqlite3');\n    const oldDbPath = path.join(this.gatewayDir, 'db.sqlite3');\n    if (fs.existsSync(oldDbPath)) {\n      this.renameFile(oldDbPath, dbPath);\n    }\n\n    // Open the database.\n    db.open();\n\n    // Normalize user email addresses\n    Users.getUsers().then((users) => {\n      users.forEach((user) => {\n        // Call editUser with the same user, as it will normalize the email\n        // for us and save it.\n        Users.editUser(user);\n      });\n    });\n\n    // Move the tunneltoken into the database.\n    const ttPath = path.join(this.gatewayDir, 'tunneltoken');\n    if (fs.existsSync(ttPath)) {\n      const token = JSON.parse(fs.readFileSync(ttPath));\n      Settings.set('tunneltoken', token).then(() => {\n        fs.unlinkSync(ttPath);\n      }).catch((e) => {\n        throw e;\n      });\n    }\n\n    // Move the notunnel setting into the database.\n    const ntPath = path.join(this.gatewayDir, 'notunnel');\n    if (fs.existsSync(ntPath)) {\n      Settings.set('notunnel', true).then(() => {\n        fs.unlinkSync(ntPath);\n      }).catch((e) => {\n        throw e;\n      });\n    }\n\n    // Move certificates, if necessary.\n    const pkPath1 = path.join(this.gatewayDir, 'privatekey.pem');\n    const pkPath2 = path.join(this.gatewayDir, 'ssl', 'privatekey.pem');\n    if (fs.existsSync(pkPath1)) {\n      this.renameFile(pkPath1, path.join(this.sslDir, 'privatekey.pem'));\n    } else if (fs.existsSync(pkPath2)) {\n      this.renameFile(pkPath2, path.join(this.sslDir, 'privatekey.pem'));\n    }\n\n    const certPath1 = path.join(this.gatewayDir, 'certificate.pem');\n    const certPath2 = path.join(this.gatewayDir, 'ssl', 'certificate.pem');\n    if (fs.existsSync(certPath1)) {\n      this.renameFile(certPath1, path.join(this.sslDir, 'certificate.pem'));\n    } else if (fs.existsSync(certPath2)) {\n      this.renameFile(certPath2, path.join(this.sslDir, 'certificate.pem'));\n    }\n\n    const chainPath1 = path.join(this.gatewayDir, 'chain.pem');\n    const chainPath2 = path.join(this.gatewayDir, 'ssl', 'chain.pem');\n    if (fs.existsSync(chainPath1)) {\n      this.renameFile(chainPath1, path.join(this.sslDir, 'chain.pem'));\n    } else if (fs.existsSync(chainPath2)) {\n      this.renameFile(chainPath2, path.join(this.sslDir, 'chain.pem'));\n    }\n\n    const csrPath1 = path.join(this.gatewayDir, 'csr.pem');\n    const csrPath2 = path.join(this.gatewayDir, 'ssl', 'csr.pem');\n    if (fs.existsSync(csrPath1)) {\n      this.renameFile(csrPath1, path.join(this.sslDir, 'csr.pem'));\n    } else if (fs.existsSync(csrPath2)) {\n      this.renameFile(csrPath2, path.join(this.sslDir, 'csr.pem'));\n    }\n\n    const oldSslDir = path.join(this.gatewayDir, 'ssl');\n    if (fs.existsSync(oldSslDir)) {\n      rimraf(oldSslDir, (err) => {\n        if (err) {\n          throw err;\n        }\n      });\n    }\n\n    // Move old uploads, if necessary.\n    const oldUploadsDir = path.join(this.gatewayDir, 'static', 'uploads');\n    if (fs.existsSync(oldUploadsDir) &&\n        fs.lstatSync(oldUploadsDir).isDirectory()) {\n      const fnames = fs.readdirSync(oldUploadsDir);\n      for (const fname of fnames) {\n        this.renameFile(\n          path.join(oldUploadsDir, fname), path.join(this.uploadsDir, fname));\n      }\n\n      fs.rmdirSync(oldUploadsDir);\n    }\n\n    // Create a user config if one doesn't exist.\n    const userConfigPath = path.join(this.configDir, 'local.js');\n    if (!fs.existsSync(userConfigPath)) {\n      fs.writeFileSync(\n        userConfigPath, '\\'use strict\\';\\n\\nmodule.exports = {\\n};');\n    }\n\n    const localConfigPath = path.join(this.gatewayDir, 'config', 'local.js');\n    if (!fs.existsSync(localConfigPath)) {\n      fs.copyFileSync(userConfigPath, localConfigPath);\n    }\n\n    // Move anything that exists in ~/mozilla-iot, such as certbot configs.\n    const oldProfileDir = path.join(os.homedir(), 'mozilla-iot');\n    const oldEtcDir = path.join(oldProfileDir, 'etc');\n    if (fs.existsSync(oldEtcDir) && fs.lstatSync(oldEtcDir).isDirectory()) {\n      pending.push(this.renameDir(oldEtcDir, path.join(this.baseDir, 'etc')));\n    }\n    const oldVarDir = path.join(oldProfileDir, 'var');\n    if (fs.existsSync(oldVarDir) && fs.lstatSync(oldVarDir).isDirectory()) {\n      pending.push(this.renameDir(oldVarDir, path.join(this.baseDir, 'var')));\n    }\n\n    // Move add-ons.\n    if (process.env.NODE_ENV !== 'test') {\n      const oldAddonsDir = path.join(this.gatewayDir, 'build', 'addons');\n      if (fs.existsSync(oldAddonsDir) &&\n          fs.lstatSync(oldAddonsDir).isDirectory()) {\n        const fnames = fs.readdirSync(oldAddonsDir);\n        for (const fname of fnames) {\n          const oldFname = path.join(oldAddonsDir, fname);\n          const newFname = path.join(this.addonsDir, fname);\n          const lstat = fs.lstatSync(oldFname);\n\n          if (fname !== 'plugin' && lstat.isDirectory()) {\n            // Move existing add-ons.\n            pending.push(this.renameDir(oldFname, newFname));\n          }\n        }\n      }\n    }\n    return Promise.all(pending);\n  },\n};\n\nmodule.exports = Profile;\n","/**\n * Various utilities.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nconst crypto = require('crypto');\nconst fs = require('fs');\n\nmodule.exports = {\n  /**\n   * Compute a SHA-256 checksum of a file.\n   *\n   * @param {String} fname File path\n   * @returns A checksum as a lower case hex string.\n   */\n  hashFile: function(fname) {\n    const hash = crypto.createHash('sha256');\n\n    let fd;\n    try {\n      fd = fs.openSync(fname, 'r');\n      const buffer = new Uint8Array(4096);\n\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const bytes = fs.readSync(fd, buffer, 0, 4096);\n        if (bytes <= 0) {\n          break;\n        }\n        hash.update(buffer.slice(0, bytes));\n      }\n    } catch (e) {\n      console.error(e);\n      return null;\n    } finally {\n      if (fd) {\n        fs.closeSync(fd);\n      }\n    }\n\n    return hash.digest('hex').toLowerCase();\n  },\n\n  /**\n   * Escape text such that it's safe to be placed in HTML.\n   */\n  escapeHtml: function(text) {\n    if (typeof text !== 'string') {\n      text = `${text}`;\n    }\n\n    return text\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#039;');\n  },\n};\n","const config = require('config');\nconst express = require('express');\nconst Handlebars = require('handlebars');\nconst bodyParser = require('body-parser');\nconst fs = require('fs');\nconst platform = require('./platform.js');\nconst wifi = require('./wifi.js');\nconst wait = require('./wait.js');\nconst path = require('path');\n\nHandlebars.registerHelper('escapeQuotes', function(str) {\n  return new Handlebars.SafeString(str.replace(/'/, '\\\\\\''));\n});\n\nconst templatesPath = path.join(__dirname, '../../src/wifi-setup/templates');\n\nconst WiFiSetupApp = {};\n// The express server\nconst app = express();\n\n// When we get POSTs, handle the body like this\napp.use(bodyParser.urlencoded({extended: false}));\n\n// Define the handler methods for the various URLs we handle\napp.get('/*', handleCaptive);\napp.get('/', handleRoot);\napp.get('/wifi-setup', handleWiFiSetup);\napp.post('/connecting', handleConnecting);\napp.use(express.static(templatesPath));\n\nWiFiSetupApp.onRequest = app;\n\nfunction getTemplate(filename) {\n  return Handlebars.compile(fs.readFileSync(filename, 'utf8'));\n}\n\nconst wifiSetupTemplate = getTemplate(\n  path.join(templatesPath, 'wifiSetup.handlebars'));\nconst connectingTemplate = getTemplate(\n  path.join(templatesPath, 'connecting.handlebars'));\nconst hotspotTemplate = getTemplate(\n  path.join(templatesPath, 'hotspot.handlebars'));\n\n// When the client issues a GET request for the list of wifi networks\n// scan and return them\n\n// this function handles requests for captive portals\nfunction handleCaptive(request, response, next) {\n  console.log('handleCaptive', request.path);\n  if (request.path === '/hotspot.html') {\n    console.log('sending hotspot.html');\n    response.send(hotspotTemplate({ap_ip: platform.ap_ip}));\n  } else if (request.path === '/hotspot-detect.html' ||\n    request.path === '/connecttest.txt') {\n    console.log('ios or osx captive portal request', request.path);\n    if (request.get('User-Agent').includes('CaptiveNetworkSupport') ||\n        request.get('User-Agent').includes('Microsoft NCSI')) {\n      console.log('windows captive portal request');\n      response.redirect(302, `http://${platform.ap_ip}/hotspot.html`);\n    } else {\n      response.redirect(302, `http://${platform.ap_ip}/wifi-setup`);\n    }\n  } else if (request.path === '/generate_204' || request.path === '/fwlink/') {\n    console.log('android captive portal request');\n    response.redirect(302, `http://${platform.ap_ip}/wifi-setup`);\n  } else if (request.path === '/redirect') {\n    console.log('redirect - send setup for windows');\n    response.redirect(302, `http://${platform.ap_ip}/wifi-setup`);\n  } else {\n    console.log('skipping.');\n    next();\n  }\n}\n\n// This function handles requests for the root URL '/'.\n// We display a different page depending on what stage of setup we're at\nfunction handleRoot(request, response) {\n  wifi.getStatus().then((status) => {\n    // If we don't have a wifi connection yet, display the wifi setup page\n    if (status !== 'COMPLETED') {\n      console.log('no wifi connection; redirecting to wifiSetup');\n      response.redirect('/wifi-setup');\n    } else {\n      // Otherwise, look to see if we have an oauth token yet\n      console.log('wifi setup complete; redirecting /status');\n      response.redirect('/status');\n    }\n  })\n    .catch((e) => {\n      console.error(e);\n    });\n}\n\nfunction handleWiFiSetup(request, response) {\n  wifi.scan().then((results) => {\n    // On Edison, scanning will fail since we're in AP mode at this point\n    // So we'll use the preliminary scan instead\n    if (results.length === 0) {\n      results = wifi.preliminaryScanResults;\n    }\n\n    // XXX\n    // To handle the case where the user entered a bad password and we are\n    // not connected, we should show the networks we know about, and modify\n    // the template to explain that if the user is seeing it, it means\n    // that the network is down or password is bad. This allows the user\n    // to re-enter a network.  Hopefully wpa_supplicant is smart enough\n    // to do the right thing if there are two entries for the same ssid.\n    // If not, we could modify wifi.defineNetwork() to overwrite rather than\n    // just adding.\n    let map1 = [];\n    if (results) {\n      map1 = results.filter((x) => x.length > 7);\n      map1 = map1.map((word) => {\n        let icon = 'wifi-secure.svg';\n        let pwdRequired = true;\n        if (word.substring(3, 5).trim() !== 'on') {\n          icon = 'wifi.svg';\n          pwdRequired = false;\n        }\n        return {\n          icon,\n          pwdRequired,\n          ssid: word.substring(6),\n        };\n      });\n    }\n\n    response.send(wifiSetupTemplate({networks: map1}));\n  });\n}\n\nfunction handleConnecting(request, response) {\n  if (request.body.skip === '1') {\n    const wifiskipPath = path.join(config.get('profileDir'), 'config',\n                                   'wifiskip');\n    fs.closeSync(fs.openSync(wifiskipPath, 'w'));\n    console.log('skip wifi setup. stop the ap');\n    response.send(connectingTemplate({skip: 'true'}));\n    wifi.stopAP()\n      .then(() => wifi.broadcastBeacon())\n      .then(() => {\n        WiFiSetupApp.onConnection();\n      });\n    return;\n  }\n\n  const ssid = request.body.ssid.trim();\n  const password = request.body.password.trim();\n\n  // XXX\n  // We can come back here from the status page if the user defines\n  // more than one network. We always need to call defineNetwork(), but\n  // only need to call stopAP() if we're actually in ap mode.\n  //\n  // Also, if we're not in AP mode, then we should just redirect to\n  // /status instead of sending the connecting template.\n  //\n  response.send(connectingTemplate({skip: 'false'}));\n\n  // Wait before switching networks to make sure the response gets through.\n  // And also wait to be sure that the access point is fully down before\n  // defining the new network. If I only wait two seconds here, it seems\n  // like the Edison takes a really long time to bring up the new network\n  // but a 5 second wait seems to work better.\n  wait(2000)\n    .then(() => wifi.stopAP())\n    .then(() => wait(5000))\n    .then(() => wifi.getKnownNetworks())\n    .then((networks) => {\n      const index = networks.indexOf(ssid);\n      if (index >= 0) {\n        // Remove the existing network. We should be able to update this with\n        // `wpa_cli -iwlan0 new_password <id> \"<psk>\"`, but that doesn't seem\n        // to actually work.\n        return wifi.removeNetwork(index);\n      } else {\n        return Promise.resolve();\n      }\n    })\n    .then(() => wifi.defineNetwork(ssid, password))\n    .then(() => wifi.waitForWiFi(20, 3000))\n    .then(() => wifi.broadcastBeacon())\n    .then(() => {\n      WiFiSetupApp.onConnection();\n    })\n    .catch((error) => {\n      console.log('General Error:', error);\n    });\n}\n\nmodule.exports = WiFiSetupApp;\n","module.exports.wifi = require('./wifi');\nmodule.exports.wifiSetupApp = require('./app');\n","/* eslint-disable */\n/*\n * # Raspberry Pi (we'll treat this as the default)\n * pi@gateway:~ $ uname -a\n * Linux gateway 4.4.13-v7+ #894 SMP Mon Jun 13 13:13:27 BST 2016 armv7l GNU/Linux\n *\n */\n\nconst uname =\n    require('child_process').execFileSync('uname', ['-a'], {encoding: 'utf8'});\n\n/* eslint-enable */\n\nconst platform = require('./platforms/default.js');\n\nmodule.exports = platform;\n","const path = require('path');\n\nmodule.exports = {\n  platform: 'default',\n\n  // ip to be used by the AP\n  ap_ip: '192.168.220.1',\n\n  // A shell command that outputs the string \"COMPLETED\" if we are\n  // connected to a wifi network and outputs something else otherwise\n  getStatus:\n    'wpa_cli -iwlan0 status | sed -n -e \\'/^wpa_state=/{s/wpa_state=//;p;q}\\'',\n\n  // A shell command that outputs the SSID of the current wifi network\n  // or outputs nothing if we are not connected to wifi\n  getConnectedNetwork:\n    'wpa_cli -iwlan0 status | sed -n -e \\'/^ssid=/{s/ssid=//;p;q}\\'',\n\n  // A Python script that scans for wifi networks and outputs the ssids in\n  // order from best signal to worst signal, omitting hidden networks\n  scan: `sudo ${path.join(__dirname, './scan.py')}`,\n\n  // A shell command that lists the names of known wifi networks, one\n  // to a line.\n  getKnownNetworks:\n    // eslint-disable-next-line\n    'wpa_cli -iwlan0 list_networks | sed -e \"1d\" | awk \\'BEGIN {FS=\"\\\\t\"}; {print $2}\\'',\n\n  // Start broadcasting an access point.\n  // The name of the AP is defined in a config file elsewhere\n  // Note that we use different commands on Yocto systems than\n  // we do on Raspbian systems\n  startAP:\n    // eslint-disable-next-line\n    'sudo ifconfig wlan0 $IP; sudo systemctl start hostapd; sudo systemctl start dnsmasq',\n\n  // Stop broadcasting an AP and attempt to reconnect to local wifi\n  stopAP:\n    // eslint-disable-next-line\n    'sudo systemctl stop hostapd; sudo systemctl stop dnsmasq; sudo ifconfig wlan0 0.0.0.0',\n\n  // Remove an existing network. Expects the network ID in the environment\n  // variable ID.\n  removeNetwork:\n    'wpa_cli -iwlan0 remove_network $ID && wpa_cli -iwlan0 save_config',\n\n  // Define a new wifi network. Expects the network name and password\n  // in the environment variables SSID and PSK.\n  defineNetwork:\n    // eslint-disable-next-line\n    'ID=`wpa_cli -iwlan0 add_network` && wpa_cli -iwlan0 set_network $ID ssid \\\\\"$SSID\\\\\" && wpa_cli -iwlan0 set_network $ID psk \\\\\"$PSK\\\\\" && wpa_cli -iwlan0 enable_network $ID && wpa_cli -iwlan0 save_config',\n\n  // Define a new open wifi network. Expects the network name\n  // in the environment variable SSID.\n  defineOpenNetwork:\n    // eslint-disable-next-line\n    'ID=`wpa_cli -iwlan0 add_network` && wpa_cli -iwlan0 set_network $ID ssid \\\\\"$SSID\\\\\" && wpa_cli -iwlan0 set_network $ID key_mgmt NONE && wpa_cli -iwlan0 enable_network $ID && wpa_cli -iwlan0 save_config',\n\n  // Lists configured networks\n  listNetworks: 'wpa_cli -iwlan0 list_networks',\n\n  // Broadcast an Eddystone beacon\n  broadcastBeacon:\n    // eslint-disable-next-line\n    'sudo hciconfig hci0 up && sudo hciconfig hci0 leadv 3 && sudo hcitool -i hci0 cmd',\n};\n","const child_process = require('child_process');\n\nmodule.exports = run;\n\n// A Promise-based version of child_process.exec(). It rejects the\n// promise if there is an error or if there is any output to stderr.\n// Otherwise it resolves the promise to the text that was printed to\n// stdout (with any leading and trailing whitespace removed).\nfunction run(command, environment) {\n  return new Promise(function(resolve, reject) {\n    console.log('Running command:', command);\n    const options = {};\n    if (environment) {\n      options.env = environment;\n    }\n    child_process.exec(command, options, function(error, stdout, stderr) {\n      if (error) {\n        console.log('Error running command:', error);\n        reject(error);\n      } else if (stderr && stderr.length > 0) {\n        console.log('Command wrote to stderr, assuming failure:', stderr);\n        reject(new Error(`${command} output to stderr: ${stderr}`));\n      } else {\n        resolve(stdout.trim());\n      }\n    });\n  });\n}\n","module.exports = function wait(milliseconds) {\n  return new Promise(function(resolve) {\n    setTimeout(resolve, milliseconds);\n  });\n};\n","const config = require('config');\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\nconst run = require('./run.js');\nconst platform = require('./platform.js');\n\nexports.getStatus = getStatus;\nexports.getConnectedNetwork = getConnectedNetwork;\nexports.scan = scan;\nexports.startAP = startAP;\nexports.stopAP = stopAP;\nexports.defineNetwork = defineNetwork;\nexports.removeNetwork = removeNetwork;\nexports.getKnownNetworks = getKnownNetworks;\nexports.broadcastBeacon = broadcastBeacon;\nexports.checkConnection = checkConnection;\nexports.waitForWiFi = waitForWiFi;\n\n// The Edison device can't scan for wifi networks while in AP mode, so\n// we've got to scan before we enter AP mode and save the results. They're a\n// global variable because this code needs to ship\nexports.preliminaryScanResults = [];\n\n\n/**\n * Determine whether we have a wifi connection with the `wpa_cli\n * status` command. This function returns a Promise that resolves to a\n * string.  On my Rasberry Pi, the string is \"DISCONNECTED\" or\n * \"INACTIVE\" when there is no connection and is \"COMPLETED\" when\n * there is a connection. There are other possible string values when\n * a connection is being established\n */\nfunction getStatus() {\n  return run(platform.getStatus);\n}\n\n/**\n * Determine the ssid of the wifi network we are connected to.\n * This function returns a Promise that resolves to a string.\n * The string will be empty if not connected.\n */\nfunction getConnectedNetwork() {\n  return run(platform.getConnectedNetwork);\n}\n\n/**\n * Scan for available wifi networks using `iwlist wlan0 scan`.\n * Returns a Promise that resolves to an array of strings. Each string\n * is the ssid of a wifi network. They are sorted by signal strength from\n * strongest to weakest. On a Raspberry Pi, a scan seems to require root\n * privileges.\n *\n * On a Raspberry Pi 3, this function works when the device is in AP mode.\n * The Intel Edison, however, cannot scan while in AP mode: iwlist fails\n * with an error. iwlist sometimes also fails with an error when the\n * hardware is busy, so this function will try multiple times if you\n * pass a number. If all attempts fail, the promise is resolved to\n * an empty array.\n */\nfunction scan(numAttempts) {\n  numAttempts = numAttempts || 1;\n  return new Promise(function(resolve) {\n    let attempts = 0;\n\n    function tryScan() {\n      attempts++;\n\n      _scan()\n        .then((out) => {\n          resolve(out.length ? out.split('\\n') : []);\n        })\n        .catch((err) => {\n          console.error('Scan attempt', attempts, 'failed:',\n                        err.message || err);\n\n          if (attempts >= numAttempts) {\n            console.error('Giving up. No scan results available.');\n            resolve([]);\n          } else {\n            console.error('Will try again in 3 seconds.');\n            setTimeout(tryScan, 3000);\n          }\n        });\n    }\n\n    tryScan();\n  });\n\n  function _scan() {\n    return run(platform.scan);\n  }\n}\n\n/**\n * Enable an access point that users can connect to to configure the device.\n *\n * This command runs different commands on Raspbery Pi Rasbian and Edison Yocto.\n *\n * It requires that hostapd and udhcpd are installed on the system but not\n * enabled, so that they do not automatically run when the device boots up.\n * It also requires that hostapd and udhcpd have appropriate config files\n * that define the ssid for the wifi network to be created, for example.\n * Also, the udhcpd config file should be set up to work with the IP address\n * of the device.\n *\n * XXX\n * It would probably be better if the IP address, SSID and password were\n * options to this function rather than being hardcoded in system config\n * files. (Each device ought to be able to add a random number to its\n * SSID, for example, so that when you've got multiple devices they don't\n * all try to create the same network).\n *\n * This function returns a Promise that resolves when the necessary\n * commands have been run.  This does not necessarily mean that the AP\n * will be functional, however. The setup process might take a few\n * seconds to complete before the user will be able to see and connect\n * to the network.\n */\nfunction startAP(ip) {\n  return run(platform.startAP, {IP: ip});\n}\n\n/**\n * Like startAP(), but take the access point down, using platform-dependent\n * commands.\n *\n * Returns a promise that resolves when the commands have been run. At\n * this point, the AP should be in the process of stopping but may not\n * yet be completely down.\n */\nfunction stopAP() {\n  return run(platform.stopAP);\n}\n\n/**\n * This function uses wpa_cli to add the specified network ssid and password\n * to the wpa_supplicant.conf file. This assumes that wpa_supplicant is\n * configured to run automatically at boot time and is configured to work\n * with wpa_cli.\n *\n * If the system is not connected to a wifi network, calling this\n * command with a valid ssid and password should cause it to connect.\n */\nfunction defineNetwork(ssid, password) {\n  return run(password ? platform.defineNetwork : platform.defineOpenNetwork, {\n    SSID: ssid,\n    PSK: password,\n  });\n}\n\n/**\n * This function uses wpa_cli to remove the network with the given ID.\n */\nfunction removeNetwork(id) {\n  return run(platform.removeNetwork, {ID: id});\n}\n\n/**\n * Return a Promise that resolves to an array of known wifi network names\n */\nfunction getKnownNetworks() {\n  return run(platform.getKnownNetworks)\n    .then((out) => out.length ? out.split('\\n') : []);\n}\n\n/**\n * Broadcast a Bluetooth Eddystone beacon with the local IP address.\n */\nfunction broadcastBeacon() {\n  let cmd = platform.broadcastBeacon;\n\n  let ip = null;\n  const ifaces = os.networkInterfaces();\n\n  // Check out wlan0 first.\n  if (ifaces.hasOwnProperty('wlan0')) {\n    for (const addr of ifaces.wlan0) {\n      if (addr.family !== 'IPv4' || addr.internal) {\n        continue;\n      }\n\n      ip = addr.address;\n      break;\n    }\n  }\n\n  // If we didn't get an IP address, check out eth0.\n  if (ip === null && ifaces.hasOwnProperty('eth0')) {\n    for (const addr of ifaces.eth0) {\n      if (addr.family !== 'IPv4' || addr.internal) {\n        continue;\n      }\n\n      ip = addr.address;\n      break;\n    }\n  }\n\n  // If we still don't have an IP, bail.\n  if (ip === null) {\n    // Don't reject, as this isn't really critical.\n    return Promise.resolve();\n  }\n\n  // OGF + OCF\n  cmd += ' 0x08 0x0008';\n\n  // Length byte\n  const length1 = 14 + ip.length;\n  cmd += ` ${length1.toString(16)}`;\n\n  // Flags\n  cmd += ' 02 01 06';\n\n  // UUIDs\n  cmd += ' 03 03 aa fe';\n\n  // Length byte\n  const length2 = 6 + ip.length;\n  cmd += ` ${length2.toString(16)}`;\n\n  // Service data type value\n  cmd += ' 16';\n\n  // UUIDs\n  cmd += ' aa fe';\n\n  // Frame type\n  cmd += ' 10';\n\n  // TX power\n  cmd += ' 00';\n\n  // URL scheme\n  cmd += ' 02';\n\n  // URL\n  cmd += ` ${ip.split('').map((x) => x.charCodeAt(0).toString(16)).join(' ')}`;\n\n  // Trailer\n  cmd += ' 00 00 00 00 00 00 00 00';\n\n  return run(cmd);\n}\n\nfunction checkConnection() {\n  const wifiskipPath = path.join(config.get('profileDir'), 'config',\n                                 'wifiskip');\n  if (fs.existsSync(wifiskipPath)) {\n    return Promise.resolve(true);\n  }\n  return getStatus().then(() => {\n    // Wait until we have a working wifi connection. Retry every 3 seconds up\n    // to 10 times. If we are connected, then start the Gateway client.\n    // If we never get a wifi connection, go into AP mode.\n    // Before we start, though, let the user know that something is happening\n    return waitForWiFi(20, 3000).then(() => {\n      return true;\n    }).catch((err) => {\n      console.log('No wifi connection found. Starting the AP...', err);\n      // Scan for wifi networks now because we can't always scan once\n      // the AP is being broadcast, retrying up to 10 times\n      scan(10).then((ssids) => {\n        exports.preliminaryScanResults = ssids; // Remember ssids\n        console.log('No wifi found; entering AP mode');\n        startAP(platform.ap_ip);\n      });\n\n      return false;\n    });\n  }).catch((err) => {\n    console.error('Error checking wifi adapter presence', err);\n    return true;\n  });\n}\n\n// Return a promise, then check every interval ms for a wifi connection.\n// Resolve the promise when we're connected. Or, if we aren't connected\n// after maxAttempts attempts, then reject the promise\nfunction waitForWiFi(maxAttempts, interval) {\n  return new Promise(function(resolve, reject) {\n    let attempts = 0;\n\n    // first of all we query wpa_supplicant if there's a wifi AP configured\n    run(platform.listNetworks)\n      .then((out) => {\n        console.log('List Networks command executed:', out);\n        if (out.includes('\\n0\\t')) {\n          // there's at least one wifi AP configured. Let's wait to see if it\n          // will connect\n          check();\n        } else {\n          // No wifi AP configured. Let's skip the wait and start the setup\n          // immediately\n          reject();\n        }\n      })\n      .catch((err) => console.error('Error listing Networks:', err));\n\n\n    function check() {\n      attempts++;\n      console.log('check', attempts);\n      getStatus()\n        .then((status) => {\n          console.log(status);\n          if (status === 'COMPLETED') {\n            console.log('WiFi connection found. resolving');\n            checkForAddress();\n            console.log('resolved');\n          } else {\n            console.log('No wifi connection on attempt', attempts);\n            retryOrGiveUp();\n          }\n        })\n        .catch((err) => {\n          console.error('Error checking wifi on attempt', attempts, ':', err);\n          retryOrGiveUp();\n        });\n    }\n\n    function checkForAddress() {\n      const ifaces = os.networkInterfaces();\n\n      if (ifaces.hasOwnProperty('wlan0')) {\n        for (const addr of ifaces.wlan0) {\n          if (addr.family !== 'IPv4' || addr.internal) {\n            continue;\n          }\n\n          resolve();\n          return;\n        }\n      }\n\n      retryOrGiveUp();\n    }\n\n    function retryOrGiveUp() {\n      if (attempts >= maxAttempts) {\n        console.error('Giving up. No wifi available.');\n        reject();\n      } else {\n        setTimeout(check, interval);\n      }\n    }\n  });\n}\n","module.exports = require(\"ajv\");","module.exports = require(\"archiver\");","module.exports = require(\"asn1.js\");","module.exports = require(\"assert\");","module.exports = require(\"bcryptjs\");","module.exports = require(\"body-parser\");","module.exports = require(\"callsites\");","module.exports = require(\"child_process\");","module.exports = require(\"compression\");","module.exports = require(\"config\");","module.exports = require(\"crypto\");","module.exports = require(\"dnssd\");","module.exports = require(\"event-to-promise\");","module.exports = require(\"events\");","module.exports = require(\"express\");","module.exports = require(\"express-fileupload\");","module.exports = require(\"express-handlebars\");","module.exports = require(\"express-promise-router\");","module.exports = require(\"express-ws\");","module.exports = require(\"fs\");","module.exports = require(\"gateway-addon\");","module.exports = require(\"greenlock\");","module.exports = require(\"handlebars\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"ip-regex\");","module.exports = require(\"jsonwebtoken\");","module.exports = require(\"le-challenge-dns\");","module.exports = require(\"le-store-certbot\");","module.exports = require(\"mkdirp\");","module.exports = require(\"nanomsg\");","module.exports = require(\"ncp\");","module.exports = require(\"net\");","module.exports = require(\"nocache\");","module.exports = require(\"node-fetch\");","module.exports = require(\"node-getopt\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"process\");","module.exports = require(\"promisepipe\");","module.exports = require(\"readline\");","module.exports = require(\"rimraf\");","module.exports = require(\"semver\");","module.exports = require(\"sqlite3\");","module.exports = require(\"string-format\");","module.exports = require(\"tar\");","module.exports = require(\"tmp\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"uuid\");","module.exports = require(\"web-push\");","module.exports = require(\"winston\");","module.exports = require(\"winston-daily-rotate-file\");","module.exports = require(\"ws\");"],"sourceRoot":""}